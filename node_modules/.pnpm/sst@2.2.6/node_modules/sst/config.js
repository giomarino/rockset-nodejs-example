import { DeleteParameterCommand, GetParameterCommand, GetParametersByPathCommand, PutParameterCommand, SSMClient, } from "@aws-sdk/client-ssm";
import { GetFunctionConfigurationCommand, LambdaClient, UpdateFunctionConfigurationCommand, } from "@aws-sdk/client-lambda";
import { pipe, map } from "remeda";
import { useProject } from "./project.js";
import { useAWSClient } from "./credentials.js";
import { Stacks } from "./stacks/index.js";
export var Config;
(function (Config) {
    async function parameters() {
        const result = [];
        for await (const p of scan(PREFIX.FALLBACK)) {
            const parsed = parse(p.Name);
            if (parsed.type === "secrets")
                continue;
            result.push({
                ...parsed,
                value: p.Value,
            });
        }
        for await (const p of scan(PREFIX.STAGE)) {
            const parsed = parse(p.Name);
            if (parsed.type === "secrets")
                continue;
            result.push({
                ...parsed,
                value: p.Value,
            });
        }
        return result;
    }
    Config.parameters = parameters;
    function envFor(input) {
        return `SST_${input.type}_${input.prop}_${normalizeID(input.id)}`;
    }
    Config.envFor = envFor;
    function pathFor(input) {
        return `${input.fallback ? PREFIX.FALLBACK : PREFIX.STAGE}${input.type}/${normalizeID(input.id)}/${input.prop}`;
    }
    Config.pathFor = pathFor;
    function normalizeID(input) {
        return input.replace(/-/g, "_");
    }
    Config.normalizeID = normalizeID;
    async function secrets() {
        const result = {};
        for await (const p of scan(PREFIX.STAGE + "Secret")) {
            const parsed = parse(p.Name);
            if (!result[parsed.id])
                result[parsed.id] = {};
            result[parsed.id].value = p.Value;
        }
        for await (const p of scan(PREFIX.FALLBACK + "Secret")) {
            const parsed = parse(p.Name);
            if (!result[parsed.id])
                result[parsed.id] = {};
            result[parsed.id].fallback = p.Value;
        }
        return result;
    }
    Config.secrets = secrets;
    async function env() {
        const project = useProject();
        const parameters = await Config.parameters();
        const env = {
            SST_APP: project.config.name,
            SST_STAGE: project.config.stage,
            ...pipe(parameters, map((p) => [envFor(p), p.value]), Object.fromEntries),
        };
        return env;
    }
    Config.env = env;
    async function setSecret(input) {
        const ssm = useAWSClient(SSMClient);
        const result = await ssm.send(new PutParameterCommand({
            Name: pathFor({
                id: input.key,
                type: "Secret",
                prop: "value",
                fallback: input.fallback,
            }),
            Value: input.value,
            Type: "SecureString",
            Overwrite: true,
        }));
    }
    Config.setSecret = setSecret;
    async function getSecret(input) {
        const ssm = useAWSClient(SSMClient);
        const result = await ssm.send(new GetParameterCommand({
            Name: pathFor({
                id: input.key,
                prop: "value",
                type: "Secret",
                fallback: input.fallback,
            }),
            WithDecryption: true,
        }));
        return result.Parameter?.Value;
    }
    Config.getSecret = getSecret;
    async function removeSecret(input) {
        const ssm = useAWSClient(SSMClient);
        await ssm.send(new DeleteParameterCommand({
            Name: pathFor({
                id: input.key,
                type: "Secret",
                prop: "value",
                fallback: input.fallback,
            }),
        }));
    }
    Config.removeSecret = removeSecret;
    async function restart(key) {
        const lambda = useAWSClient(LambdaClient);
        const metadata = await Stacks.metadata();
        const filtered = Object.values(metadata)
            .flat()
            .filter((f) => f.type === "Function")
            .filter((f) => f.data.secrets.includes(key));
        const restarted = await Promise.all(filtered.map(async (f) => {
            // Note: in the case where the function is removed, but the metadata
            //       is not updated, we ignore the Function not found error.
            try {
                const config = await lambda.send(new GetFunctionConfigurationCommand({
                    FunctionName: f.data.arn,
                }));
                await lambda.send(new UpdateFunctionConfigurationCommand({
                    FunctionName: f.data.arn,
                    Environment: {
                        Variables: {
                            ...(config.Environment?.Variables || {}),
                            [SECRET_UPDATED_AT_ENV]: Date.now().toString(),
                        },
                    },
                }));
                return true;
            }
            catch (e) {
                if (e.name === "ResourceNotFoundException" &&
                    e.message.startsWith("Function not found")) {
                    return;
                }
            }
        }));
        return restarted.filter(Boolean).length;
    }
    Config.restart = restart;
})(Config || (Config = {}));
async function* scan(prefix) {
    const ssm = useAWSClient(SSMClient);
    let token;
    while (true) {
        const results = await ssm.send(new GetParametersByPathCommand({
            Path: prefix,
            WithDecryption: true,
            Recursive: true,
            NextToken: token,
        }));
        yield* results.Parameters || [];
        if (!results.NextToken)
            break;
        token = results.NextToken;
    }
}
const FALLBACK_STAGE = ".fallback";
const SECRET_UPDATED_AT_ENV = "SST_ADMIN_SECRET_UPDATED_AT";
const PREFIX = {
    get STAGE() {
        const project = useProject();
        return `/sst/${project.config.name}/${project.config.stage}/`;
    },
    get FALLBACK() {
        const project = useProject();
        return `/sst/${project.config.name}/${FALLBACK_STAGE}/`;
    },
};
function parse(ssmName) {
    const parts = ssmName.split("/");
    return {
        type: parts[4],
        id: parts[5],
        prop: parts.slice(6).join("/"),
    };
}
