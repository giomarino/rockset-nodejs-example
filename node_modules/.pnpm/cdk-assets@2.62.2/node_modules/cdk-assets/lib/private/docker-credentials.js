"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.obtainEcrCredentials = exports.fetchDockerLoginCredentials = exports.cdkCredentialsConfig = exports.cdkCredentialsConfigFile = void 0;
const fs = require("fs");
const os = require("os");
const path = require("path");
/** Returns the presumed location of the CDK Docker credentials config file */
function cdkCredentialsConfigFile() {
    return process.env.CDK_DOCKER_CREDS_FILE ?? path.join((os.userInfo().homedir ?? os.homedir()).trim() || '/', '.cdk', 'cdk-docker-creds.json');
}
exports.cdkCredentialsConfigFile = cdkCredentialsConfigFile;
let _cdkCredentials;
/** Loads and parses the CDK Docker credentials configuration, if it exists. */
function cdkCredentialsConfig() {
    if (!_cdkCredentials) {
        try {
            _cdkCredentials = JSON.parse(fs.readFileSync(cdkCredentialsConfigFile(), { encoding: 'utf-8' }));
        }
        catch (err) { }
    }
    return _cdkCredentials;
}
exports.cdkCredentialsConfig = cdkCredentialsConfig;
/** Fetches login credentials from the configured source (e.g., SecretsManager, ECR) */
async function fetchDockerLoginCredentials(aws, config, endpoint) {
    // Paranoid handling to ensure new URL() doesn't throw if the schema is missing
    // For official docker registry, docker will pass https://index.docker.io/v1/
    endpoint = endpoint.includes('://') ? endpoint : `https://${endpoint}`;
    const domain = new URL(endpoint).hostname;
    if (!Object.keys(config.domainCredentials).includes(domain) && !Object.keys(config.domainCredentials).includes(endpoint)) {
        throw new Error(`unknown domain ${domain}`);
    }
    let domainConfig = config.domainCredentials[domain] ?? config.domainCredentials[endpoint];
    if (domainConfig.secretsManagerSecretId) {
        const sm = await aws.secretsManagerClient({ assumeRoleArn: domainConfig.assumeRoleArn });
        const secretValue = await sm.getSecretValue({ SecretId: domainConfig.secretsManagerSecretId }).promise();
        if (!secretValue.SecretString) {
            throw new Error(`unable to fetch SecretString from secret: ${domainConfig.secretsManagerSecretId}`);
        }
        ;
        const secret = JSON.parse(secretValue.SecretString);
        const usernameField = domainConfig.secretsUsernameField ?? 'username';
        const secretField = domainConfig.secretsPasswordField ?? 'secret';
        if (!secret[usernameField] || !secret[secretField]) {
            throw new Error(`malformed secret string ("${usernameField}" or "${secretField}" field missing)`);
        }
        return { Username: secret[usernameField], Secret: secret[secretField] };
    }
    else if (domainConfig.ecrRepository) {
        const ecr = await aws.ecrClient({ assumeRoleArn: domainConfig.assumeRoleArn });
        const ecrAuthData = await obtainEcrCredentials(ecr);
        return { Username: ecrAuthData.username, Secret: ecrAuthData.password };
    }
    else {
        throw new Error('unknown credential type: no secret ID or ECR repo');
    }
}
exports.fetchDockerLoginCredentials = fetchDockerLoginCredentials;
async function obtainEcrCredentials(ecr, logger) {
    if (logger) {
        logger('Fetching ECR authorization token');
    }
    const authData = (await ecr.getAuthorizationToken({}).promise()).authorizationData || [];
    if (authData.length === 0) {
        throw new Error('No authorization data received from ECR');
    }
    const token = Buffer.from(authData[0].authorizationToken, 'base64').toString('ascii');
    const [username, password] = token.split(':');
    if (!username || !password) {
        throw new Error('unexpected ECR authData format');
    }
    return {
        username,
        password,
        endpoint: authData[0].proxyEndpoint,
    };
}
exports.obtainEcrCredentials = obtainEcrCredentials;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLWNyZWRlbnRpYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLWNyZWRlbnRpYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsNkJBQTZCO0FBc0I3Qiw4RUFBOEU7QUFDOUUsU0FBZ0Isd0JBQXdCO0lBQ3RDLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxHQUFHLEVBQUUsTUFBTSxFQUFFLHVCQUF1QixDQUFDLENBQUM7QUFDaEosQ0FBQztBQUZELDREQUVDO0FBRUQsSUFBSSxlQUFvRCxDQUFDO0FBQ3pELCtFQUErRTtBQUMvRSxTQUFnQixvQkFBb0I7SUFDbEMsSUFBSSxDQUFDLGVBQWUsRUFBRTtRQUNwQixJQUFJO1lBQ0YsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyx3QkFBd0IsRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQTRCLENBQUM7U0FDN0g7UUFBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0tBQ2xCO0lBQ0QsT0FBTyxlQUFlLENBQUM7QUFDekIsQ0FBQztBQVBELG9EQU9DO0FBRUQsdUZBQXVGO0FBQ2hGLEtBQUssVUFBVSwyQkFBMkIsQ0FBQyxHQUFTLEVBQUUsTUFBK0IsRUFBRSxRQUFnQjtJQUM1RywrRUFBK0U7SUFDL0UsNkVBQTZFO0lBQzdFLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFdBQVcsUUFBUSxFQUFFLENBQUM7SUFDdkUsTUFBTSxNQUFNLEdBQUcsSUFB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LENBQUMsQ0FBQyxDQUFDLGtCQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2RixNQUFNLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztLQUFFO0lBRWxGLE9BQU87UUFDTCxRQUFRO1FBQ1IsUUFBUTtRQUNSLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYztLQUNyQyxDQUFDO0FBQ0osQ0FBQztBQWZELG9EQWVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IElBd3MgfSBmcm9tICcuLi9hd3MnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi9zaGVsbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyQ3JlZGVudGlhbHMge1xuICByZWFkb25seSBVc2VybmFtZTogc3RyaW5nO1xuICByZWFkb25seSBTZWNyZXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2NrZXJDcmVkZW50aWFsc0NvbmZpZyB7XG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcmVhZG9ubHkgZG9tYWluQ3JlZGVudGlhbHM6IFJlY29yZDxzdHJpbmcsIERvY2tlckRvbWFpbkNyZWRlbnRpYWxTb3VyY2U+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY2tlckRvbWFpbkNyZWRlbnRpYWxTb3VyY2Uge1xuICByZWFkb25seSBzZWNyZXRzTWFuYWdlclNlY3JldElkPzogc3RyaW5nO1xuICByZWFkb25seSBzZWNyZXRzVXNlcm5hbWVGaWVsZD86IHN0cmluZztcbiAgcmVhZG9ubHkgc2VjcmV0c1Bhc3N3b3JkRmllbGQ/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGVjclJlcG9zaXRvcnk/OiBib29sZWFuO1xuICByZWFkb25seSBhc3N1bWVSb2xlQXJuPzogc3RyaW5nO1xufVxuXG4vKiogUmV0dXJucyB0aGUgcHJlc3VtZWQgbG9jYXRpb24gb2YgdGhlIENESyBEb2NrZXIgY3JlZGVudGlhbHMgY29uZmlnIGZpbGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBjZGtDcmVkZW50aWFsc0NvbmZpZ0ZpbGUoKTogc3RyaW5nIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkNES19ET0NLRVJfQ1JFRFNfRklMRSA/PyBwYXRoLmpvaW4oKG9zLnVzZXJJbmZvKCkuaG9tZWRpciA/PyBvcy5ob21lZGlyKCkpLnRyaW0oKSB8fCAnLycsICcuY2RrJywgJ2Nkay1kb2NrZXItY3JlZHMuanNvbicpO1xufVxuXG5sZXQgX2Nka0NyZWRlbnRpYWxzOiBEb2NrZXJDcmVkZW50aWFsc0NvbmZpZyB8IHVuZGVmaW5lZDtcbi8qKiBMb2FkcyBhbmQgcGFyc2VzIHRoZSBDREsgRG9ja2VyIGNyZWRlbnRpYWxzIGNvbmZpZ3VyYXRpb24sIGlmIGl0IGV4aXN0cy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZGtDcmVkZW50aWFsc0NvbmZpZygpOiBEb2NrZXJDcmVkZW50aWFsc0NvbmZpZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghX2Nka0NyZWRlbnRpYWxzKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9jZGtDcmVkZW50aWFscyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGNka0NyZWRlbnRpYWxzQ29uZmlnRmlsZSgpLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pKSBhcyBEb2NrZXJDcmVkZW50aWFsc0NvbmZpZztcbiAgICB9IGNhdGNoIChlcnIpIHsgfVxuICB9XG4gIHJldHVybiBfY2RrQ3JlZGVudGlhbHM7XG59XG5cbi8qKiBGZXRjaGVzIGxvZ2luIGNyZWRlbnRpYWxzIGZyb20gdGhlIGNvbmZpZ3VyZWQgc291cmNlIChlLmcuLCBTZWNyZXRzTWFuYWdlciwgRUNSKSAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRG9ja2VyTG9naW5DcmVkZW50aWFscyhhd3M6IElBd3MsIGNvbmZpZzogRG9ja2VyQ3JlZGVudGlhbHNDb25maWcsIGVuZHBvaW50OiBzdHJpbmcpIHtcbiAgLy8gUGFyYW5vaWQgaGFuZGxpbmcgdG8gZW5zdXJlIG5ldyBVUkwoKSBkb2Vzbid0IHRocm93IGlmIHRoZSBzY2hlbWEgaXMgbWlzc2luZ1xuICAvLyBGb3Igb2ZmaWNpYWwgZG9ja2VyIHJlZ2lzdHJ5LCBkb2NrZXIgd2lsbCBwYXNzIGh0dHBzOi8vaW5kZXguZG9ja2VyLmlvL3YxL1xuICBlbmRwb2ludCA9IGVuZHBvaW50LmluY2x1ZGVzKCc6Ly8nKSA/IGVuZHBvaW50IDogYGh0dHBzOi8vJHtlbmRwb2ludH1gO1xuICBjb25zdCBkb21haW4gPSBuZXcgVVJMKGVuZHBvaW50KS5ob3N0bmFtZTtcblxuICBpZiAoIU9iamVjdC5rZXlzKGNvbmZpZy5kb21haW5DcmVkZW50aWFscykuaW5jbHVkZXMoZG9tYWluKSAmJiAhT2JqZWN0LmtleXMoY29uZmlnLmRvbWFpbkNyZWRlbnRpYWxzKS5pbmNsdWRlcyhlbmRwb2ludCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gZG9tYWluICR7ZG9tYWlufWApO1xuICB9XG5cbiAgbGV0IGRvbWFpbkNvbmZpZyA9IGNvbmZpZy5kb21haW5DcmVkZW50aWFsc1tkb21haW5dID8/IGNvbmZpZy5kb21haW5DcmVkZW50aWFsc1tlbmRwb2ludF07XG5cbiAgaWYgKGRvbWFpbkNvbmZpZy5zZWNyZXRzTWFuYWdlclNlY3JldElkKSB7XG4gICAgY29uc3Qgc20gPSBhd2FpdCBhd3Muc2VjcmV0c01hbmFnZXJDbGllbnQoeyBhc3N1bWVSb2xlQXJuOiBkb21haW5Db25maWcuYXNzdW1lUm9sZUFybiB9KTtcbiAgICBjb25zdCBzZWNyZXRWYWx1ZSA9IGF3YWl0IHNtLmdldFNlY3JldFZhbHVlKHsgU2VjcmV0SWQ6IGRvbWFpbkNvbmZpZy5zZWNyZXRzTWFuYWdlclNlY3JldElkIH0pLnByb21pc2UoKTtcbiAgICBpZiAoIXNlY3JldFZhbHVlLlNlY3JldFN0cmluZykgeyB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBmZXRjaCBTZWNyZXRTdHJpbmcgZnJvbSBzZWNyZXQ6ICR7ZG9tYWluQ29uZmlnLnNlY3JldHNNYW5hZ2VyU2VjcmV0SWR9YCk7IH07XG5cbiAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKHNlY3JldFZhbHVlLlNlY3JldFN0cmluZyk7XG5cbiAgICBjb25zdCB1c2VybmFtZUZpZWxkID0gZG9tYWluQ29uZmlnLnNlY3JldHNVc2VybmFtZUZpZWxkID8/ICd1c2VybmFtZSc7XG4gICAgY29uc3Qgc2VjcmV0RmllbGQgPSBkb21haW5Db25maWcuc2VjcmV0c1Bhc3N3b3JkRmllbGQgPz8gJ3NlY3JldCc7XG4gICAgaWYgKCFzZWNyZXRbdXNlcm5hbWVGaWVsZF0gfHwgIXNlY3JldFtzZWNyZXRGaWVsZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWFsZm9ybWVkIHNlY3JldCBzdHJpbmcgKFwiJHt1c2VybmFtZUZpZWxkfVwiIG9yIFwiJHtzZWNyZXRGaWVsZH1cIiBmaWVsZCBtaXNzaW5nKWApO1xuICAgIH1cblxuICAgIHJldHVybiB7IFVzZXJuYW1lOiBzZWNyZXRbdXNlcm5hbWVGaWVsZF0sIFNlY3JldDogc2VjcmV0W3NlY3JldEZpZWxkXSB9O1xuICB9IGVsc2UgaWYgKGRvbWFpbkNvbmZpZy5lY3JSZXBvc2l0b3J5KSB7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgYXdzLmVjckNsaWVudCh7IGFzc3VtZVJvbGVBcm46IGRvbWFpbkNvbmZpZy5hc3N1bWVSb2xlQXJuIH0pO1xuICAgIGNvbnN0IGVjckF1dGhEYXRhID0gYXdhaXQgb2J0YWluRWNyQ3JlZGVudGlhbHMoZWNyKTtcblxuICAgIHJldHVybiB7IFVzZXJuYW1lOiBlY3JBdXRoRGF0YS51c2VybmFtZSwgU2VjcmV0OiBlY3JBdXRoRGF0YS5wYXNzd29yZCB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjcmVkZW50aWFsIHR5cGU6IG5vIHNlY3JldCBJRCBvciBFQ1IgcmVwbycpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvYnRhaW5FY3JDcmVkZW50aWFscyhlY3I6IEFXUy5FQ1IsIGxvZ2dlcj86IExvZ2dlcikge1xuICBpZiAobG9nZ2VyKSB7IGxvZ2dlcignRmV0Y2hpbmcgRUNSIGF1dGhvcml6YXRpb24gdG9rZW4nKTsgfVxuICBjb25zdCBhdXRoRGF0YSA9IChhd2FpdCBlY3IuZ2V0QXV0aG9yaXphdGlvblRva2VuKHsgfSkucHJvbWlzZSgpKS5hdXRob3JpemF0aW9uRGF0YSB8fCBbXTtcbiAgaWYgKGF1dGhEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gYXV0aG9yaXphdGlvbiBkYXRhIHJlY2VpdmVkIGZyb20gRUNSJyk7XG4gIH1cbiAgY29uc3QgdG9rZW4gPSBCdWZmZXIuZnJvbShhdXRoRGF0YVswXS5hdXRob3JpemF0aW9uVG9rZW4hLCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJyk7XG4gIGNvbnN0IFt1c2VybmFtZSwgcGFzc3dvcmRdID0gdG9rZW4uc3BsaXQoJzonKTtcbiAgaWYgKCF1c2VybmFtZSB8fCAhcGFzc3dvcmQpIHsgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIEVDUiBhdXRoRGF0YSBmb3JtYXQnKTsgfVxuXG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWUsXG4gICAgcGFzc3dvcmQsXG4gICAgZW5kcG9pbnQ6IGF1dGhEYXRhWzBdLnByb3h5RW5kcG9pbnQhLFxuICB9O1xufVxuIl19