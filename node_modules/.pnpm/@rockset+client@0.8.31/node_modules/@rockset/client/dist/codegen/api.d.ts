/**
 * REST API
 * Rockset's REST API allows for creating and managing all resources in Rockset. Each supported endpoint is documented below.  All requests must be authorized with a Rockset API key, which can be created in the [Rockset console](https://console.rockset.com). The API key must be provided as `ApiKey <api_key>` in the `Authorization` request header. For example: ``` Authorization: ApiKey aB35kDjg93J5nsf4GjwMeErAVd832F7ad4vhsW1S02kfZiab42sTsfW5Sxt25asT ```  All endpoints are only accessible via https.  Build something awesome!
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import { Configuration } from "./configuration";
/**
 *
 * @export
 */
export declare const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}
/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}
/**
 *
 * @export
 * @class BaseAPI
 */
export declare class BaseAPI {
    protected basePath: string;
    protected fetch: FetchAPI;
    protected configuration: Configuration;
    constructor(configuration?: Configuration, basePath?: string, fetch?: FetchAPI);
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export declare class RequiredError extends Error {
    field: string;
    name: "RequiredError";
    constructor(field: string, msg?: string);
}
/**
 *
 * @export
 * @interface AddDocumentsRequest
 */
export interface AddDocumentsRequest {
    /**
     * Array of documents to be added to the collection.
     * @type {Array<any>}
     * @memberof AddDocumentsRequest
     */
    data: Array<any>;
}
/**
 *
 * @export
 * @interface AddDocumentsResponse
 */
export interface AddDocumentsResponse {
    /**
     * Information about the added documents.
     * @type {Array<DocumentStatus>}
     * @memberof AddDocumentsResponse
     */
    data?: Array<DocumentStatus>;
}
/**
 *
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     * Name of the alias.
     * @type {string}
     * @memberof Alias
     */
    name?: string;
    /**
     * Alias description.
     * @type {string}
     * @memberof Alias
     */
    description?: string;
    /**
     * Name of the workspace.
     * @type {string}
     * @memberof Alias
     */
    workspace?: string;
    /**
     * Email of the creator.
     * @type {string}
     * @memberof Alias
     */
    creator_email?: string;
    /**
     * List of fully qualified collection names referenced by alias.
     * @type {Array<string>}
     * @memberof Alias
     */
    collections?: Array<string>;
    /**
     * State of the alias.
     * @type {string}
     * @memberof Alias
     */
    state?: Alias.StateEnum;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Alias
     */
    created_at?: string;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Alias
     */
    modified_at?: string;
}
/**
 * @export
 * @namespace Alias
 */
export declare namespace Alias {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        CREATED,
        DELETED
    }
}
/**
 * API keys are used to authenticate requests to Rockset's API. An API key is tied to the user who creates it.
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * Date that API key was created (ISO-8601 format).
     * @type {string}
     * @memberof ApiKey
     */
    created_at?: string;
    /**
     * Name of the API key.
     * @type {string}
     * @memberof ApiKey
     */
    name: string;
    /**
     * API key string of 64 alphanumeric characters.
     * @type {string}
     * @memberof ApiKey
     */
    key: string;
    /**
     * Date that API key was most recently used (ISO-8601 format).
     * @type {string}
     * @memberof ApiKey
     */
    last_access_time?: string;
    /**
     * The expiration date of this API key.
     * @type {string}
     * @memberof ApiKey
     */
    expiry_time?: string;
    /**
     * Role specifying access control. If not specified, API key will have access to all of the associated user's roles.
     * @type {string}
     * @memberof ApiKey
     */
    role?: string;
    /**
     * Email of API key owner.
     * @type {string}
     * @memberof ApiKey
     */
    created_by?: string;
    /**
     * Current state of this key.
     * @type {string}
     * @memberof ApiKey
     */
    state?: ApiKey.StateEnum;
}
/**
 * @export
 * @namespace ApiKey
 */
export declare namespace ApiKey {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        ACTIVE,
        SUSPENDED
    }
}
/**
 *
 * @export
 * @interface AsyncQueryOptions
 */
export interface AsyncQueryOptions {
    /**
     * The maximum amount of time that the client is willing to wait for the query to complete. If the query is not complete by this timeout, a response will be returned with a `query_id` that can be used to check the status of the query and retrieve results once the query has completed.
     * @type {number}
     * @memberof AsyncQueryOptions
     */
    client_timeout_ms?: number;
    /**
     * The maximum amount of time that the system will attempt to complete query execution before aborting the query and returning an error.
     * @type {number}
     * @memberof AsyncQueryOptions
     */
    timeout_ms?: number;
    /**
     * The maximum number of results you will receive as a client. If the query exceeds this limit, the remaining results can be requested using a returned pagination cursor. In addition, there is a maximum response size of 100MiB so fewer than `max_results` may be returned.
     * @type {number}
     * @memberof AsyncQueryOptions
     */
    max_initial_results?: number;
}
/**
 *
 * @export
 * @interface AvroParams
 */
export interface AvroParams {
}
/**
 *
 * @export
 * @interface AwsAccessKey
 */
export interface AwsAccessKey {
    /**
     * AWS access key ID.
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_access_key_id: string;
    /**
     * AWS secret access key.
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_secret_access_key: string;
}
/**
 *
 * @export
 * @interface AwsRole
 */
export interface AwsRole {
    /**
     * ARN of rockset-role created in your account.
     * @type {string}
     * @memberof AwsRole
     */
    aws_role_arn: string;
    /**
     * External id used for integration.
     * @type {string}
     * @memberof AwsRole
     */
    aws_external_id?: string;
}
/**
 *
 * @export
 * @interface AzureBlobStorageIntegration
 */
export interface AzureBlobStorageIntegration {
    /**
     * Credentials for the Azure Blob Service.
     * @type {string}
     * @memberof AzureBlobStorageIntegration
     */
    connection_string: string;
}
/**
 *
 * @export
 * @interface AzureEventHubsIntegration
 */
export interface AzureEventHubsIntegration {
    /**
     * Credentials for the Azure Event Hubs.
     * @type {string}
     * @memberof AzureEventHubsIntegration
     */
    connection_string?: string;
}
/**
 *
 * @export
 * @interface AzureServiceBusIntegration
 */
export interface AzureServiceBusIntegration {
    /**
     * Credentials for the Azure Service Bus.
     * @type {string}
     * @memberof AzureServiceBusIntegration
     */
    connection_string: string;
}
/**
 *
 * @export
 * @interface BulkStats
 */
export interface BulkStats {
    /**
     * ISO-8601 date of when the bulk ingest was started.
     * @type {string}
     * @memberof BulkStats
     */
    started_at?: string;
    /**
     * ISO-8601 date of when the initializing stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    initializing_stage_done_at?: string;
    /**
     * ISO-8601 date of when the downloading stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    downloading_stage_done_at?: string;
    /**
     * ISO-8601 date of when the provisioning stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    provisioning_stage_done_at?: string;
    /**
     * ISO-8601 date of when the indexing stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    indexing_stage_done_at?: string;
    /**
     * ISO-8601 date of when the finalizing stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    finalizing_stage_done_at?: string;
    /**
     * Number of documents downloaded from source during an ongoing or completed bulk ingest. This includes documents that are dropped and reingested.
     * @type {number}
     * @memberof BulkStats
     */
    documents_downloaded?: number;
    /**
     * Size in bytes of documents downloaded from source during an ongoing or completed bulk ingest. This includes documents that are dropped and reingested.
     * @type {number}
     * @memberof BulkStats
     */
    data_downloaded_bytes?: number;
    /**
     * Bulk ingest compute units in milliseconds used for downloading documents.
     * @type {number}
     * @memberof BulkStats
     */
    download_compute_ms?: number;
    /**
     * Size in bytes of documents indexed. This is the total size of documents after transformations and dropping before indexes are built.
     * @type {number}
     * @memberof BulkStats
     */
    data_indexed_bytes?: number;
    /**
     * Bulk ingest compute units in milliseconds used for indexing documents.
     * @type {number}
     * @memberof BulkStats
     */
    index_compute_ms?: number;
    /**
     * Total size of indexes after the completed bulk ingest. This is the same as collection size.
     * @type {number}
     * @memberof BulkStats
     */
    total_index_size_bytes?: number;
    /**
     * Throughput of documents indexed in the last minute measured in bytes/s. This is based off the data_indexed_bytes size. Throughput during the download stage is shown on a per-source granularity in the sources field of the Collection response.
     * @type {number}
     * @memberof BulkStats
     */
    data_indexed_throughput_bytes?: number;
}
/**
 *
 * @export
 * @interface CancelQueryResponse
 */
export interface CancelQueryResponse {
    /**
     *
     * @type {QueryInfo}
     * @memberof CancelQueryResponse
     */
    data?: QueryInfo;
}
/**
 *
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * Unique identifier for the cluster.
     * @type {string}
     * @memberof Cluster
     */
    id?: string;
    /**
     * Cluster type.
     * @type {string}
     * @memberof Cluster
     */
    cluster_type?: Cluster.ClusterTypeEnum;
    /**
     * Aws region.
     * @type {string}
     * @memberof Cluster
     */
    aws_region?: string;
    /**
     * Domain of org using cluster.
     * @type {string}
     * @memberof Cluster
     */
    domain?: string;
    /**
     * Top level domain of org using cluster.
     * @type {string}
     * @memberof Cluster
     */
    top_level_domain?: string;
    /**
     * Api server url for cluster.
     * @type {string}
     * @memberof Cluster
     */
    apiserver_url?: string;
}
/**
 * @export
 * @namespace Cluster
 */
export declare namespace Cluster {
    /**
     * @export
     * @enum {string}
     */
    enum ClusterTypeEnum {
        PUBLIC
    }
}
/**
 *
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Collection
     */
    created_at?: string;
    /**
     * Email of user who created the collection.
     * @type {string}
     * @memberof Collection
     */
    created_by?: string;
    /**
     * Unique identifer for collection, can contain alphanumeric or dash characters.
     * @type {string}
     * @memberof Collection
     */
    name?: string;
    /**
     * Text describing the collection.
     * @type {string}
     * @memberof Collection
     */
    description?: string;
    /**
     * Name of the workspace that the collection is in.
     * @type {string}
     * @memberof Collection
     */
    workspace?: string;
    /**
     * Current status of collection.
     * @type {string}
     * @memberof Collection
     */
    status?: Collection.StatusEnum;
    /**
     * List of sources from which collection ingests.
     * @type {Array<Source>}
     * @memberof Collection
     */
    sources?: Array<Source>;
    /**
     * Metrics about the collection.
     * @type {CollectionStats}
     * @memberof Collection
     */
    stats?: CollectionStats;
    /**
     * Number of seconds after which data is purged based on event time.
     * @type {number}
     * @memberof Collection
     */
    retention_secs?: number;
    /**
     * List of mappings applied on all documents in a collection.
     * @type {Array<FieldMappingV2>}
     * @memberof Collection
     */
    field_mappings?: Array<FieldMappingV2>;
    /**
     * Field mapping for a collection.
     * @type {FieldMappingQuery}
     * @memberof Collection
     */
    field_mapping_query?: FieldMappingQuery;
    /**
     * List of clustering fields for a collection.
     * @type {Array<FieldPartition>}
     * @memberof Collection
     */
    clustering_key?: Array<FieldPartition>;
    /**
     * List of aliases for a collection.
     * @type {Array<Alias>}
     * @memberof Collection
     */
    aliases?: Array<Alias>;
    /**
     * Whether the collection is read-only or not.
     * @type {boolean}
     * @memberof Collection
     */
    read_only?: boolean;
    /**
     * Whether the collection is insert only or not.
     * @type {boolean}
     * @memberof Collection
     */
    insert_only?: boolean;
    /**
     *
     * @type {Array<BulkStats>}
     * @memberof Collection
     */
    bulk_stats?: Array<BulkStats>;
}
/**
 * @export
 * @namespace Collection
 */
export declare namespace Collection {
    /**
     * @export
     * @enum {string}
     */
    enum StatusEnum {
        INITIALIZED,
        CREATED,
        READY,
        PAUSED,
        DELETED,
        PAUSING,
        RESUMING,
        PREPARINGBULK,
        BULKINGESTMODE,
        EXITINGBULKINGESTMODE,
        UNKNOWN
    }
}
/**
 *
 * @export
 * @interface CollectionMount
 */
export interface CollectionMount {
    /**
     * Mount type.
     * @type {string}
     * @memberof CollectionMount
     */
    type?: CollectionMount.TypeEnum;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof CollectionMount
     */
    created_at?: string;
    /**
     * Mount type.
     * @type {string}
     * @memberof CollectionMount
     */
    state?: CollectionMount.StateEnum;
    /**
     * Collection path.
     * @type {string}
     * @memberof CollectionMount
     */
    collection_path?: string;
    /**
     * Virtual instance ID.
     * @type {string}
     * @memberof CollectionMount
     */
    virtual_instance_id?: string;
    /**
     * Virtual Instance RRN.
     * @type {string}
     * @memberof CollectionMount
     */
    virtual_instance_rrn?: string;
    /**
     * Mount ID.
     * @type {string}
     * @memberof CollectionMount
     */
    id?: string;
    /**
     * Mount RRN.
     * @type {string}
     * @memberof CollectionMount
     */
    rrn?: string;
    /**
     * Time in millis at which the snapshot expires.
     * @type {number}
     * @memberof CollectionMount
     */
    snapshot_expiration_time_millis?: number;
    /**
     * Stats about this Collection Mount
     * @type {CollectionMountStats}
     * @memberof CollectionMount
     */
    stats?: CollectionMountStats;
}
/**
 * @export
 * @namespace CollectionMount
 */
export declare namespace CollectionMount {
    /**
     * @export
     * @enum {string}
     */
    enum TypeEnum {
        STATIC,
        LIVE
    }
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        CREATING,
        ACTIVE,
        EXPIRED,
        DELETING
    }
}
/**
 *
 * @export
 * @interface CollectionMountResponse
 */
export interface CollectionMountResponse {
    /**
     * Resource mount object.
     * @type {CollectionMount}
     * @memberof CollectionMountResponse
     */
    data?: CollectionMount;
}
/**
 *
 * @export
 * @interface CollectionMountStats
 */
export interface CollectionMountStats {
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof CollectionMountStats
     */
    last_queried_ms?: number;
}
/**
 *
 * @export
 * @interface CollectionStats
 */
export interface CollectionStats {
    /**
     * Number of documents in the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    doc_count?: number;
    /**
     * Number of documents purged from the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_count?: number;
    /**
     * Number between 0 and 1 that indicates progress of collection creation.
     * @type {number}
     * @memberof CollectionStats
     */
    fill_progress?: number;
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof CollectionStats
     */
    last_queried_ms?: number;
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof CollectionStats
     */
    last_updated_ms?: number;
    /**
     * Total collection size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    total_size?: number;
    /**
     * Total collection index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    total_index_size?: number;
    /**
     * Total collection row index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    row_index_size?: number;
    /**
     * Total collection column index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    column_index_size?: number;
    /**
     * Total collection inverted index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    inverted_index_size?: number;
    /**
     * Total collection range index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    range_index_size?: number;
    /**
     * Total size of bytes purged in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_size?: number;
    /**
     * Total number of bytes inserted into the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_inserted?: number;
    /**
     * Total number of bytes overwritten in writing into the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_overwritten?: number;
    /**
     * Total number of bytes inserted into the collection during bulk.
     * @type {number}
     * @memberof CollectionStats
     */
    bulk_bytes_inserted?: number;
    /**
     * Total number of bytes overwritten in writing into the collection during bulk.
     * @type {number}
     * @memberof CollectionStats
     */
    bulk_bytes_overwritten?: number;
}
/**
 *
 * @export
 * @interface CreateAliasRequest
 */
export interface CreateAliasRequest {
    /**
     * Alias name.
     * @type {string}
     * @memberof CreateAliasRequest
     */
    name: string;
    /**
     * Optional description.
     * @type {string}
     * @memberof CreateAliasRequest
     */
    description?: string;
    /**
     * List of fully qualified collection names referenced by alias.
     * @type {Array<string>}
     * @memberof CreateAliasRequest
     */
    collections: Array<string>;
}
/**
 *
 * @export
 * @interface CreateAliasResponse
 */
export interface CreateAliasResponse {
    /**
     * Alias that was created.
     * @type {Alias}
     * @memberof CreateAliasResponse
     */
    data?: Alias;
}
/**
 *
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * Name for this API key.
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    role?: string;
    /**
     *
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    created_by?: string;
}
/**
 *
 * @export
 * @interface CreateApiKeyResponse
 */
export interface CreateApiKeyResponse {
    /**
     * The API key that was created.
     * @type {ApiKey}
     * @memberof CreateApiKeyResponse
     */
    data?: ApiKey;
}
/**
 *
 * @export
 * @interface CreateCollectionMountRequest
 */
export interface CreateCollectionMountRequest {
    /**
     * Mount type.
     * @type {string}
     * @memberof CreateCollectionMountRequest
     */
    type?: CreateCollectionMountRequest.TypeEnum;
    /**
     * Collections to mount.
     * @type {Array<string>}
     * @memberof CreateCollectionMountRequest
     */
    collection_paths?: Array<string>;
}
/**
 * @export
 * @namespace CreateCollectionMountRequest
 */
export declare namespace CreateCollectionMountRequest {
    /**
     * @export
     * @enum {string}
     */
    enum TypeEnum {
        STATIC,
        LIVE
    }
}
/**
 *
 * @export
 * @interface CreateCollectionMountsResponse
 */
export interface CreateCollectionMountsResponse {
    /**
     * Mounts created.
     * @type {Array<CollectionMount>}
     * @memberof CreateCollectionMountsResponse
     */
    data?: Array<CollectionMount>;
}
/**
 *
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * Unique identifier for collection, can contain alphanumeric or dash characters.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    name?: string;
    /**
     * Text describing the collection.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    description?: string;
    /**
     * List of sources from which to ingest data.
     * @type {Array<Source>}
     * @memberof CreateCollectionRequest
     */
    sources?: Array<Source>;
    /**
     * Number of seconds after which data is purged, based on event time.
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    retention_secs?: number;
    /**
     * Deprecated. Configuration for event data. Use an _event_time mapping in `field_mapping_query` instead.
     * @type {EventTimeInfo}
     * @memberof CreateCollectionRequest
     */
    event_time_info?: EventTimeInfo;
    /**
     * Deprecated. List of mappings. Use field_mapping_query instead.
     * @type {Array<FieldMappingV2>}
     * @memberof CreateCollectionRequest
     */
    field_mappings?: Array<FieldMappingV2>;
    /**
     * Mapping of fields for a collection.
     * @type {FieldMappingQuery}
     * @memberof CreateCollectionRequest
     */
    field_mapping_query?: FieldMappingQuery;
    /**
     * Deprecated. List of clustering fields. Use CLUSTER BY clause in `field_mapping_query` instead.
     * @type {Array<FieldPartition>}
     * @memberof CreateCollectionRequest
     */
    clustering_key?: Array<FieldPartition>;
}
/**
 *
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * Collection that was created.
     * @type {Collection}
     * @memberof CreateCollectionResponse
     */
    data?: Collection;
}
/**
 *
 * @export
 * @interface CreateIntegrationRequest
 */
export interface CreateIntegrationRequest {
    /**
     * Descriptive label.
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    name: string;
    /**
     * Longer explanation for the integration.
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    description?: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role.
     * @type {S3Integration}
     * @memberof CreateIntegrationRequest
     */
    s3?: S3Integration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role.
     * @type {KinesisIntegration}
     * @memberof CreateIntegrationRequest
     */
    kinesis?: KinesisIntegration;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role.
     * @type {DynamodbIntegration}
     * @memberof CreateIntegrationRequest
     */
    dynamodb?: DynamodbIntegration;
    /**
     * GCS details.
     * @type {GcsIntegration}
     * @memberof CreateIntegrationRequest
     */
    gcs?: GcsIntegration;
    /**
     * Azure Blob Storage details.
     * @type {AzureBlobStorageIntegration}
     * @memberof CreateIntegrationRequest
     */
    azure_blob_storage?: AzureBlobStorageIntegration;
    /**
     * Azure Service Bus details.
     * @type {AzureServiceBusIntegration}
     * @memberof CreateIntegrationRequest
     */
    azure_service_bus?: AzureServiceBusIntegration;
    /**
     * Azure Event Hubs details.
     * @type {AzureEventHubsIntegration}
     * @memberof CreateIntegrationRequest
     */
    azure_event_hubs?: AzureEventHubsIntegration;
    /**
     *
     * @type {KafkaIntegration}
     * @memberof CreateIntegrationRequest
     */
    kafka?: KafkaIntegration;
    /**
     * MongoDb details.
     * @type {MongoDbIntegration}
     * @memberof CreateIntegrationRequest
     */
    mongodb?: MongoDbIntegration;
    /**
     *
     * @type {SnowflakeIntegration}
     * @memberof CreateIntegrationRequest
     */
    snowflake?: SnowflakeIntegration;
}
/**
 *
 * @export
 * @interface CreateIntegrationResponse
 */
export interface CreateIntegrationResponse {
    /**
     * Integration object that was created.
     * @type {Integration}
     * @memberof CreateIntegrationResponse
     */
    data?: Integration;
}
/**
 *
 * @export
 * @interface CreateQueryLambdaRequest
 */
export interface CreateQueryLambdaRequest {
    /**
     * Query Lambda name.
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    name: string;
    /**
     * Optional description.
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    description?: string;
    /**
     * Query Lambda SQL query.
     * @type {QueryLambdaSql}
     * @memberof CreateQueryLambdaRequest
     */
    sql: QueryLambdaSql;
    /**
     *
     * @type {boolean}
     * @memberof CreateQueryLambdaRequest
     */
    is_public?: boolean;
}
/**
 *
 * @export
 * @interface CreateQueryLambdaTagRequest
 */
export interface CreateQueryLambdaTagRequest {
    /**
     * Name of Query Lambda tag.
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    tag_name: string;
    /**
     * Hash identifying a Query Lambda tag.
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    version: string;
}
/**
 *
 * @export
 * @interface CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    role_name?: string;
    /**
     * Description for the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    description?: string;
    /**
     * List of privileges that will be associated with the role.
     * @type {Array<Privilege>}
     * @memberof CreateRoleRequest
     */
    privileges?: Array<Privilege>;
}
/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * User email, must be unique.
     * @type {string}
     * @memberof CreateUserRequest
     */
    email: string;
    /**
     * List of roles for a given user.
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    roles: Array<string>;
    /**
     * User first name.
     * @type {string}
     * @memberof CreateUserRequest
     */
    first_name?: string;
    /**
     * User last name.
     * @type {string}
     * @memberof CreateUserRequest
     */
    last_name?: string;
}
/**
 *
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * User that was created.
     * @type {User}
     * @memberof CreateUserResponse
     */
    data?: User;
}
/**
 *
 * @export
 * @interface CreateViewRequest
 */
export interface CreateViewRequest {
    /**
     * View name.
     * @type {string}
     * @memberof CreateViewRequest
     */
    name: string;
    /**
     * Optional description.
     * @type {string}
     * @memberof CreateViewRequest
     */
    description?: string;
    /**
     * SQL for this view.
     * @type {string}
     * @memberof CreateViewRequest
     */
    query: string;
}
/**
 *
 * @export
 * @interface CreateViewResponse
 */
export interface CreateViewResponse {
    /**
     * View that was updated.
     * @type {View}
     * @memberof CreateViewResponse
     */
    data?: View;
}
/**
 *
 * @export
 * @interface CreateVirtualInstanceRequest
 */
export interface CreateVirtualInstanceRequest {
    /**
     * Requested virtual instance type.
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    type?: CreateVirtualInstanceRequest.TypeEnum;
    /**
     * Unique identifier for virtual instance, can contain alphanumeric or dash characters.
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    name: string;
    /**
     * Description of requested virtual instance.
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    description?: string;
    /**
     * Number of seconds without queries after which the VI is suspended
     * @type {number}
     * @memberof CreateVirtualInstanceRequest
     */
    auto_suspend_seconds?: number;
}
/**
 * @export
 * @namespace CreateVirtualInstanceRequest
 */
export declare namespace CreateVirtualInstanceRequest {
    /**
     * @export
     * @enum {string}
     */
    enum TypeEnum {
        FREE,
        NANO,
        SHARED,
        MILLI,
        SMALL,
        MEDIUM,
        LARGE,
        XLARGE,
        XLARGE2,
        XLARGE4,
        XLARGE8,
        XLARGE16
    }
}
/**
 *
 * @export
 * @interface CreateVirtualInstanceResponse
 */
export interface CreateVirtualInstanceResponse {
    /**
     * Virtual instance object.
     * @type {VirtualInstance}
     * @memberof CreateVirtualInstanceResponse
     */
    data?: VirtualInstance;
}
/**
 *
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
    /**
     * Descriptive label and unique identifier.
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    name: string;
    /**
     * Longer explanation for the workspace.
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    description?: string;
}
/**
 *
 * @export
 * @interface CreateWorkspaceResponse
 */
export interface CreateWorkspaceResponse {
    /**
     * The workspace that was created.
     * @type {Workspace}
     * @memberof CreateWorkspaceResponse
     */
    data?: Workspace;
}
/**
 *
 * @export
 * @interface CsvParams
 */
export interface CsvParams {
    /**
     * If the first line in every object specifies the column names.
     * @type {boolean}
     * @memberof CsvParams
     */
    firstLineAsColumnNames?: boolean;
    /**
     * A single character that is the column separator.
     * @type {string}
     * @memberof CsvParams
     */
    separator?: string;
    /**
     * One of: UTF-8, ISO_8859_1, UTF-16.
     * @type {string}
     * @memberof CsvParams
     */
    encoding?: string;
    /**
     * Names of columns.
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnNames?: Array<string>;
    /**
     * Names of columns.
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnTypes?: Array<CsvParams.ColumnTypesEnum>;
    /**
     * character within which a cell value is enclosed,null character if no such character, default is '\"'
     * @type {string}
     * @memberof CsvParams
     */
    quoteChar?: string;
    /**
     * escape character removes any special meaning from the following character,default is '\\'
     * @type {string}
     * @memberof CsvParams
     */
    escapeChar?: string;
}
/**
 * @export
 * @namespace CsvParams
 */
export declare namespace CsvParams {
    /**
     * @export
     * @enum {string}
     */
    enum ColumnTypesEnum {
        UNKNOWN,
        BOOLEAN,
        BOOL,
        INTEGER,
        INT,
        FLOAT,
        TIME,
        DATE,
        DATETIME,
        TIMESTAMP,
        STRING
    }
}
/**
 *
 * @export
 * @interface DeleteAliasResponse
 */
export interface DeleteAliasResponse {
    /**
     * Alias that was deleted.
     * @type {Alias}
     * @memberof DeleteAliasResponse
     */
    data?: Alias;
}
/**
 *
 * @export
 * @interface DeleteApiKeyResponse
 */
export interface DeleteApiKeyResponse {
    /**
     * The API key that was deleted.
     * @type {ApiKey}
     * @memberof DeleteApiKeyResponse
     */
    data?: ApiKey;
}
/**
 *
 * @export
 * @interface DeleteCollectionResponse
 */
export interface DeleteCollectionResponse {
    /**
     * Collection that was deleted.
     * @type {Collection}
     * @memberof DeleteCollectionResponse
     */
    data?: Collection;
}
/**
 *
 * @export
 * @interface DeleteDocumentsRequest
 */
export interface DeleteDocumentsRequest {
    /**
     * Array of IDs of documents to be deleted.
     * @type {Array<DeleteDocumentsRequestData>}
     * @memberof DeleteDocumentsRequest
     */
    data: Array<DeleteDocumentsRequestData>;
}
/**
 *
 * @export
 * @interface DeleteDocumentsRequestData
 */
export interface DeleteDocumentsRequestData {
    /**
     * Unique document ID.
     * @type {string}
     * @memberof DeleteDocumentsRequestData
     */
    _id: string;
}
/**
 *
 * @export
 * @interface DeleteDocumentsResponse
 */
export interface DeleteDocumentsResponse {
    /**
     * Information about deleted documents.
     * @type {Array<DocumentStatus>}
     * @memberof DeleteDocumentsResponse
     */
    data?: Array<DocumentStatus>;
}
/**
 *
 * @export
 * @interface DeleteIntegrationResponse
 */
export interface DeleteIntegrationResponse {
    /**
     * Integration object that was deleted.
     * @type {Integration}
     * @memberof DeleteIntegrationResponse
     */
    data?: Integration;
}
/**
 *
 * @export
 * @interface DeleteQueryLambdaResponse
 */
export interface DeleteQueryLambdaResponse {
    /**
     * Query Lambda details.
     * @type {QueryLambda}
     * @memberof DeleteQueryLambdaResponse
     */
    data?: QueryLambda;
}
/**
 *
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    /**
     * User object that was deleted.
     * @type {User}
     * @memberof DeleteUserResponse
     */
    data?: User;
}
/**
 *
 * @export
 * @interface DeleteViewResponse
 */
export interface DeleteViewResponse {
    /**
     * View that was deleted.
     * @type {View}
     * @memberof DeleteViewResponse
     */
    data?: View;
}
/**
 *
 * @export
 * @interface DeleteVirtualInstanceResponse
 */
export interface DeleteVirtualInstanceResponse {
    /**
     * Virtual instance that was deleted.
     * @type {VirtualInstance}
     * @memberof DeleteVirtualInstanceResponse
     */
    data?: VirtualInstance;
}
/**
 *
 * @export
 * @interface DeleteWorkspaceResponse
 */
export interface DeleteWorkspaceResponse {
    /**
     * The workspace that was deleted.
     * @type {Workspace}
     * @memberof DeleteWorkspaceResponse
     */
    data?: Workspace;
}
/**
 *
 * @export
 * @interface DocumentStatus
 */
export interface DocumentStatus {
    /**
     * Collection name.
     * @type {string}
     * @memberof DocumentStatus
     */
    _collection?: string;
    /**
     * Error message, if any.
     * @type {ErrorModel}
     * @memberof DocumentStatus
     */
    error?: ErrorModel;
    /**
     * Unique document ID.
     * @type {string}
     * @memberof DocumentStatus
     */
    _id?: string;
    /**
     * Status of the document.
     * @type {string}
     * @memberof DocumentStatus
     */
    status?: DocumentStatus.StatusEnum;
    /**
     * Unique id used to represent each patch request.
     * @type {string}
     * @memberof DocumentStatus
     */
    patch_id?: string;
}
/**
 * @export
 * @namespace DocumentStatus
 */
export declare namespace DocumentStatus {
    /**
     * @export
     * @enum {string}
     */
    enum StatusEnum {
        ADDED,
        REPLACED,
        DELETED,
        PATCHED,
        ERROR
    }
}
/**
 *
 * @export
 * @interface DynamodbIntegration
 */
export interface DynamodbIntegration {
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof DynamodbIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Role used for external id type authentication.
     * @type {AwsRole}
     * @memberof DynamodbIntegration
     */
    aws_role?: AwsRole;
    /**
     * S3 bucket used for export during collection initial dump.
     * @type {string}
     * @memberof DynamodbIntegration
     */
    s3_export_bucket_name?: string;
}
/**
 * Describes details about an error
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * Descriptive message about the error.
     * @type {string}
     * @memberof ErrorModel
     */
    message?: string;
    /**
     * Category of the error.
     * @type {string}
     * @memberof ErrorModel
     */
    type?: ErrorModel.TypeEnum;
    /**
     * Line where the error happened (if applicable).
     * @type {number}
     * @memberof ErrorModel
     */
    line?: number;
    /**
     * Column where the error happened (if applicable).
     * @type {number}
     * @memberof ErrorModel
     */
    column?: number;
    /**
     * Internal trace ID to help with debugging.
     * @type {string}
     * @memberof ErrorModel
     */
    trace_id?: string;
    /**
     * ID of the error.
     * @type {string}
     * @memberof ErrorModel
     */
    error_id?: string;
    /**
     * ID of the query (if applicable).
     * @type {string}
     * @memberof ErrorModel
     */
    query_id?: string;
}
/**
 * @export
 * @namespace ErrorModel
 */
export declare namespace ErrorModel {
    /**
     * @export
     * @enum {string}
     */
    enum TypeEnum {
        AUTHEXCEPTION,
        VERSIONEXCEPTION,
        INTERNALERROR,
        INVALIDINPUT,
        NOTIMPLEMENTEDYET,
        RESOURCEEXCEEDED,
        ALREADYEXISTS,
        NOTALLOWED,
        NOTACCEPTABLE,
        NOTSUPPORTED,
        NOTFOUND,
        DEPENDENTRESOURCES,
        QUERYERROR,
        NOTREADY,
        FORBIDDEN,
        QUERYTIMEOUT,
        CONNECTIONERROR,
        CONTENTTOOLARGE,
        CREATING,
        BADREQUEST,
        SERVICEUNAVAILABLE,
        CONFLICT,
        RATELIMITEXCEEDED,
        QUERYCANCELLED,
        CLIENTCONNECTIONERROR
    }
}
/**
 *
 * @export
 * @interface EventTimeInfo
 */
export interface EventTimeInfo {
    /**
     * Name of the field containing event time.
     * @type {string}
     * @memberof EventTimeInfo
     */
    field: string;
    /**
     * Format of time field, can be one of: milliseconds_since_epoch, seconds_since_epoch.
     * @type {string}
     * @memberof EventTimeInfo
     */
    format?: string;
    /**
     * Default time zone, in standard IANA format.
     * @type {string}
     * @memberof EventTimeInfo
     */
    time_zone?: string;
}
/**
 *
 * @export
 * @interface ExecutePublicQueryLambdaRequest
 */
export interface ExecutePublicQueryLambdaRequest {
    /**
     * List of named parameters.
     * @type {Array<QueryParameter>}
     * @memberof ExecutePublicQueryLambdaRequest
     */
    parameters?: Array<QueryParameter>;
    /**
     * Row limit to use if no limit specified in the SQL query text.
     * @type {number}
     * @memberof ExecutePublicQueryLambdaRequest
     */
    default_row_limit?: number;
    /**
     * Whether to generate warnings.
     * @type {boolean}
     * @memberof ExecutePublicQueryLambdaRequest
     */
    generate_warnings?: boolean;
}
/**
 *
 * @export
 * @interface ExecuteQueryLambdaRequest
 */
export interface ExecuteQueryLambdaRequest {
    /**
     * List of named parameters.
     * @type {Array<QueryParameter>}
     * @memberof ExecuteQueryLambdaRequest
     */
    parameters?: Array<QueryParameter>;
    /**
     * Row limit to use if no limit specified in the SQL query text.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    default_row_limit?: number;
    /**
     * Whether to generate warnings.
     * @type {boolean}
     * @memberof ExecuteQueryLambdaRequest
     */
    generate_warnings?: boolean;
    /**
     * Flag to paginate and store the results of this query for later / sequential retrieval.
     * @type {boolean}
     * @memberof ExecuteQueryLambdaRequest
     */
    paginate?: boolean;
    /**
     * Number of documents to return in addition to paginating for this query call. Only relevant if `paginate` flag is also set.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    initial_paginate_response_doc_count?: number;
    /**
     * Options for configuring Asynchronous Query Mode (beta).
     * @type {AsyncQueryOptions}
     * @memberof ExecuteQueryLambdaRequest
     */
    async_options?: AsyncQueryOptions;
    /**
     * Virtual instance on which to run the query.
     * @type {string}
     * @memberof ExecuteQueryLambdaRequest
     */
    virtual_instance_id?: string;
}
/**
 *
 * @export
 * @interface FieldMapping
 */
export interface FieldMapping {
}
/**
 *
 * @export
 * @interface FieldMappingQuery
 */
export interface FieldMappingQuery {
    /**
     * SELECT * EXCEPT (name), SHA256(name) AS name_anon FROM _input.
     * @type {string}
     * @memberof FieldMappingQuery
     */
    sql?: string;
}
/**
 *
 * @export
 * @interface FieldMappingV2
 */
export interface FieldMappingV2 {
    /**
     * A user specified string that is a name for this mapping.
     * @type {string}
     * @memberof FieldMappingV2
     */
    name?: string;
    /**
     * A boolean that determines whether to drop all fields in this document. If set, input and output fields should not be set
     * @type {boolean}
     * @memberof FieldMappingV2
     */
    is_drop_all_fields?: boolean;
    /**
     * A List of InputField for this mapping.
     * @type {Array<InputField>}
     * @memberof FieldMappingV2
     */
    input_fields?: Array<InputField>;
    /**
     * An OutputField for this mapping.
     * @type {OutputField}
     * @memberof FieldMappingV2
     */
    output_field?: OutputField;
}
/**
 *
 * @export
 * @interface FieldPartition
 */
export interface FieldPartition {
    /**
     * The name of a field, parsed as a SQL qualified name.
     * @type {string}
     * @memberof FieldPartition
     */
    field_name?: string;
    /**
     * The type of partitions on a field.
     * @type {string}
     * @memberof FieldPartition
     */
    type?: FieldPartition.TypeEnum;
    /**
     * The values for partitioning of a field. Unneeded if the partition type is AUTO.
     * @type {Array<string>}
     * @memberof FieldPartition
     */
    keys?: Array<string>;
}
/**
 * @export
 * @namespace FieldPartition
 */
export declare namespace FieldPartition {
    /**
     * @export
     * @enum {string}
     */
    enum TypeEnum {
        AUTO
    }
}
/**
 *
 * @export
 * @interface FormatParams
 */
export interface FormatParams {
    /**
     * Source data is in json format.
     * @type {boolean}
     * @memberof FormatParams
     */
    json?: boolean;
    /**
     *
     * @type {CsvParams}
     * @memberof FormatParams
     */
    csv?: CsvParams;
    /**
     *
     * @type {XmlParams}
     * @memberof FormatParams
     */
    xml?: XmlParams;
    /**
     *
     * @type {boolean}
     * @memberof FormatParams
     */
    mysql_dms?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof FormatParams
     */
    postgres_dms?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof FormatParams
     */
    mssql_dms?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof FormatParams
     */
    oracle_dms?: boolean;
    /**
     *
     * @type {AvroParams}
     * @memberof FormatParams
     */
    avro?: AvroParams;
}
/**
 *
 * @export
 * @interface GcpServiceAccount
 */
export interface GcpServiceAccount {
    /**
     * Contents of JSON Service Account key file.
     * @type {string}
     * @memberof GcpServiceAccount
     */
    service_account_key_file_json: string;
}
/**
 *
 * @export
 * @interface GcsIntegration
 */
export interface GcsIntegration {
    /**
     * Credentials for an GCP key integration.
     * @type {GcpServiceAccount}
     * @memberof GcsIntegration
     */
    gcp_service_account?: GcpServiceAccount;
}
/**
 *
 * @export
 * @interface GetAliasResponse
 */
export interface GetAliasResponse {
    /**
     * Alias that was requested.
     * @type {Alias}
     * @memberof GetAliasResponse
     */
    data?: Alias;
}
/**
 *
 * @export
 * @interface GetApiKeyResponse
 */
export interface GetApiKeyResponse {
    /**
     * The requested API key object.
     * @type {ApiKey}
     * @memberof GetApiKeyResponse
     */
    data?: ApiKey;
}
/**
 *
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
    /**
     * Collection that was requested.
     * @type {Collection}
     * @memberof GetCollectionResponse
     */
    data?: Collection;
}
/**
 *
 * @export
 * @interface GetIntegrationResponse
 */
export interface GetIntegrationResponse {
    /**
     * Integration object.
     * @type {Integration}
     * @memberof GetIntegrationResponse
     */
    data?: Integration;
}
/**
 *
 * @export
 * @interface GetQueryResponse
 */
export interface GetQueryResponse {
    /**
     *
     * @type {QueryInfo}
     * @memberof GetQueryResponse
     */
    data?: QueryInfo;
}
/**
 *
 * @export
 * @interface GetViewResponse
 */
export interface GetViewResponse {
    /**
     * View that was requested.
     * @type {View}
     * @memberof GetViewResponse
     */
    data?: View;
}
/**
 *
 * @export
 * @interface GetVirtualInstanceResponse
 */
export interface GetVirtualInstanceResponse {
    /**
     * Virtual instance that was requested.
     * @type {VirtualInstance}
     * @memberof GetVirtualInstanceResponse
     */
    data?: VirtualInstance;
}
/**
 *
 * @export
 * @interface GetWorkspaceResponse
 */
export interface GetWorkspaceResponse {
    /**
     * The workspace that was requested.
     * @type {Workspace}
     * @memberof GetWorkspaceResponse
     */
    data?: Workspace;
}
/**
 *
 * @export
 * @interface InputField
 */
export interface InputField {
    /**
     * The name of a field, parsed as a SQL qualified name.
     * @type {string}
     * @memberof InputField
     */
    field_name?: string;
    /**
     * Define the behaviour if fieldName is missing or is null.
     * @type {string}
     * @memberof InputField
     */
    if_missing?: InputField.IfMissingEnum;
    /**
     * If true, then drop fieldName from the document.
     * @type {boolean}
     * @memberof InputField
     */
    is_drop?: boolean;
    /**
     * Sql parameter name.
     * @type {string}
     * @memberof InputField
     */
    param?: string;
}
/**
 * @export
 * @namespace InputField
 */
export declare namespace InputField {
    /**
     * @export
     * @enum {string}
     */
    enum IfMissingEnum {
        SKIP,
        PASS
    }
}
/**
 * Integrations that can be associated with data sources to create collections. Only one type of integration may be specified.
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * Descriptive label and unique identifier.
     * @type {string}
     * @memberof Integration
     */
    name: string;
    /**
     * Longer explanation for the integration.
     * @type {string}
     * @memberof Integration
     */
    description?: string;
    /**
     * Email of user who created the integration.
     * @type {string}
     * @memberof Integration
     */
    created_by: string;
    /**
     * User that owns this integration.
     * @type {string}
     * @memberof Integration
     */
    owner_email?: string;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Integration
     */
    created_at?: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role.
     * @type {S3Integration}
     * @memberof Integration
     */
    s3?: S3Integration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role.
     * @type {KinesisIntegration}
     * @memberof Integration
     */
    kinesis?: KinesisIntegration;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role.
     * @type {DynamodbIntegration}
     * @memberof Integration
     */
    dynamodb?: DynamodbIntegration;
    /**
     * GCS details.
     * @type {GcsIntegration}
     * @memberof Integration
     */
    gcs?: GcsIntegration;
    /**
     * Azure Blob Storage details.
     * @type {AzureBlobStorageIntegration}
     * @memberof Integration
     */
    azure_blob_storage?: AzureBlobStorageIntegration;
    /**
     * Azure Service Bus details.
     * @type {AzureServiceBusIntegration}
     * @memberof Integration
     */
    azure_service_bus?: AzureServiceBusIntegration;
    /**
     * Azure Event Hubs details.
     * @type {AzureEventHubsIntegration}
     * @memberof Integration
     */
    azure_event_hubs?: AzureEventHubsIntegration;
    /**
     * Kafka details.
     * @type {KafkaIntegration}
     * @memberof Integration
     */
    kafka?: KafkaIntegration;
    /**
     * MongoDb details.
     * @type {MongoDbIntegration}
     * @memberof Integration
     */
    mongodb?: MongoDbIntegration;
    /**
     * Snowflake details.
     * @type {SnowflakeIntegration}
     * @memberof Integration
     */
    snowflake?: SnowflakeIntegration;
    /**
     * List of collections that use the integration.
     * @type {Array<Collection>}
     * @memberof Integration
     */
    collections?: Array<Collection>;
}
/**
 *
 * @export
 * @interface KafkaIntegration
 */
export interface KafkaIntegration {
    /**
     * Kafka topics to tail.
     * @type {Array<string>}
     * @memberof KafkaIntegration
     */
    kafka_topic_names?: Array<string>;
    /**
     * The status of the Kafka source by topic.
     * @type {{ [key: string]: StatusKafka; }}
     * @memberof KafkaIntegration
     */
    source_status_by_topic?: {
        [key: string]: StatusKafka;
    };
    /**
     * The format of the Kafka topics being tailed.
     * @type {string}
     * @memberof KafkaIntegration
     */
    kafka_data_format?: KafkaIntegration.KafkaDataFormatEnum;
    /**
     * Kafka connection string.
     * @type {string}
     * @memberof KafkaIntegration
     */
    connection_string?: string;
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof KafkaIntegration
     */
    aws_role?: AwsRole;
    /**
     *
     * @type {boolean}
     * @memberof KafkaIntegration
     */
    use_v3?: boolean;
    /**
     * The Kafka bootstrap server url(s). Required only for V3 integration.
     * @type {string}
     * @memberof KafkaIntegration
     */
    bootstrap_servers?: string;
    /**
     * Kafka security configurations.
     * @type {KafkaV3SecurityConfig}
     * @memberof KafkaIntegration
     */
    security_config?: KafkaV3SecurityConfig;
    /**
     * Kafka configurations for schema registry.
     * @type {SchemaRegistryConfig}
     * @memberof KafkaIntegration
     */
    schema_registry_config?: SchemaRegistryConfig;
}
/**
 * @export
 * @namespace KafkaIntegration
 */
export declare namespace KafkaIntegration {
    /**
     * @export
     * @enum {string}
     */
    enum KafkaDataFormatEnum {
        JSON,
        AVRO
    }
}
/**
 *
 * @export
 * @interface KafkaV3SecurityConfig
 */
export interface KafkaV3SecurityConfig {
    /**
     *
     * @type {string}
     * @memberof KafkaV3SecurityConfig
     */
    api_key?: string;
    /**
     *
     * @type {string}
     * @memberof KafkaV3SecurityConfig
     */
    secret?: string;
}
/**
 *
 * @export
 * @interface KinesisIntegration
 */
export interface KinesisIntegration {
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof KinesisIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof KinesisIntegration
     */
    aws_role?: AwsRole;
}
/**
 *
 * @export
 * @interface ListAliasesResponse
 */
export interface ListAliasesResponse {
    /**
     * List of all aliases.
     * @type {Array<Alias>}
     * @memberof ListAliasesResponse
     */
    data?: Array<Alias>;
}
/**
 *
 * @export
 * @interface ListApiKeysResponse
 */
export interface ListApiKeysResponse {
    /**
     * List of API key objects.
     * @type {Array<ApiKey>}
     * @memberof ListApiKeysResponse
     */
    data?: Array<ApiKey>;
}
/**
 *
 * @export
 * @interface ListCollectionMountsResponse
 */
export interface ListCollectionMountsResponse {
    /**
     * List of all collection mounts.
     * @type {Array<CollectionMount>}
     * @memberof ListCollectionMountsResponse
     */
    data?: Array<CollectionMount>;
}
/**
 *
 * @export
 * @interface ListCollectionsResponse
 */
export interface ListCollectionsResponse {
    /**
     * List of all collections.
     * @type {Array<Collection>}
     * @memberof ListCollectionsResponse
     */
    data?: Array<Collection>;
}
/**
 *
 * @export
 * @interface ListIntegrationsResponse
 */
export interface ListIntegrationsResponse {
    /**
     * List of integration objects.
     * @type {Array<Integration>}
     * @memberof ListIntegrationsResponse
     */
    data?: Array<Integration>;
}
/**
 *
 * @export
 * @interface ListQueriesResponse
 */
export interface ListQueriesResponse {
    /**
     *
     * @type {Array<QueryInfo>}
     * @memberof ListQueriesResponse
     */
    data?: Array<QueryInfo>;
}
/**
 *
 * @export
 * @interface ListQueryLambdaTagsResponse
 */
export interface ListQueryLambdaTagsResponse {
    /**
     * List of all tags associated with a Query Lambda.
     * @type {Array<QueryLambdaTag>}
     * @memberof ListQueryLambdaTagsResponse
     */
    data?: Array<QueryLambdaTag>;
}
/**
 *
 * @export
 * @interface ListQueryLambdaVersionsResponse
 */
export interface ListQueryLambdaVersionsResponse {
    /**
     * List of all versions for a particular Query Lambda.
     * @type {Array<QueryLambdaVersion>}
     * @memberof ListQueryLambdaVersionsResponse
     */
    data?: Array<QueryLambdaVersion>;
}
/**
 *
 * @export
 * @interface ListQueryLambdasResponse
 */
export interface ListQueryLambdasResponse {
    /**
     * List of all Query Lambdas.
     * @type {Array<QueryLambda>}
     * @memberof ListQueryLambdasResponse
     */
    data?: Array<QueryLambda>;
}
/**
 *
 * @export
 * @interface ListRolesResponse
 */
export interface ListRolesResponse {
    /**
     * List of all roles.
     * @type {Array<Role>}
     * @memberof ListRolesResponse
     */
    data?: Array<Role>;
}
/**
 *
 * @export
 * @interface ListUnsubscribePreferencesResponse
 */
export interface ListUnsubscribePreferencesResponse {
    /**
     * List of notification preferences.
     * @type {Array<UnsubscribePreference>}
     * @memberof ListUnsubscribePreferencesResponse
     */
    data?: Array<UnsubscribePreference>;
}
/**
 *
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * List of users.
     * @type {Array<User>}
     * @memberof ListUsersResponse
     */
    data?: Array<User>;
}
/**
 *
 * @export
 * @interface ListViewsResponse
 */
export interface ListViewsResponse {
    /**
     * List of all views.
     * @type {Array<View>}
     * @memberof ListViewsResponse
     */
    data?: Array<View>;
}
/**
 *
 * @export
 * @interface ListVirtualInstancesResponse
 */
export interface ListVirtualInstancesResponse {
    /**
     * List of all virtual instances.
     * @type {Array<VirtualInstance>}
     * @memberof ListVirtualInstancesResponse
     */
    data?: Array<VirtualInstance>;
}
/**
 *
 * @export
 * @interface ListWorkspacesResponse
 */
export interface ListWorkspacesResponse {
    /**
     * List of workspaces.
     * @type {Array<Workspace>}
     * @memberof ListWorkspacesResponse
     */
    data?: Array<Workspace>;
}
/**
 *
 * @export
 * @interface MongoDbIntegration
 */
export interface MongoDbIntegration {
    /**
     * MongoDB connection URI string.
     * @type {string}
     * @memberof MongoDbIntegration
     */
    connection_uri: string;
}
/**
 * An organization in Rockset is a container for users and collections.
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * Unique identifier for the organization.
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Organization
     */
    created_at?: string;
    /**
     * Name of the organization.
     * @type {string}
     * @memberof Organization
     */
    display_name?: string;
    /**
     * Organization's unique external ID within Rockset.
     * @type {string}
     * @memberof Organization
     */
    external_id?: string;
    /**
     * Rockset's global AWS user.
     * @type {string}
     * @memberof Organization
     */
    rockset_user?: string;
    /**
     * List of clusters associated with this org.
     * @type {Array<Cluster>}
     * @memberof Organization
     */
    clusters?: Array<Cluster>;
}
/**
 *
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Organization object.
     * @type {Organization}
     * @memberof OrganizationResponse
     */
    data?: Organization;
}
/**
 *
 * @export
 * @interface OutputField
 */
export interface OutputField {
    /**
     * The name of a field, parsed as a SQL qualified name.
     * @type {string}
     * @memberof OutputField
     */
    field_name?: string;
    /**
     * The name of a sql function.
     * @type {SqlExpression}
     * @memberof OutputField
     */
    value?: SqlExpression;
    /**
     * Error in Mapping execution: 'skip' or 'fail'.
     * @type {string}
     * @memberof OutputField
     */
    on_error?: OutputField.OnErrorEnum;
}
/**
 * @export
 * @namespace OutputField
 */
export declare namespace OutputField {
    /**
     * @export
     * @enum {string}
     */
    enum OnErrorEnum {
        SKIP,
        FAIL
    }
}
/**
 *
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Use this cursor to fetch the first page of results for this query.
     * @type {string}
     * @memberof Pagination
     */
    start_cursor?: string;
}
/**
 *
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
    /**
     * Number of documents returned in this result set.
     * @type {number}
     * @memberof PaginationInfo
     */
    current_page_doc_count?: number;
    /**
     * The doc offset that next_cursor starts at.
     * @type {number}
     * @memberof PaginationInfo
     */
    next_cursor_offset?: number;
    /**
     * Cursor used to retrieve the first set of documents.
     * @type {string}
     * @memberof PaginationInfo
     */
    start_cursor?: string;
    /**
     * Cursor to use to get the list of documents.
     * @type {string}
     * @memberof PaginationInfo
     */
    next_cursor?: string;
    /**
     * Direct link to the next page of results.
     * @type {string}
     * @memberof PaginationInfo
     */
    next_page_link?: string;
}
/**
 *
 * @export
 * @interface PatchDocument
 */
export interface PatchDocument {
    /**
     * Unique ID of the document to be patched.
     * @type {string}
     * @memberof PatchDocument
     */
    _id: string;
    /**
     * List of patch operations.
     * @type {Array<PatchOperation>}
     * @memberof PatchDocument
     */
    patch: Array<PatchOperation>;
}
/**
 *
 * @export
 * @interface PatchDocumentsRequest
 */
export interface PatchDocumentsRequest {
    /**
     * List of patches to be applied.
     * @type {Array<PatchDocument>}
     * @memberof PatchDocumentsRequest
     */
    data: Array<PatchDocument>;
}
/**
 *
 * @export
 * @interface PatchDocumentsResponse
 */
export interface PatchDocumentsResponse {
    /**
     *
     * @type {Array<DocumentStatus>}
     * @memberof PatchDocumentsResponse
     */
    data: Array<DocumentStatus>;
}
/**
 *
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * [JSON Patch operation](https://datatracker.ietf.org/doc/html/rfc6902#page-4) to be performed in this patch. Case insensitive.
     * @type {string}
     * @memberof PatchOperation
     */
    op: PatchOperation.OpEnum;
    /**
     * [JSON Pointer](https://datatracker.ietf.org/doc/html/rfc6901) referencing a location in the target document where the operation is performed
     * @type {string}
     * @memberof PatchOperation
     */
    path: string;
    /**
     * Value used in the patch operation. Required for `ADD`, `REPLACE`, `TEST`, and `INCREMENT` operations.
     * @type {any}
     * @memberof PatchOperation
     */
    value?: any;
    /**
     * [JSON Pointer](https://datatracker.ietf.org/doc/html/rfc6901) referencing a location in the target document. Required for `COPY` and `MOVE` operations.
     * @type {string}
     * @memberof PatchOperation
     */
    from?: string;
}
/**
 * @export
 * @namespace PatchOperation
 */
export declare namespace PatchOperation {
    /**
     * @export
     * @enum {string}
     */
    enum OpEnum {
        ADD,
        REPLACE,
        REMOVE,
        COPY,
        MOVE,
        TEST,
        INCREMENT
    }
}
/**
 *
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * The action allowed by this privilege.
     * @type {string}
     * @memberof Privilege
     */
    action?: Privilege.ActionEnum;
    /**
     * The resources on which the action is allowed. Defaults to '*All*' if not specified.
     * @type {string}
     * @memberof Privilege
     */
    resource_name?: string;
    /**
     * Cluster ID (`usw2a1` for us-west-2, `use1a1` for us-east-1, `euc1a1` for eu-central-1) for which the action is allowed. Defaults to '*All*' if not specified.
     * @type {string}
     * @memberof Privilege
     */
    cluster?: string;
}
/**
 * @export
 * @namespace Privilege
 */
export declare namespace Privilege {
    /**
     * @export
     * @enum {string}
     */
    enum ActionEnum {
        ALLGLOBALACTIONS,
        GETORGGLOBAL,
        GETCURRENTUSERGLOBAL,
        INVITEUSERGLOBAL,
        DELETEUSERGLOBAL,
        LISTUSERSGLOBAL,
        GETBILLINGGLOBAL,
        UPDATEBILLINGGLOBAL,
        UPDATESETTINGSGLOBAL,
        GETMETRICSGLOBAL,
        CREATEVIGLOBAL,
        UPDATEVIGLOBAL,
        LISTVIGLOBAL,
        CREATEWSGLOBAL,
        LISTWSGLOBAL,
        CREATEINTEGRATIONGLOBAL,
        DELETEINTEGRATIONGLOBAL,
        LISTINTEGRATIONSGLOBAL,
        UPDATERESOURCEOWNERGLOBAL,
        CREATEAPIKEYGLOBAL,
        CREATEROLEGLOBAL,
        UPDATEROLEGLOBAL,
        DELETEROLEGLOBAL,
        LISTROLESGLOBAL,
        GRANTREVOKEROLEGLOBAL,
        ALLINTEGRATIONACTIONS,
        CREATECOLLECTIONINTEGRATION,
        ALLWORKSPACEACTIONS,
        DELETEWS,
        QUERYDATAWS,
        WRITEDATAWS,
        CREATECOLLECTIONWS,
        DELETECOLLECTIONWS,
        CREATEALIASWS,
        DELETEALIASWS,
        LISTRESOURCESWS,
        CREATEQUERYLAMBDAWS,
        DELETEQUERYLAMBDAWS,
        EXECUTEQUERYLAMBDAWS,
        CREATEVIEWWS,
        DELETEVIEWWS,
        ALLVIACTIONS,
        QUERYVI,
        UPDATEVI,
        SUSPENDRESUMEVI,
        DELETEVI
    }
}
/**
 *
 * @export
 * @interface QueryError
 */
export interface QueryError {
    /**
     * The type of error.
     * @type {string}
     * @memberof QueryError
     */
    type?: string;
    /**
     * A message associated with the error, containing more information about it.
     * @type {string}
     * @memberof QueryError
     */
    message?: string;
    /**
     * The HTTP status code associated with this error, had it been sent as the response status code
     * @type {number}
     * @memberof QueryError
     */
    status_code?: number;
}
/**
 *
 * @export
 * @interface QueryFieldType
 */
export interface QueryFieldType {
    /**
     * Name of the field.
     * @type {string}
     * @memberof QueryFieldType
     */
    name: string;
    /**
     * Data type of the field.
     * @type {string}
     * @memberof QueryFieldType
     */
    type: string;
}
/**
 *
 * @export
 * @interface QueryInfo
 */
export interface QueryInfo {
    /**
     * Unique Query ID.
     * @type {string}
     * @memberof QueryInfo
     */
    query_id?: string;
    /**
     * Status of the query.
     * @type {string}
     * @memberof QueryInfo
     */
    status?: QueryInfo.StatusEnum;
    /**
     * User ID who executed the query.
     * @type {string}
     * @memberof QueryInfo
     */
    executed_by?: string;
    /**
     * Time (UTC) the query request was first received and queued for execution.
     * @type {string}
     * @memberof QueryInfo
     */
    submitted_at?: string;
    /**
     * Time (UTC) that query results expire. Only populated if `status` is `COMPLETE`.
     * @type {string}
     * @memberof QueryInfo
     */
    expires_at?: string;
    /**
     * Various stats about the query's execution.
     * @type {Stats}
     * @memberof QueryInfo
     */
    stats?: Stats;
    /**
     * Information for fetching query results pages. Only populated if `status` is `COMPLETE`.
     * @type {Pagination}
     * @memberof QueryInfo
     */
    pagination?: Pagination;
    /**
     * The log offset that query results were written to in the destination collection. Only populated for INSERT INTO queries.
     * @type {string}
     * @memberof QueryInfo
     */
    last_offset?: string;
    /**
     * Errors encountered while executing the query.
     * @type {Array<QueryError>}
     * @memberof QueryInfo
     */
    query_errors?: Array<QueryError>;
}
/**
 * @export
 * @namespace QueryInfo
 */
export declare namespace QueryInfo {
    /**
     * @export
     * @enum {string}
     */
    enum StatusEnum {
        QUEUED,
        RUNNING,
        COMPLETED,
        ERROR,
        CANCELLED
    }
}
/**
 *
 * @export
 * @interface QueryLambda
 */
export interface QueryLambda {
    /**
     * Workspace of this Query Lambda.
     * @type {string}
     * @memberof QueryLambda
     */
    workspace?: string;
    /**
     * User that created this Query Lambda.
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated_by?: string;
    /**
     * ISO-8601 date of when Query Lambda was last updated.
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated?: string;
    /**
     * Query Lambda name.
     * @type {string}
     * @memberof QueryLambda
     */
    name?: string;
    /**
     * Number of Query Lambda versions.
     * @type {number}
     * @memberof QueryLambda
     */
    version_count?: number;
    /**
     * Collections/aliases queried by underlying SQL query.
     * @type {Array<string>}
     * @memberof QueryLambda
     */
    collections?: Array<string>;
    /**
     * Query Lambda version details for most recently created version.
     * @type {QueryLambdaVersion}
     * @memberof QueryLambda
     */
    latest_version?: QueryLambdaVersion;
}
/**
 *
 * @export
 * @interface QueryLambdaSql
 */
export interface QueryLambdaSql {
    /**
     * SQL text.
     * @type {string}
     * @memberof QueryLambdaSql
     */
    query: string;
    /**
     * Default parameters for this Query Lambda.
     * @type {Array<QueryParameter>}
     * @memberof QueryLambdaSql
     */
    default_parameters?: Array<QueryParameter>;
}
/**
 *
 * @export
 * @interface QueryLambdaStats
 */
export interface QueryLambdaStats {
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed?: string;
    /**
     * User who last executed Query Lambda.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed_by?: string;
    /**
     * ISO-8601 date of last execution failure.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error?: string;
    /**
     * Error message associated with last failed execution.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error_message?: string;
}
/**
 *
 * @export
 * @interface QueryLambdaTag
 */
export interface QueryLambdaTag {
    /**
     * Name of Query Lambda tag.
     * @type {string}
     * @memberof QueryLambdaTag
     */
    tag_name?: string;
    /**
     * Query lambda version.
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaTag
     */
    version?: QueryLambdaVersion;
}
/**
 *
 * @export
 * @interface QueryLambdaTagResponse
 */
export interface QueryLambdaTagResponse {
    /**
     * Updated Query Lambda tag.
     * @type {QueryLambdaTag}
     * @memberof QueryLambdaTagResponse
     */
    data?: QueryLambdaTag;
}
/**
 *
 * @export
 * @interface QueryLambdaVersion
 */
export interface QueryLambdaVersion {
    /**
     * Workspace of this Query Lambda.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    workspace?: string;
    /**
     * User that created this Query Lambda.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_by?: string;
    /**
     * ISO-8601 date of when Query Lambda was created.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_at?: string;
    /**
     * Query Lambda name.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    name?: string;
    /**
     * Query Lambda version.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    version?: string;
    /**
     * Optional description.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    description?: string;
    /**
     * Query Lambda SQL query.
     * @type {QueryLambdaSql}
     * @memberof QueryLambdaVersion
     */
    sql?: QueryLambdaSql;
    /**
     * Collections queried by underlying SQL query.
     * @type {Array<string>}
     * @memberof QueryLambdaVersion
     */
    collections?: Array<string>;
    /**
     * Status of this Query Lambda.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    state?: QueryLambdaVersion.StateEnum;
    /**
     * Stats related to this Query Lambda.
     * @type {QueryLambdaStats}
     * @memberof QueryLambdaVersion
     */
    stats?: QueryLambdaStats;
    /**
     * Public access ID associated with this QL version
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    public_access_id?: string;
}
/**
 * @export
 * @namespace QueryLambdaVersion
 */
export declare namespace QueryLambdaVersion {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        ACTIVE,
        INVALIDSQL
    }
}
/**
 *
 * @export
 * @interface QueryLambdaVersionResponse
 */
export interface QueryLambdaVersionResponse {
    /**
     * Query Lambda version details.
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaVersionResponse
     */
    data?: QueryLambdaVersion;
}
/**
 *
 * @export
 * @interface QueryPaginationResponse
 */
export interface QueryPaginationResponse {
    /**
     * List of documents returned by the query.
     * @type {Array<any>}
     * @memberof QueryPaginationResponse
     */
    results?: Array<any>;
    /**
     * Total documents returned by the query.
     * @type {number}
     * @memberof QueryPaginationResponse
     */
    results_total_doc_count?: number;
    /**
     * Pagination metadata.
     * @type {PaginationInfo}
     * @memberof QueryPaginationResponse
     */
    pagination?: PaginationInfo;
}
/**
 *
 * @export
 * @interface QueryParameter
 */
export interface QueryParameter {
    /**
     * Name of the field.
     * @type {string}
     * @memberof QueryParameter
     */
    name: string;
    /**
     * Data type of the field.
     * @type {string}
     * @memberof QueryParameter
     */
    type: string;
    /**
     * Literal value of the field.
     * @type {string}
     * @memberof QueryParameter
     */
    value: string;
}
/**
 *
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
    /**
     * Main query request body.
     * @type {QueryRequestSql}
     * @memberof QueryRequest
     */
    sql: QueryRequestSql;
    /**
     * Options for configuring Asynchronous Query Mode (beta).
     * @type {AsyncQueryOptions}
     * @memberof QueryRequest
     */
    async_options?: AsyncQueryOptions;
}
/**
 *
 * @export
 * @interface QueryRequestSql
 */
export interface QueryRequestSql {
    /**
     * SQL query string.
     * @type {string}
     * @memberof QueryRequestSql
     */
    query: string;
    /**
     * Flag to enable warnings. Warnings can help debug query issues but negatively affect performance.
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    generate_warnings?: boolean;
    /**
     * List of named parameters.
     * @type {Array<QueryParameter>}
     * @memberof QueryRequestSql
     */
    parameters?: Array<QueryParameter>;
    /**
     * Row limit to use. Limits specified in the query text will override this default.
     * @type {number}
     * @memberof QueryRequestSql
     */
    default_row_limit?: number;
    /**
     * Flag to paginate and store the results of this query for later / sequential retrieval.
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    paginate?: boolean;
    /**
     * Number of documents to return in addition to paginating for this query call. Only relevant if `paginate` flag is also set.
     * @type {number}
     * @memberof QueryRequestSql
     */
    initial_paginate_response_doc_count?: number;
}
/**
 *
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
    /**
     * Unique ID for this query.
     * @type {string}
     * @memberof QueryResponse
     */
    query_id?: string;
    /**
     * List of collections referenced in the query.
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    collections?: Array<string>;
    /**
     * Results from the query.
     * @type {Array<any>}
     * @memberof QueryResponse
     */
    results?: Array<any>;
    /**
     * Meta information about the query including execution latencies.
     * @type {QueryResponseStats}
     * @memberof QueryResponse
     */
    stats?: QueryResponseStats;
    /**
     * Warnings generated by the query. Only populated if `generate_warnings` is specified in the query request.
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    warnings?: Array<string>;
    /**
     * The full path of the executed query lambda. Includes version information.
     * @type {string}
     * @memberof QueryResponse
     */
    query_lambda_path?: string;
    /**
     * Errors encountered while executing the query.
     * @type {Array<QueryError>}
     * @memberof QueryResponse
     */
    query_errors?: Array<QueryError>;
    /**
     * Meta information about each column in the result set. Not populated in `SELECT *` queries.
     * @type {Array<QueryFieldType>}
     * @memberof QueryResponse
     */
    column_fields?: Array<QueryFieldType>;
    /**
     * Number of results generated by the query.
     * @type {number}
     * @memberof QueryResponse
     */
    results_total_doc_count?: number;
    /**
     * Pagination information. Only populated if `paginate` is specified in the query request.
     * @type {PaginationInfo}
     * @memberof QueryResponse
     */
    pagination?: PaginationInfo;
    /**
     * If this was a write query, this is the log offset the query was written to.
     * @type {string}
     * @memberof QueryResponse
     */
    last_offset?: string;
}
/**
 *
 * @export
 * @interface QueryResponseStats
 */
export interface QueryResponseStats {
    /**
     * Query time in milliseconds.
     * @type {number}
     * @memberof QueryResponseStats
     */
    elapsed_time_ms?: number;
    /**
     * Time query was throttled by admission control.
     * @type {number}
     * @memberof QueryResponseStats
     */
    throttled_time_micros?: number;
}
/**
 *
 * @export
 * @interface ResumeVirtualInstanceResponse
 */
export interface ResumeVirtualInstanceResponse {
    /**
     * Virtual instance that was resumed.
     * @type {VirtualInstance}
     * @memberof ResumeVirtualInstanceResponse
     */
    data?: VirtualInstance;
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof Role
     */
    role_name?: string;
    /**
     * Description for the role.
     * @type {string}
     * @memberof Role
     */
    description?: string;
    /**
     * Email of the user who currently owns the role.
     * @type {string}
     * @memberof Role
     */
    owner_email?: string;
    /**
     * Email of the user who created the role.
     * @type {string}
     * @memberof Role
     */
    created_by?: string;
    /**
     * List of privileges associated with the role.
     * @type {Array<Privilege>}
     * @memberof Role
     */
    privileges?: Array<Privilege>;
    /**
     * ISO-8601 date of when the role was created.
     * @type {string}
     * @memberof Role
     */
    created_at?: string;
}
/**
 *
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     *
     * @type {Role}
     * @memberof RoleResponse
     */
    data?: Role;
}
/**
 *
 * @export
 * @interface S3Integration
 */
export interface S3Integration {
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof S3Integration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof S3Integration
     */
    aws_role?: AwsRole;
}
/**
 *
 * @export
 * @interface SchemaRegistryConfig
 */
export interface SchemaRegistryConfig {
    /**
     * Schema registry URL.
     * @type {string}
     * @memberof SchemaRegistryConfig
     */
    url?: string;
    /**
     * The secure API key for schema registry.
     * @type {string}
     * @memberof SchemaRegistryConfig
     */
    key?: string;
    /**
     * The secure API password registry.
     * @type {string}
     * @memberof SchemaRegistryConfig
     */
    secret?: string;
}
/**
 *
 * @export
 * @interface SnowflakeIntegration
 */
export interface SnowflakeIntegration {
    /**
     * Snowflake browser url.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    snowflake_url: string;
    /**
     * Snowflake database username.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    username: string;
    /**
     * Snowflake database password.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    password: string;
    /**
     * Snowflake user role. If unspecified, will use the default user role.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    user_role?: string;
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof SnowflakeIntegration
     */
    aws_role?: AwsRole;
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof SnowflakeIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * default snowflake data warehouse name for query execution. Warehouse name can be overridden in the collection.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    default_warehouse: string;
    /**
     * S3 path used for running 'COPY INTO' command on snowflake table.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    s3_export_path: string;
}
/**
 * Details about the data source for the given collection. Only one of the following fields are allowed to be defined. Only collections can act as data sources for views.
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Unique source identifier.
     * @type {string}
     * @memberof Source
     */
    id?: string;
    /**
     * Name of integration to use.
     * @type {string}
     * @memberof Source
     */
    integration_name?: string;
    /**
     * Configuration for ingestion from S3.
     * @type {SourceS3}
     * @memberof Source
     */
    s3?: SourceS3;
    /**
     * Configuration for ingestion from kinesis stream.
     * @type {SourceKinesis}
     * @memberof Source
     */
    kinesis?: SourceKinesis;
    /**
     * Configuration for ingestion from GCS.
     * @type {SourceGcs}
     * @memberof Source
     */
    gcs?: SourceGcs;
    /**
     * Configuration for ingestion from Azure Blob Storage.
     * @type {SourceAzureBlobStorage}
     * @memberof Source
     */
    azure_blob_storage?: SourceAzureBlobStorage;
    /**
     * Configuration for ingestion from Azure Service Bus.
     * @type {SourceAzureServiceBus}
     * @memberof Source
     */
    azure_service_bus?: SourceAzureServiceBus;
    /**
     * Configuration for ingestion from Azure Event Hubs.
     * @type {SourceAzureEventHubs}
     * @memberof Source
     */
    azure_event_hubs?: SourceAzureEventHubs;
    /**
     * Configuration for ingestion from  a dynamodb table.
     * @type {SourceDynamoDb}
     * @memberof Source
     */
    dynamodb?: SourceDynamoDb;
    /**
     * File upload details.
     * @type {SourceFileUpload}
     * @memberof Source
     */
    file_upload?: SourceFileUpload;
    /**
     * Kafka collection identifier.
     * @type {SourceKafka}
     * @memberof Source
     */
    kafka?: SourceKafka;
    /**
     * MongoDB collection details.
     * @type {SourceMongoDb}
     * @memberof Source
     */
    mongodb?: SourceMongoDb;
    /**
     * Configuration for ingestion from Snowflake.
     * @type {SourceSnowflake}
     * @memberof Source
     */
    snowflake?: SourceSnowflake;
    /**
     * The ingest status of this source.
     * @type {Status}
     * @memberof Source
     */
    status?: Status;
    /**
     * Format parameters for data from this source.
     * @type {FormatParams}
     * @memberof Source
     */
    format_params?: FormatParams;
}
/**
 *
 * @export
 * @interface SourceAzureBlobStorage
 */
export interface SourceAzureBlobStorage {
    /**
     * Name of Azure blob Storage container you want to ingest from.
     * @type {string}
     * @memberof SourceAzureBlobStorage
     */
    container?: string;
    /**
     * Prefix that selects blobs to ingest.
     * @type {string}
     * @memberof SourceAzureBlobStorage
     */
    prefix?: string;
    /**
     * Glob-style pattern that selects keys to ingest. Only either prefix or pattern can be specified.
     * @type {string}
     * @memberof SourceAzureBlobStorage
     */
    pattern?: string;
    /**
     *
     * @type {number}
     * @memberof SourceAzureBlobStorage
     */
    blob_count_downloaded?: number;
    /**
     *
     * @type {number}
     * @memberof SourceAzureBlobStorage
     */
    blob_count_total?: number;
    /**
     *
     * @type {number}
     * @memberof SourceAzureBlobStorage
     */
    blob_bytes_total?: number;
}
/**
 *
 * @export
 * @interface SourceAzureEventHubs
 */
export interface SourceAzureEventHubs {
    /**
     * Name of the hub which rockset should ingest from.
     * @type {string}
     * @memberof SourceAzureEventHubs
     */
    hub_id?: string;
    /**
     * The offset reset policy.
     * @type {string}
     * @memberof SourceAzureEventHubs
     */
    offset_reset_policy?: SourceAzureEventHubs.OffsetResetPolicyEnum;
    /**
     * Source status.
     * @type {StatusAzureEventHubs}
     * @memberof SourceAzureEventHubs
     */
    status?: StatusAzureEventHubs;
}
/**
 * @export
 * @namespace SourceAzureEventHubs
 */
export declare namespace SourceAzureEventHubs {
    /**
     * @export
     * @enum {string}
     */
    enum OffsetResetPolicyEnum {
        LATEST,
        EARLIEST
    }
}
/**
 *
 * @export
 * @interface SourceAzureServiceBus
 */
export interface SourceAzureServiceBus {
    /**
     * Name of the topic which rockset should ingest from.
     * @type {string}
     * @memberof SourceAzureServiceBus
     */
    topic?: string;
    /**
     * The subscription to read from the topic.
     * @type {string}
     * @memberof SourceAzureServiceBus
     */
    subscription?: string;
    /**
     * Azure Service bus source status.
     * @type {StatusAzureServiceBus}
     * @memberof SourceAzureServiceBus
     */
    status?: StatusAzureServiceBus;
}
/**
 *
 * @export
 * @interface SourceDynamoDb
 */
export interface SourceDynamoDb {
    /**
     * AWS region name of DynamoDB table, by default us-west-2 is used.
     * @type {string}
     * @memberof SourceDynamoDb
     */
    aws_region?: string;
    /**
     * Name of DynamoDB table containing data.
     * @type {string}
     * @memberof SourceDynamoDb
     */
    table_name: string;
    /**
     * DynamoDB source status v2.
     * @type {StatusDynamoDbV2}
     * @memberof SourceDynamoDb
     */
    current_status?: StatusDynamoDbV2;
    /**
     * Max RCU usage for scan.
     * @type {number}
     * @memberof SourceDynamoDb
     */
    rcu?: number;
    /**
     * DynamoDB source status.
     * @type {StatusDynamoDb}
     * @memberof SourceDynamoDb
     */
    status?: StatusDynamoDb;
    /**
     * Whether to use DynamoDB Scan API for the initial scan.
     * @type {boolean}
     * @memberof SourceDynamoDb
     */
    use_scan_api?: boolean;
}
/**
 *
 * @export
 * @interface SourceFileUpload
 */
export interface SourceFileUpload {
    /**
     * Name of the file.
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_name: string;
    /**
     * Size of the file in bytes.
     * @type {number}
     * @memberof SourceFileUpload
     */
    file_size: number;
    /**
     * Time of file upload.
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_upload_time: string;
}
/**
 *
 * @export
 * @interface SourceGcs
 */
export interface SourceGcs {
    /**
     * Name of GCS bucket you want to ingest from.
     * @type {string}
     * @memberof SourceGcs
     */
    bucket?: string;
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceGcs
     */
    prefix?: string;
    /**
     * Glob-style pattern that selects keys to ingest. Only either prefix or pattern can be specified.
     * @type {string}
     * @memberof SourceGcs
     */
    pattern?: string;
    /**
     *
     * @type {number}
     * @memberof SourceGcs
     */
    object_count_downloaded?: number;
    /**
     *
     * @type {number}
     * @memberof SourceGcs
     */
    object_count_total?: number;
    /**
     *
     * @type {number}
     * @memberof SourceGcs
     */
    object_bytes_total?: number;
    /**
     *
     * @type {number}
     * @memberof SourceGcs
     */
    object_bytes_downloaded?: number;
}
/**
 *
 * @export
 * @interface SourceKafka
 */
export interface SourceKafka {
    /**
     * The Kafka topic to be tailed.
     * @type {string}
     * @memberof SourceKafka
     */
    kafka_topic_name?: string;
    /**
     * Kafka source status.
     * @type {StatusKafka}
     * @memberof SourceKafka
     */
    status?: StatusKafka;
    /**
     * The Kafka consumer group Id being used.
     * @type {string}
     * @memberof SourceKafka
     */
    consumer_group_id?: string;
    /**
     * Whether to use v3 integration.
     * @type {boolean}
     * @memberof SourceKafka
     */
    use_v3?: boolean;
    /**
     * The offset reset policy.
     * @type {string}
     * @memberof SourceKafka
     */
    offset_reset_policy?: SourceKafka.OffsetResetPolicyEnum;
}
/**
 * @export
 * @namespace SourceKafka
 */
export declare namespace SourceKafka {
    /**
     * @export
     * @enum {string}
     */
    enum OffsetResetPolicyEnum {
        LATEST,
        EARLIEST
    }
}
/**
 *
 * @export
 * @interface SourceKinesis
 */
export interface SourceKinesis {
    /**
     * AWS region name of Kinesis stream, by default us-west-2 is used.
     * @type {string}
     * @memberof SourceKinesis
     */
    aws_region?: string;
    /**
     * Name of kinesis stream.
     * @type {string}
     * @memberof SourceKinesis
     */
    stream_name: string;
    /**
     * Set of fields that correspond to a DMS primary key.
     * @type {Array<string>}
     * @memberof SourceKinesis
     */
    dms_primary_key?: Array<string>;
    /**
     * For non-DMS streams, Rockset can tail from the earliest end or latest end of kinesis source.
     * @type {string}
     * @memberof SourceKinesis
     */
    offset_reset_policy?: SourceKinesis.OffsetResetPolicyEnum;
}
/**
 * @export
 * @namespace SourceKinesis
 */
export declare namespace SourceKinesis {
    /**
     * @export
     * @enum {string}
     */
    enum OffsetResetPolicyEnum {
        LATEST,
        EARLIEST
    }
}
/**
 *
 * @export
 * @interface SourceMongoDb
 */
export interface SourceMongoDb {
    /**
     * MongoDB database name containing this collection.
     * @type {string}
     * @memberof SourceMongoDb
     */
    database_name: string;
    /**
     * MongoDB collection name.
     * @type {string}
     * @memberof SourceMongoDb
     */
    collection_name: string;
    /**
     * MongoDB source status.
     * @type {StatusMongoDb}
     * @memberof SourceMongoDb
     */
    status?: StatusMongoDb;
}
/**
 *
 * @export
 * @interface SourceS3
 */
export interface SourceS3 {
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceS3
     */
    prefix?: string;
    /**
     * Glob-style pattern that selects keys to ingest. Only either prefix or pattern can be specified.
     * @type {string}
     * @memberof SourceS3
     */
    pattern?: string;
    /**
     * AWS region containing source bucket.
     * @type {string}
     * @memberof SourceS3
     */
    region?: string;
    /**
     * Address of S3 bucket containing data.
     * @type {string}
     * @memberof SourceS3
     */
    bucket: string;
    /**
     * List of prefixes to paths from which data should be ingested.
     * @type {Array<string>}
     * @memberof SourceS3
     */
    prefixes: Array<string>;
    /**
     *
     * @type {number}
     * @memberof SourceS3
     */
    object_count_downloaded?: number;
    /**
     *
     * @type {number}
     * @memberof SourceS3
     */
    object_count_total?: number;
    /**
     *
     * @type {number}
     * @memberof SourceS3
     */
    object_bytes_total?: number;
    /**
     *
     * @type {number}
     * @memberof SourceS3
     */
    object_bytes_downloaded?: number;
}
/**
 *
 * @export
 * @interface SourceSnowflake
 */
export interface SourceSnowflake {
    /**
     * Name of the snowflake database.
     * @type {string}
     * @memberof SourceSnowflake
     */
    database: string;
    /**
     * Name of the snowflake database schema.
     * @type {string}
     * @memberof SourceSnowflake
     */
    schema: string;
    /**
     * Name of the snowflake table.
     * @type {string}
     * @memberof SourceSnowflake
     */
    table_name: string;
    /**
     * Name of the data warehouse to be used.
     * @type {string}
     * @memberof SourceSnowflake
     */
    warehouse?: string;
    /**
     * Snowflake source status.
     * @type {StatusSnowflake}
     * @memberof SourceSnowflake
     */
    status?: StatusSnowflake;
}
/**
 *
 * @export
 * @interface SqlExpression
 */
export interface SqlExpression {
    /**
     * The name of a sql function.
     * @type {string}
     * @memberof SqlExpression
     */
    sql?: string;
}
/**
 *
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     * Total execution time (including time queued) of the query, in milliseconds.
     * @type {number}
     * @memberof Stats
     */
    elapsed_time_ms?: number;
    /**
     * Time query spent queued, in milliseconds.
     * @type {number}
     * @memberof Stats
     */
    throttled_time_ms?: number;
    /**
     * Number of documents returned by the query. Only populated if `status` is `COMPLETE`.
     * @type {number}
     * @memberof Stats
     */
    result_set_document_count?: number;
    /**
     * Number of bytes in the query result set. Only populated if `status` is `COMPLETE`. Not populated for INSERT INTO queries.
     * @type {number}
     * @memberof Stats
     */
    result_set_bytes_size?: number;
}
/**
 *
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Status of the Source's ingestion.
     * @type {string}
     * @memberof Status
     */
    state?: Status.StateEnum;
    /**
     * State message.
     * @type {string}
     * @memberof Status
     */
    message?: string;
    /**
     * ISO-8601 date when source was last processed.
     * @type {string}
     * @memberof Status
     */
    last_processed_at?: string;
    /**
     * Last source item processed by ingester.
     * @type {string}
     * @memberof Status
     */
    last_processed_item?: string;
    /**
     * Total items processed of source.
     * @type {number}
     * @memberof Status
     */
    total_processed_items?: number;
    /**
     * Size in bytes detected for the source at collection initialization. This size can be 0 or null for event stream sources.
     * @type {number}
     * @memberof Status
     */
    detected_size_bytes?: number;
}
/**
 * @export
 * @namespace Status
 */
export declare namespace Status {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        INITIALIZING,
        WATCHING,
        PROCESSING,
        COMPLETED,
        ERROR
    }
}
/**
 *
 * @export
 * @interface StatusAzureEventHubs
 */
export interface StatusAzureEventHubs {
    /**
     * State of the source.
     * @type {string}
     * @memberof StatusAzureEventHubs
     */
    state?: StatusAzureEventHubs.StateEnum;
    /**
     * Time at which the last document was consumed.
     * @type {string}
     * @memberof StatusAzureEventHubs
     */
    last_consumed_time?: string;
    /**
     * Number of documents consumed.
     * @type {number}
     * @memberof StatusAzureEventHubs
     */
    num_documents_processed?: number;
    /**
     * Status info per partition.
     * @type {Array<StatusAzureEventHubsPartition>}
     * @memberof StatusAzureEventHubs
     */
    partitions?: Array<StatusAzureEventHubsPartition>;
}
/**
 * @export
 * @namespace StatusAzureEventHubs
 */
export declare namespace StatusAzureEventHubs {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        NODOCSYET,
        ACTIVE,
        DORMANT
    }
}
/**
 *
 * @export
 * @interface StatusAzureEventHubsPartition
 */
export interface StatusAzureEventHubsPartition {
    /**
     * The number of this partition.
     * @type {number}
     * @memberof StatusAzureEventHubsPartition
     */
    partition_number?: number;
    /**
     * Latest offset of partition.
     * @type {number}
     * @memberof StatusAzureEventHubsPartition
     */
    partition_offset?: number;
    /**
     * Per partition lag for offset.
     * @type {number}
     * @memberof StatusAzureEventHubsPartition
     */
    offset_lag?: number;
}
/**
 *
 * @export
 * @interface StatusAzureServiceBus
 */
export interface StatusAzureServiceBus {
    /**
     * Service Bus first message processed time in ISO-8601 format.
     * @type {string}
     * @memberof StatusAzureServiceBus
     */
    first_processed_at?: string;
    /**
     * Number of records processed.
     * @type {number}
     * @memberof StatusAzureServiceBus
     */
    records_processed?: number;
    /**
     * Sessions processed.
     * @type {{ [key: string]: StatusAzureServiceBusSession; }}
     * @memberof StatusAzureServiceBus
     */
    sessions?: {
        [key: string]: StatusAzureServiceBusSession;
    };
}
/**
 *
 * @export
 * @interface StatusAzureServiceBusSession
 */
export interface StatusAzureServiceBusSession {
    /**
     * The last processed sequence number within this session.
     * @type {number}
     * @memberof StatusAzureServiceBusSession
     */
    sequence_number?: number;
    /**
     * Most recent ISO-8601 date when a message from this session was processed.
     * @type {string}
     * @memberof StatusAzureServiceBusSession
     */
    last_processed?: string;
}
/**
 *
 * @export
 * @interface StatusDynamoDb
 */
export interface StatusDynamoDb {
    /**
     * DynamoDB scan start time.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_start_time?: string;
    /**
     * DynamoDb scan end time.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan.
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_records_processed?: number;
    /**
     * Number of records in DynamoDB table at time of scan.
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_total_records?: number;
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    state?: StatusDynamoDb.StateEnum;
    /**
     * ISO-8601 date when source was last processed.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    stream_last_processed_at?: string;
}
/**
 * @export
 * @namespace StatusDynamoDb
 */
export declare namespace StatusDynamoDb {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        INITIALIZING,
        SCANNINGTABLE,
        PROCESSINGSTREAM
    }
}
/**
 *
 * @export
 * @interface StatusDynamoDbV2
 */
export interface StatusDynamoDbV2 {
    /**
     *
     * @type {number}
     * @memberof StatusDynamoDbV2
     */
    initial_dump_completion_percentage?: number;
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusDynamoDbV2
     */
    state?: StatusDynamoDbV2.StateEnum;
    /**
     * ISO-8601 date when source was last processed.
     * @type {string}
     * @memberof StatusDynamoDbV2
     */
    stream_last_processed_at?: string;
}
/**
 * @export
 * @namespace StatusDynamoDbV2
 */
export declare namespace StatusDynamoDbV2 {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        INITIALIZING,
        SCANNING,
        EXPORTINGTOS3,
        DOWNLOADINGFROMS3,
        PROCESSINGSTREAM
    }
}
/**
 *
 * @export
 * @interface StatusKafka
 */
export interface StatusKafka {
    /**
     * State of the Kafka source.
     * @type {string}
     * @memberof StatusKafka
     */
    state?: StatusKafka.StateEnum;
    /**
     * Time at which the last document was consumed from Kafka.
     * @type {string}
     * @memberof StatusKafka
     */
    last_consumed_time?: string;
    /**
     * Number of documents consumed by this Kafka topic.
     * @type {number}
     * @memberof StatusKafka
     */
    num_documents_processed?: number;
    /**
     * Status info per partition.
     * @type {Array<StatusKafkaPartition>}
     * @memberof StatusKafka
     */
    kafka_partitions?: Array<StatusKafkaPartition>;
}
/**
 * @export
 * @namespace StatusKafka
 */
export declare namespace StatusKafka {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        NODOCSYET,
        ACTIVE,
        DORMANT
    }
}
/**
 *
 * @export
 * @interface StatusKafkaPartition
 */
export interface StatusKafkaPartition {
    /**
     * The number of this partition.
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    partition_number?: number;
    /**
     * Latest offset of partition.
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    partition_offset?: number;
    /**
     * Per partition lag for offset.
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    offset_lag?: number;
}
/**
 *
 * @export
 * @interface StatusMongoDb
 */
export interface StatusMongoDb {
    /**
     * MongoDB scan start time.
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_start_time?: string;
    /**
     * MongoDB scan end time.
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan.
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_records_processed?: number;
    /**
     * Number of records in MongoDB table at time of scan.
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_total_records?: number;
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusMongoDb
     */
    state?: StatusMongoDb.StateEnum;
    /**
     * ISO-8601 date when new insert from source was last processed.
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_insert_processed_at?: string;
    /**
     * ISO-8601 date when update from source was last processed.
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_update_processed_at?: string;
    /**
     * ISO-8601 date when delete from source was last processed.
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_delete_processed_at?: string;
    /**
     * Number of new records inserted using stream.
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_inserted?: number;
    /**
     * Number of new records updated using stream.
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_updated?: number;
    /**
     * Number of new records deleted using stream.
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_deleted?: number;
}
/**
 * @export
 * @namespace StatusMongoDb
 */
export declare namespace StatusMongoDb {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        INITIALIZING,
        SCANNINGTABLE,
        PROCESSINGSTREAM
    }
}
/**
 *
 * @export
 * @interface StatusSnowflake
 */
export interface StatusSnowflake {
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusSnowflake
     */
    state?: StatusSnowflake.StateEnum;
}
/**
 * @export
 * @namespace StatusSnowflake
 */
export declare namespace StatusSnowflake {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        INITIALIZING,
        EXPORTINGTOS3,
        DOWNLOADINGFROMS3,
        COMPLETED
    }
}
/**
 *
 * @export
 * @interface SuspendVirtualInstanceResponse
 */
export interface SuspendVirtualInstanceResponse {
    /**
     * Virtual instance that was suspended.
     * @type {VirtualInstance}
     * @memberof SuspendVirtualInstanceResponse
     */
    data?: VirtualInstance;
}
/**
 * Notification preferences for the user.
 * @export
 * @interface UnsubscribePreference
 */
export interface UnsubscribePreference {
    /**
     * The type of notification to be unsubscribed from.
     * @type {string}
     * @memberof UnsubscribePreference
     */
    notificationType: string;
}
/**
 *
 * @export
 * @interface UpdateAliasRequest
 */
export interface UpdateAliasRequest {
    /**
     * Optional description.
     * @type {string}
     * @memberof UpdateAliasRequest
     */
    description?: string;
    /**
     * List of fully qualified collection names referenced by alias.
     * @type {Array<string>}
     * @memberof UpdateAliasRequest
     */
    collections: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateApiKeyRequest
 */
export interface UpdateApiKeyRequest {
    /**
     * State that the api key should be set to.
     * @type {string}
     * @memberof UpdateApiKeyRequest
     */
    state?: UpdateApiKeyRequest.StateEnum;
}
/**
 * @export
 * @namespace UpdateApiKeyRequest
 */
export declare namespace UpdateApiKeyRequest {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        ACTIVE,
        SUSPENDED
    }
}
/**
 *
 * @export
 * @interface UpdateApiKeyResponse
 */
export interface UpdateApiKeyResponse {
    /**
     * The API key that was updated.
     * @type {ApiKey}
     * @memberof UpdateApiKeyResponse
     */
    data?: ApiKey;
}
/**
 *
 * @export
 * @interface UpdateQueryLambdaRequest
 */
export interface UpdateQueryLambdaRequest {
    /**
     * Optional description.
     * @type {string}
     * @memberof UpdateQueryLambdaRequest
     */
    description?: string;
    /**
     * Query Lambda SQL query.
     * @type {QueryLambdaSql}
     * @memberof UpdateQueryLambdaRequest
     */
    sql?: QueryLambdaSql;
    /**
     *
     * @type {boolean}
     * @memberof UpdateQueryLambdaRequest
     */
    is_public?: boolean;
}
/**
 *
 * @export
 * @interface UpdateRoleRequest
 */
export interface UpdateRoleRequest {
    /**
     * Description for the role.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    description?: string;
    /**
     * List of privileges that will be associated with the role.
     * @type {Array<Privilege>}
     * @memberof UpdateRoleRequest
     */
    privileges?: Array<Privilege>;
}
/**
 *
 * @export
 * @interface UpdateUnsubscribePreferencesRequest
 */
export interface UpdateUnsubscribePreferencesRequest {
    /**
     * List of notification preferences.
     * @type {Array<UnsubscribePreference>}
     * @memberof UpdateUnsubscribePreferencesRequest
     */
    data?: Array<UnsubscribePreference>;
}
/**
 *
 * @export
 * @interface UpdateUnsubscribePreferencesResponse
 */
export interface UpdateUnsubscribePreferencesResponse {
    /**
     * List of notification preferences.
     * @type {Array<UnsubscribePreference>}
     * @memberof UpdateUnsubscribePreferencesResponse
     */
    data?: Array<UnsubscribePreference>;
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * User first name.
     * @type {string}
     * @memberof UpdateUserRequest
     */
    first_name?: string;
    /**
     * User last name.
     * @type {string}
     * @memberof UpdateUserRequest
     */
    last_name?: string;
    /**
     * New list of roles for a given user.
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    roles?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateViewRequest
 */
export interface UpdateViewRequest {
    /**
     * Optional description.
     * @type {string}
     * @memberof UpdateViewRequest
     */
    description?: string;
    /**
     * SQL for this view.
     * @type {string}
     * @memberof UpdateViewRequest
     */
    query: string;
}
/**
 *
 * @export
 * @interface UpdateViewResponse
 */
export interface UpdateViewResponse {
    /**
     * View that was updated.
     * @type {View}
     * @memberof UpdateViewResponse
     */
    data?: View;
}
/**
 *
 * @export
 * @interface UpdateVirtualInstanceRequest
 */
export interface UpdateVirtualInstanceRequest {
    /**
     * Requested virtual instance size.
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    new_size?: UpdateVirtualInstanceRequest.NewSizeEnum;
    /**
     *
     * @type {boolean}
     * @memberof UpdateVirtualInstanceRequest
     */
    monitoring_enabled?: boolean;
    /**
     * New virtual instance name.
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    name?: string;
    /**
     * New virtual instance description.
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    description?: string;
    /**
     * Whether auto-suspend should be enabled for this Virtual Instance.
     * @type {boolean}
     * @memberof UpdateVirtualInstanceRequest
     */
    auto_suspend_enabled?: boolean;
    /**
     * Number of seconds without queries after which the VI is suspended
     * @type {number}
     * @memberof UpdateVirtualInstanceRequest
     */
    auto_suspend_seconds?: number;
}
/**
 * @export
 * @namespace UpdateVirtualInstanceRequest
 */
export declare namespace UpdateVirtualInstanceRequest {
    /**
     * @export
     * @enum {string}
     */
    enum NewSizeEnum {
        FREE,
        NANO,
        SHARED,
        MILLI,
        SMALL,
        MEDIUM,
        LARGE,
        XLARGE,
        XLARGE2,
        XLARGE4,
        XLARGE8,
        XLARGE16
    }
}
/**
 *
 * @export
 * @interface UpdateVirtualInstanceResponse
 */
export interface UpdateVirtualInstanceResponse {
    /**
     * Virtual instance that was switched.
     * @type {VirtualInstance}
     * @memberof UpdateVirtualInstanceResponse
     */
    data?: VirtualInstance;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof User
     */
    created_at?: string;
    /**
     * User email.
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * User first name.
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * User last name.
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * List of roles for a given user.
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<string>;
    /**
     * State of user - NEW / ACTIVE.
     * @type {string}
     * @memberof User
     */
    state?: string;
}
/**
 *
 * @export
 * @interface ValidateQueryResponse
 */
export interface ValidateQueryResponse {
    /**
     * List of collections specified in query.
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    collections: Array<string>;
    /**
     * List of parameters specified in query.
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    parameters: Array<string>;
}
/**
 *
 * @export
 * @interface View
 */
export interface View {
    /**
     *
     * @type {string}
     * @memberof View
     */
    path?: string;
    /**
     * Name of the view.
     * @type {string}
     * @memberof View
     */
    name?: string;
    /**
     * View description.
     * @type {string}
     * @memberof View
     */
    description?: string;
    /**
     * Name of the workspace.
     * @type {string}
     * @memberof View
     */
    workspace?: string;
    /**
     * Email of the creator.
     * @type {string}
     * @memberof View
     */
    creator_email?: string;
    /**
     * Email of the owner, note: deprecated and will always be null.
     * @type {string}
     * @memberof View
     */
    owner_email?: string;
    /**
     * SQL query of the view.
     * @type {string}
     * @memberof View
     */
    query_sql?: string;
    /**
     * List of entities referenced by view. An entity can be a view, alias or collection.
     * @type {Array<string>}
     * @memberof View
     */
    entities?: Array<string>;
    /**
     * State of the view.
     * @type {string}
     * @memberof View
     */
    state?: View.StateEnum;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof View
     */
    created_at?: string;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof View
     */
    modified_at?: string;
}
/**
 * @export
 * @namespace View
 */
export declare namespace View {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        CREATED,
        SYNCING,
        DELETED
    }
}
/**
 *
 * @export
 * @interface VirtualInstance
 */
export interface VirtualInstance {
    /**
     * Virtual instance name.
     * @type {string}
     * @memberof VirtualInstance
     */
    name: string;
    /**
     * Virtual instance description.
     * @type {string}
     * @memberof VirtualInstance
     */
    description?: string;
    /**
     * Creator of requested virtual instance.
     * @type {string}
     * @memberof VirtualInstance
     */
    created_by?: string;
    /**
     * ISO-8601 date of when virtual instance was created.
     * @type {string}
     * @memberof VirtualInstance
     */
    created_at?: string;
    /**
     * ISO-8601 date of when virtual instance was created.
     * @type {string}
     * @memberof VirtualInstance
     */
    resumed_at?: string;
    /**
     * Virtual instance state.
     * @type {string}
     * @memberof VirtualInstance
     */
    state?: VirtualInstance.StateEnum;
    /**
     * Virtual instance current size.
     * @type {string}
     * @memberof VirtualInstance
     */
    current_size?: VirtualInstance.CurrentSizeEnum;
    /**
     * Virtual instance desired size.
     * @type {string}
     * @memberof VirtualInstance
     */
    desired_size?: VirtualInstance.DesiredSizeEnum;
    /**
     *
     * @type {boolean}
     * @memberof VirtualInstance
     */
    monitoring_enabled?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof VirtualInstance
     */
    default_vi?: boolean;
    /**
     *
     * @type {number}
     * @memberof VirtualInstance
     */
    default_pod_count?: number;
    /**
     *
     * @type {number}
     * @memberof VirtualInstance
     */
    scaled_pod_count?: number;
    /**
     * Unique identifier for virtual instance.
     * @type {string}
     * @memberof VirtualInstance
     */
    id?: string;
    /**
     * Virtual Instance RRN.
     * @type {string}
     * @memberof VirtualInstance
     */
    rrn?: string;
    /**
     * Number of seconds without queries after which the VI is suspended
     * @type {number}
     * @memberof VirtualInstance
     */
    auto_suspend_seconds?: number;
    /**
     * Stats about this VirtualInstance
     * @type {VirtualInstanceStats}
     * @memberof VirtualInstance
     */
    stats?: VirtualInstanceStats;
}
/**
 * @export
 * @namespace VirtualInstance
 */
export declare namespace VirtualInstance {
    /**
     * @export
     * @enum {string}
     */
    enum StateEnum {
        INITIALIZING,
        PROVISIONINGRESOURCES,
        REBALANCINGCOLLECTIONS,
        ACTIVE,
        SUSPENDING,
        SUSPENDED,
        RESUMING,
        DELETED
    }
    /**
     * @export
     * @enum {string}
     */
    enum CurrentSizeEnum {
        FREE,
        NANO,
        SHARED,
        MILLI,
        SMALL,
        MEDIUM,
        LARGE,
        XLARGE,
        XLARGE2,
        XLARGE4,
        XLARGE8,
        XLARGE16
    }
    /**
     * @export
     * @enum {string}
     */
    enum DesiredSizeEnum {
        FREE,
        NANO,
        SHARED,
        MILLI,
        SMALL,
        MEDIUM,
        LARGE,
        XLARGE,
        XLARGE2,
        XLARGE4,
        XLARGE8,
        XLARGE16
    }
}
/**
 *
 * @export
 * @interface VirtualInstanceStats
 */
export interface VirtualInstanceStats {
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof VirtualInstanceStats
     */
    last_queried_ms?: number;
}
/**
 * Workspaces are organizational containers for collections.
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * ISO-8601 date of when workspace was created.
     * @type {string}
     * @memberof Workspace
     */
    created_at?: string;
    /**
     * Email of user who created the workspace.
     * @type {string}
     * @memberof Workspace
     */
    created_by?: string;
    /**
     * Descriptive label and unique identifier.
     * @type {string}
     * @memberof Workspace
     */
    name?: string;
    /**
     * Longer explanation for the workspace.
     * @type {string}
     * @memberof Workspace
     */
    description?: string;
    /**
     * Number of collections that are immediate children of workspace.
     * @type {number}
     * @memberof Workspace
     */
    collection_count?: number;
}
/**
 *
 * @export
 * @interface XmlParams
 */
export interface XmlParams {
    /**
     * Tag until which xml is ignored.
     * @type {string}
     * @memberof XmlParams
     */
    root_tag?: string;
    /**
     * Encoding in which data source is encoded.
     * @type {string}
     * @memberof XmlParams
     */
    encoding?: string;
    /**
     * Tags with which documents are identified.
     * @type {string}
     * @memberof XmlParams
     */
    doc_tag?: string;
    /**
     * tag used for the value when there are attributes in the element having no child
     * @type {string}
     * @memberof XmlParams
     */
    value_tag?: string;
    /**
     * Tag to differentiate between attributes and elements.
     * @type {string}
     * @memberof XmlParams
     */
    attribute_prefix?: string;
}
/**
 * APIKeysApi - fetch parameter creator
 * @export
 */
export declare const APIKeysApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(body: CreateApiKeyRequest, options?: any): FetchArgs;
    /**
     * Delete an API key for any user in your organization.
     * @summary Delete API Key
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(name: string, user: string, options?: any): FetchArgs;
    /**
     * Retrieve a particular API key for any user in your organization.
     * @summary Retrieve API Key
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {string} name Name of the API key.
     * @param {boolean} [reveal] Reveal full key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey(user: string, name: string, reveal?: boolean | undefined, options?: any): FetchArgs;
    /**
     * List API key metadata for any user in your organization.
     * @summary List API Keys
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(user: string, options?: any): FetchArgs;
    /**
     * Update the state of an API key for any user in your organization.
     * @summary Update API Key State
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {UpdateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any): FetchArgs;
};
/**
 * APIKeysApi - functional programming interface
 * @export
 */
export declare const APIKeysApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(body: CreateApiKeyRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateApiKeyResponse>;
    /**
     * Delete an API key for any user in your organization.
     * @summary Delete API Key
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(name: string, user: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteApiKeyResponse>;
    /**
     * Retrieve a particular API key for any user in your organization.
     * @summary Retrieve API Key
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {string} name Name of the API key.
     * @param {boolean} [reveal] Reveal full key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey(user: string, name: string, reveal?: boolean | undefined, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetApiKeyResponse>;
    /**
     * List API key metadata for any user in your organization.
     * @summary List API Keys
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(user: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListApiKeysResponse>;
    /**
     * Update the state of an API key for any user in your organization.
     * @summary Update API Key State
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {UpdateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<UpdateApiKeyResponse>;
};
/**
 * APIKeysApi - factory interface
 * @export
 */
export declare const APIKeysApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(body: CreateApiKeyRequest, options?: any): Promise<CreateApiKeyResponse>;
    /**
     * Delete an API key for any user in your organization.
     * @summary Delete API Key
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(name: string, user: string, options?: any): Promise<DeleteApiKeyResponse>;
    /**
     * Retrieve a particular API key for any user in your organization.
     * @summary Retrieve API Key
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {string} name Name of the API key.
     * @param {boolean} [reveal] Reveal full key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey(user: string, name: string, reveal?: boolean | undefined, options?: any): Promise<GetApiKeyResponse>;
    /**
     * List API key metadata for any user in your organization.
     * @summary List API Keys
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(user: string, options?: any): Promise<ListApiKeysResponse>;
    /**
     * Update the state of an API key for any user in your organization.
     * @summary Update API Key State
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {UpdateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any): Promise<UpdateApiKeyResponse>;
};
/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export declare class APIKeysApi extends BaseAPI {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    createApiKey(body: CreateApiKeyRequest, options?: any): Promise<CreateApiKeyResponse>;
    /**
     * Delete an API key for any user in your organization.
     * @summary Delete API Key
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    deleteApiKey(name: string, user: string, options?: any): Promise<DeleteApiKeyResponse>;
    /**
     * Retrieve a particular API key for any user in your organization.
     * @summary Retrieve API Key
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {string} name Name of the API key.
     * @param {boolean} [reveal] Reveal full key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    getApiKey(user: string, name: string, reveal?: boolean, options?: any): Promise<GetApiKeyResponse>;
    /**
     * List API key metadata for any user in your organization.
     * @summary List API Keys
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    listApiKeys(user: string, options?: any): Promise<ListApiKeysResponse>;
    /**
     * Update the state of an API key for any user in your organization.
     * @summary Update API Key State
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {UpdateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any): Promise<UpdateApiKeyResponse>;
}
/**
 * AliasesApi - fetch parameter creator
 * @export
 */
export declare const AliasesApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create new alias in a workspace.
     * @summary Create Alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(workspace: string, body: CreateAliasRequest, options?: any): FetchArgs;
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(workspace: string, alias: string, options?: any): FetchArgs;
    /**
     * Get details about an alias
     * @summary Retrieve Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(workspace: string, alias: string, options?: any): FetchArgs;
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliases(options?: any): FetchArgs;
    /**
     * Update alias in a workspace.
     * @summary Update Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any): FetchArgs;
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceAliases(workspace: string, options?: any): FetchArgs;
};
/**
 * AliasesApi - functional programming interface
 * @export
 */
export declare const AliasesApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create new alias in a workspace.
     * @summary Create Alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(workspace: string, body: CreateAliasRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateAliasResponse>;
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(workspace: string, alias: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteAliasResponse>;
    /**
     * Get details about an alias
     * @summary Retrieve Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(workspace: string, alias: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetAliasResponse>;
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliases(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListAliasesResponse>;
    /**
     * Update alias in a workspace.
     * @summary Update Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetAliasResponse>;
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceAliases(workspace: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListAliasesResponse>;
};
/**
 * AliasesApi - factory interface
 * @export
 */
export declare const AliasesApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create new alias in a workspace.
     * @summary Create Alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(workspace: string, body: CreateAliasRequest, options?: any): Promise<CreateAliasResponse>;
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(workspace: string, alias: string, options?: any): Promise<DeleteAliasResponse>;
    /**
     * Get details about an alias
     * @summary Retrieve Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(workspace: string, alias: string, options?: any): Promise<GetAliasResponse>;
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliases(options?: any): Promise<ListAliasesResponse>;
    /**
     * Update alias in a workspace.
     * @summary Update Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any): Promise<GetAliasResponse>;
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceAliases(workspace: string, options?: any): Promise<ListAliasesResponse>;
};
/**
 * AliasesApi - object-oriented interface
 * @export
 * @class AliasesApi
 * @extends {BaseAPI}
 */
export declare class AliasesApi extends BaseAPI {
    /**
     * Create new alias in a workspace.
     * @summary Create Alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    createAlias(workspace: string, body: CreateAliasRequest, options?: any): Promise<CreateAliasResponse>;
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    deleteAlias(workspace: string, alias: string, options?: any): Promise<DeleteAliasResponse>;
    /**
     * Get details about an alias
     * @summary Retrieve Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    getAlias(workspace: string, alias: string, options?: any): Promise<GetAliasResponse>;
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    listAliases(options?: any): Promise<ListAliasesResponse>;
    /**
     * Update alias in a workspace.
     * @summary Update Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any): Promise<GetAliasResponse>;
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    workspaceAliases(workspace: string, options?: any): Promise<ListAliasesResponse>;
}
/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export declare const CollectionsApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(workspace: string, body: CreateCollectionRequest, options?: any): FetchArgs;
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(workspace: string, collection: string, options?: any): FetchArgs;
    /**
     * Get details about a collection.
     * @summary Retrieve Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(workspace: string, collection: string, options?: any): FetchArgs;
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(options?: any): FetchArgs;
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceCollections(workspace: string, options?: any): FetchArgs;
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
export declare const CollectionsApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(workspace: string, body: CreateCollectionRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateCollectionResponse>;
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteCollectionResponse>;
    /**
     * Get details about a collection.
     * @summary Retrieve Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetCollectionResponse>;
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListCollectionsResponse>;
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceCollections(workspace: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListCollectionsResponse>;
};
/**
 * CollectionsApi - factory interface
 * @export
 */
export declare const CollectionsApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(workspace: string, body: CreateCollectionRequest, options?: any): Promise<CreateCollectionResponse>;
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(workspace: string, collection: string, options?: any): Promise<DeleteCollectionResponse>;
    /**
     * Get details about a collection.
     * @summary Retrieve Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(workspace: string, collection: string, options?: any): Promise<GetCollectionResponse>;
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(options?: any): Promise<ListCollectionsResponse>;
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceCollections(workspace: string, options?: any): Promise<ListCollectionsResponse>;
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export declare class CollectionsApi extends BaseAPI {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    createCollection(workspace: string, body: CreateCollectionRequest, options?: any): Promise<CreateCollectionResponse>;
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    deleteCollection(workspace: string, collection: string, options?: any): Promise<DeleteCollectionResponse>;
    /**
     * Get details about a collection.
     * @summary Retrieve Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(workspace: string, collection: string, options?: any): Promise<GetCollectionResponse>;
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(options?: any): Promise<ListCollectionsResponse>;
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    workspaceCollections(workspace: string, options?: any): Promise<ListCollectionsResponse>;
}
/**
 * CustomRolesApi - fetch parameter creator
 * @export
 */
export declare const CustomRolesApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create a role for your organization.
     * @summary Create a Role
     * @param {CreateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(body: CreateRoleRequest, options?: any): FetchArgs;
    /**
     * Delete a role for your organization.
     * @summary Delete a Role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(roleName: string, options?: any): FetchArgs;
    /**
     * Retrieve a role by name for your organization.
     * @summary Retrieve role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(roleName: string, options?: any): FetchArgs;
    /**
     * List all roles for your organization.
     * @summary List Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(options?: any): FetchArgs;
    /**
     * Update a role for your organization.
     * @summary Update a Role
     * @param {string} roleName
     * @param {UpdateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(roleName: string, body: UpdateRoleRequest, options?: any): FetchArgs;
};
/**
 * CustomRolesApi - functional programming interface
 * @export
 */
export declare const CustomRolesApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create a role for your organization.
     * @summary Create a Role
     * @param {CreateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(body: CreateRoleRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<RoleResponse>;
    /**
     * Delete a role for your organization.
     * @summary Delete a Role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(roleName: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<RoleResponse>;
    /**
     * Retrieve a role by name for your organization.
     * @summary Retrieve role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(roleName: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<RoleResponse>;
    /**
     * List all roles for your organization.
     * @summary List Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListRolesResponse>;
    /**
     * Update a role for your organization.
     * @summary Update a Role
     * @param {string} roleName
     * @param {UpdateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(roleName: string, body: UpdateRoleRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<RoleResponse>;
};
/**
 * CustomRolesApi - factory interface
 * @export
 */
export declare const CustomRolesApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create a role for your organization.
     * @summary Create a Role
     * @param {CreateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(body: CreateRoleRequest, options?: any): Promise<RoleResponse>;
    /**
     * Delete a role for your organization.
     * @summary Delete a Role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(roleName: string, options?: any): Promise<RoleResponse>;
    /**
     * Retrieve a role by name for your organization.
     * @summary Retrieve role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(roleName: string, options?: any): Promise<RoleResponse>;
    /**
     * List all roles for your organization.
     * @summary List Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(options?: any): Promise<ListRolesResponse>;
    /**
     * Update a role for your organization.
     * @summary Update a Role
     * @param {string} roleName
     * @param {UpdateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(roleName: string, body: UpdateRoleRequest, options?: any): Promise<RoleResponse>;
};
/**
 * CustomRolesApi - object-oriented interface
 * @export
 * @class CustomRolesApi
 * @extends {BaseAPI}
 */
export declare class CustomRolesApi extends BaseAPI {
    /**
     * Create a role for your organization.
     * @summary Create a Role
     * @param {CreateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    createRole(body: CreateRoleRequest, options?: any): Promise<RoleResponse>;
    /**
     * Delete a role for your organization.
     * @summary Delete a Role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    deleteRole(roleName: string, options?: any): Promise<RoleResponse>;
    /**
     * Retrieve a role by name for your organization.
     * @summary Retrieve role
     * @param {string} roleName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    getRole(roleName: string, options?: any): Promise<RoleResponse>;
    /**
     * List all roles for your organization.
     * @summary List Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    listRoles(options?: any): Promise<ListRolesResponse>;
    /**
     * Update a role for your organization.
     * @summary Update a Role
     * @param {string} roleName
     * @param {UpdateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    updateRole(roleName: string, body: UpdateRoleRequest, options?: any): Promise<RoleResponse>;
}
/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export declare const DocumentsApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any): FetchArgs;
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any): FetchArgs;
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any): FetchArgs;
};
/**
 * DocumentsApi - functional programming interface
 * @export
 */
export declare const DocumentsApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<AddDocumentsResponse>;
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteDocumentsResponse>;
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<PatchDocumentsResponse>;
};
/**
 * DocumentsApi - factory interface
 * @export
 */
export declare const DocumentsApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any): Promise<AddDocumentsResponse>;
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any): Promise<DeleteDocumentsResponse>;
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any): Promise<PatchDocumentsResponse>;
};
/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export declare class DocumentsApi extends BaseAPI {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any): Promise<AddDocumentsResponse>;
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any): Promise<DeleteDocumentsResponse>;
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any): Promise<PatchDocumentsResponse>;
}
/**
 * IntegrationsApi - fetch parameter creator
 * @export
 */
export declare const IntegrationsApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIntegration(body: CreateIntegrationRequest, options?: any): FetchArgs;
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIntegration(integration: string, options?: any): FetchArgs;
    /**
     * Retrieve information about a single integration.
     * @summary Retrieve Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIntegration(integration: string, options?: any): FetchArgs;
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIntegrations(options?: any): FetchArgs;
};
/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export declare const IntegrationsApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIntegration(body: CreateIntegrationRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateIntegrationResponse>;
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIntegration(integration: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteIntegrationResponse>;
    /**
     * Retrieve information about a single integration.
     * @summary Retrieve Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIntegration(integration: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetIntegrationResponse>;
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIntegrations(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListIntegrationsResponse>;
};
/**
 * IntegrationsApi - factory interface
 * @export
 */
export declare const IntegrationsApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIntegration(body: CreateIntegrationRequest, options?: any): Promise<CreateIntegrationResponse>;
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIntegration(integration: string, options?: any): Promise<DeleteIntegrationResponse>;
    /**
     * Retrieve information about a single integration.
     * @summary Retrieve Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIntegration(integration: string, options?: any): Promise<GetIntegrationResponse>;
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIntegrations(options?: any): Promise<ListIntegrationsResponse>;
};
/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export declare class IntegrationsApi extends BaseAPI {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    createIntegration(body: CreateIntegrationRequest, options?: any): Promise<CreateIntegrationResponse>;
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    deleteIntegration(integration: string, options?: any): Promise<DeleteIntegrationResponse>;
    /**
     * Retrieve information about a single integration.
     * @summary Retrieve Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    getIntegration(integration: string, options?: any): Promise<GetIntegrationResponse>;
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    listIntegrations(options?: any): Promise<ListIntegrationsResponse>;
}
/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export declare const OrganizationsApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(options?: any): FetchArgs;
};
/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export declare const OrganizationsApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<OrganizationResponse>;
};
/**
 * OrganizationsApi - factory interface
 * @export
 */
export declare const OrganizationsApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(options?: any): Promise<OrganizationResponse>;
};
/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export declare class OrganizationsApi extends BaseAPI {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    getOrganization(options?: any): Promise<OrganizationResponse>;
}
/**
 * QueriesApi - fetch parameter creator
 * @export
 */
export declare const QueriesApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Attempts to cancel an actively-running query.
     * @summary Cancel Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelQuery(queryId: string, options?: any): FetchArgs;
    /**
     * Returns information about a query.
     * @summary Retrieve Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuery(queryId: string, options?: any): FetchArgs;
    /**
     * Returns a page of query results.
     * @summary Retrieve Query Results Page
     * @param {string} queryId
     * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
     * @param {number} [docs] Number of documents to fetch.
     * @param {number} [offset] Offset from the cursor of the first document to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryResults(queryId: string, cursor?: string | undefined, docs?: number | undefined, offset?: number | undefined, options?: any): FetchArgs;
    /**
     * Lists actively queued and running queries.
     * @summary List Queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listActiveQueries(options?: any): FetchArgs;
    /**
     * Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query(body: QueryRequest, options?: any): FetchArgs;
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validate(body: QueryRequest, options?: any): FetchArgs;
};
/**
 * QueriesApi - functional programming interface
 * @export
 */
export declare const QueriesApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Attempts to cancel an actively-running query.
     * @summary Cancel Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelQuery(queryId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CancelQueryResponse>;
    /**
     * Returns information about a query.
     * @summary Retrieve Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuery(queryId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetQueryResponse>;
    /**
     * Returns a page of query results.
     * @summary Retrieve Query Results Page
     * @param {string} queryId
     * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
     * @param {number} [docs] Number of documents to fetch.
     * @param {number} [offset] Offset from the cursor of the first document to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryResults(queryId: string, cursor?: string | undefined, docs?: number | undefined, offset?: number | undefined, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryPaginationResponse>;
    /**
     * Lists actively queued and running queries.
     * @summary List Queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listActiveQueries(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListQueriesResponse>;
    /**
     * Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query(body: QueryRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryResponse>;
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validate(body: QueryRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ValidateQueryResponse>;
};
/**
 * QueriesApi - factory interface
 * @export
 */
export declare const QueriesApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Attempts to cancel an actively-running query.
     * @summary Cancel Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelQuery(queryId: string, options?: any): Promise<CancelQueryResponse>;
    /**
     * Returns information about a query.
     * @summary Retrieve Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuery(queryId: string, options?: any): Promise<GetQueryResponse>;
    /**
     * Returns a page of query results.
     * @summary Retrieve Query Results Page
     * @param {string} queryId
     * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
     * @param {number} [docs] Number of documents to fetch.
     * @param {number} [offset] Offset from the cursor of the first document to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryResults(queryId: string, cursor?: string | undefined, docs?: number | undefined, offset?: number | undefined, options?: any): Promise<QueryPaginationResponse>;
    /**
     * Lists actively queued and running queries.
     * @summary List Queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listActiveQueries(options?: any): Promise<ListQueriesResponse>;
    /**
     * Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query(body: QueryRequest, options?: any): Promise<QueryResponse>;
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validate(body: QueryRequest, options?: any): Promise<ValidateQueryResponse>;
};
/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export declare class QueriesApi extends BaseAPI {
    /**
     * Attempts to cancel an actively-running query.
     * @summary Cancel Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    cancelQuery(queryId: string, options?: any): Promise<CancelQueryResponse>;
    /**
     * Returns information about a query.
     * @summary Retrieve Query
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    getQuery(queryId: string, options?: any): Promise<GetQueryResponse>;
    /**
     * Returns a page of query results.
     * @summary Retrieve Query Results Page
     * @param {string} queryId
     * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
     * @param {number} [docs] Number of documents to fetch.
     * @param {number} [offset] Offset from the cursor of the first document to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    getQueryResults(queryId: string, cursor?: string, docs?: number, offset?: number, options?: any): Promise<QueryPaginationResponse>;
    /**
     * Lists actively queued and running queries.
     * @summary List Queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    listActiveQueries(options?: any): Promise<ListQueriesResponse>;
    /**
     * Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    query(body: QueryRequest, options?: any): Promise<QueryResponse>;
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    validate(body: QueryRequest, options?: any): Promise<ValidateQueryResponse>;
}
/**
 * QueryLambdasApi - fetch parameter creator
 * @export
 */
export declare const QueryLambdasApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any): FetchArgs;
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any): FetchArgs;
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambda(workspace: string, queryLambda: string, options?: any): FetchArgs;
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any): FetchArgs;
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): FetchArgs;
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda By Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest | undefined, options?: any): FetchArgs;
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest | undefined, options?: any): FetchArgs;
    /**
     * Retrieve the Query Lambda version associated with a given tag.
     * @summary Retrieve Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any): FetchArgs;
    /**
     * Retrieve details for a specified version of a Query Lambda.
     * @summary Retrieve Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): FetchArgs;
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllQueryLambdas(options?: any): FetchArgs;
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTags(workspace: string, queryLambda: string, options?: any): FetchArgs;
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any): FetchArgs;
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInWorkspace(workspace: string, options?: any): FetchArgs;
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean | undefined, options?: any): FetchArgs;
};
/**
 * QueryLambdasApi - functional programming interface
 * @export
 */
export declare const QueryLambdasApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryLambdaVersionResponse>;
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryLambdaTagResponse>;
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambda(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteQueryLambdaResponse>;
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryLambdaTagResponse>;
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryLambdaVersionResponse>;
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda By Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest | undefined, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryResponse>;
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest | undefined, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryResponse>;
    /**
     * Retrieve the Query Lambda version associated with a given tag.
     * @summary Retrieve Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryLambdaTagResponse>;
    /**
     * Retrieve details for a specified version of a Query Lambda.
     * @summary Retrieve Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryLambdaVersionResponse>;
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllQueryLambdas(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListQueryLambdasResponse>;
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTags(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListQueryLambdaTagsResponse>;
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListQueryLambdaVersionsResponse>;
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInWorkspace(workspace: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListQueryLambdasResponse>;
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean | undefined, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryLambdaVersionResponse>;
};
/**
 * QueryLambdasApi - factory interface
 * @export
 */
export declare const QueryLambdasApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any): Promise<QueryLambdaVersionResponse>;
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any): Promise<QueryLambdaTagResponse>;
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambda(workspace: string, queryLambda: string, options?: any): Promise<DeleteQueryLambdaResponse>;
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any): Promise<QueryLambdaTagResponse>;
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): Promise<QueryLambdaVersionResponse>;
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda By Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest | undefined, options?: any): Promise<QueryResponse>;
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest | undefined, options?: any): Promise<QueryResponse>;
    /**
     * Retrieve the Query Lambda version associated with a given tag.
     * @summary Retrieve Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any): Promise<QueryLambdaTagResponse>;
    /**
     * Retrieve details for a specified version of a Query Lambda.
     * @summary Retrieve Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): Promise<QueryLambdaVersionResponse>;
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllQueryLambdas(options?: any): Promise<ListQueryLambdasResponse>;
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTags(workspace: string, queryLambda: string, options?: any): Promise<ListQueryLambdaTagsResponse>;
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any): Promise<ListQueryLambdaVersionsResponse>;
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInWorkspace(workspace: string, options?: any): Promise<ListQueryLambdasResponse>;
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean | undefined, options?: any): Promise<QueryLambdaVersionResponse>;
};
/**
 * QueryLambdasApi - object-oriented interface
 * @export
 * @class QueryLambdasApi
 * @extends {BaseAPI}
 */
export declare class QueryLambdasApi extends BaseAPI {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any): Promise<QueryLambdaVersionResponse>;
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any): Promise<QueryLambdaTagResponse>;
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    deleteQueryLambda(workspace: string, queryLambda: string, options?: any): Promise<DeleteQueryLambdaResponse>;
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any): Promise<QueryLambdaTagResponse>;
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): Promise<QueryLambdaVersionResponse>;
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda By Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any): Promise<QueryResponse>;
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any): Promise<QueryResponse>;
    /**
     * Retrieve the Query Lambda version associated with a given tag.
     * @summary Retrieve Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any): Promise<QueryLambdaTagResponse>;
    /**
     * Retrieve details for a specified version of a Query Lambda.
     * @summary Retrieve Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): Promise<QueryLambdaVersionResponse>;
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    listAllQueryLambdas(options?: any): Promise<ListQueryLambdasResponse>;
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    listQueryLambdaTags(workspace: string, queryLambda: string, options?: any): Promise<ListQueryLambdaTagsResponse>;
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any): Promise<ListQueryLambdaVersionsResponse>;
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    listQueryLambdasInWorkspace(workspace: string, options?: any): Promise<ListQueryLambdasResponse>;
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any): Promise<QueryLambdaVersionResponse>;
}
/**
 * SharedLambdasApi - fetch parameter creator
 * @export
 */
export declare const SharedLambdasApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Execute a public query lambda (full version).
     * @summary Execute a Public Query Lambda
     * @param {string} public_access_id public access ID of the query lambda
     * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest | undefined, options?: any): FetchArgs;
};
/**
 * SharedLambdasApi - functional programming interface
 * @export
 */
export declare const SharedLambdasApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Execute a public query lambda (full version).
     * @summary Execute a Public Query Lambda
     * @param {string} public_access_id public access ID of the query lambda
     * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest | undefined, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryResponse>;
};
/**
 * SharedLambdasApi - factory interface
 * @export
 */
export declare const SharedLambdasApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Execute a public query lambda (full version).
     * @summary Execute a Public Query Lambda
     * @param {string} public_access_id public access ID of the query lambda
     * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest | undefined, options?: any): Promise<QueryResponse>;
};
/**
 * SharedLambdasApi - object-oriented interface
 * @export
 * @class SharedLambdasApi
 * @extends {BaseAPI}
 */
export declare class SharedLambdasApi extends BaseAPI {
    /**
     * Execute a public query lambda (full version).
     * @summary Execute a Public Query Lambda
     * @param {string} public_access_id public access ID of the query lambda
     * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLambdasApi
     */
    executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest, options?: any): Promise<QueryResponse>;
}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export declare const UsersApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: CreateUserRequest, options?: any): FetchArgs;
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(user: string, options?: any): FetchArgs;
    /**
     * Retrieve currently authenticated user.
     * @summary Retrieve Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): FetchArgs;
    /**
     * Retrieve user by email.
     * @summary Retrieve User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(user: string, options?: any): FetchArgs;
    /**
     * Get all notification preferences.
     * @summary Retrieve Notification Preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUnsubscribePreferences(options?: any): FetchArgs;
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(options?: any): FetchArgs;
    /**
     * Update notification preference.
     * @summary Update Notification Preferences
     * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any): FetchArgs;
    /**
     * Update a user in an organization.
     * @summary Update User
     * @param {string} user email of the user to update
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(user: string, body: UpdateUserRequest, options?: any): FetchArgs;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export declare const UsersApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: CreateUserRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateUserResponse>;
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(user: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteUserResponse>;
    /**
     * Retrieve currently authenticated user.
     * @summary Retrieve Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<User>;
    /**
     * Retrieve user by email.
     * @summary Retrieve User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(user: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<User>;
    /**
     * Get all notification preferences.
     * @summary Retrieve Notification Preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUnsubscribePreferences(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListUnsubscribePreferencesResponse>;
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListUsersResponse>;
    /**
     * Update notification preference.
     * @summary Update Notification Preferences
     * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<UpdateUnsubscribePreferencesResponse>;
    /**
     * Update a user in an organization.
     * @summary Update User
     * @param {string} user email of the user to update
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(user: string, body: UpdateUserRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<User>;
};
/**
 * UsersApi - factory interface
 * @export
 */
export declare const UsersApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: CreateUserRequest, options?: any): Promise<CreateUserResponse>;
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(user: string, options?: any): Promise<DeleteUserResponse>;
    /**
     * Retrieve currently authenticated user.
     * @summary Retrieve Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): Promise<User>;
    /**
     * Retrieve user by email.
     * @summary Retrieve User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(user: string, options?: any): Promise<User>;
    /**
     * Get all notification preferences.
     * @summary Retrieve Notification Preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUnsubscribePreferences(options?: any): Promise<ListUnsubscribePreferencesResponse>;
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(options?: any): Promise<ListUsersResponse>;
    /**
     * Update notification preference.
     * @summary Update Notification Preferences
     * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any): Promise<UpdateUnsubscribePreferencesResponse>;
    /**
     * Update a user in an organization.
     * @summary Update User
     * @param {string} user email of the user to update
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(user: string, body: UpdateUserRequest, options?: any): Promise<User>;
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export declare class UsersApi extends BaseAPI {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    createUser(body: CreateUserRequest, options?: any): Promise<CreateUserResponse>;
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUser(user: string, options?: any): Promise<DeleteUserResponse>;
    /**
     * Retrieve currently authenticated user.
     * @summary Retrieve Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getCurrentUser(options?: any): Promise<User>;
    /**
     * Retrieve user by email.
     * @summary Retrieve User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUser(user: string, options?: any): Promise<User>;
    /**
     * Get all notification preferences.
     * @summary Retrieve Notification Preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    listUnsubscribePreferences(options?: any): Promise<ListUnsubscribePreferencesResponse>;
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    listUsers(options?: any): Promise<ListUsersResponse>;
    /**
     * Update notification preference.
     * @summary Update Notification Preferences
     * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any): Promise<UpdateUnsubscribePreferencesResponse>;
    /**
     * Update a user in an organization.
     * @summary Update User
     * @param {string} user email of the user to update
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUser(user: string, body: UpdateUserRequest, options?: any): Promise<User>;
}
/**
 * ViewsApi - fetch parameter creator
 * @export
 */
export declare const ViewsApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create a view
     * @summary Create View
     * @param {string} workspace name of the workspace
     * @param {CreateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createView(workspace: string, body: CreateViewRequest, options?: any): FetchArgs;
    /**
     * Delete a view
     * @summary Delete View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteView(workspace: string, view: string, options?: any): FetchArgs;
    /**
     * Get details about a view
     * @summary Retrieve View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getView(workspace: string, view: string, options?: any): FetchArgs;
    /**
     * Retrieve all views in an organization
     * @summary List Views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listViews(options?: any): FetchArgs;
    /**
     * Update a view
     * @summary Update View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {UpdateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any): FetchArgs;
    /**
     * Retrieve all views in a workspace.
     * @summary List Views in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceViews(workspace: string, options?: any): FetchArgs;
};
/**
 * ViewsApi - functional programming interface
 * @export
 */
export declare const ViewsApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create a view
     * @summary Create View
     * @param {string} workspace name of the workspace
     * @param {CreateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createView(workspace: string, body: CreateViewRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateViewResponse>;
    /**
     * Delete a view
     * @summary Delete View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteView(workspace: string, view: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteViewResponse>;
    /**
     * Get details about a view
     * @summary Retrieve View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getView(workspace: string, view: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetViewResponse>;
    /**
     * Retrieve all views in an organization
     * @summary List Views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listViews(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListViewsResponse>;
    /**
     * Update a view
     * @summary Update View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {UpdateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<UpdateViewResponse>;
    /**
     * Retrieve all views in a workspace.
     * @summary List Views in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceViews(workspace: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListViewsResponse>;
};
/**
 * ViewsApi - factory interface
 * @export
 */
export declare const ViewsApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create a view
     * @summary Create View
     * @param {string} workspace name of the workspace
     * @param {CreateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createView(workspace: string, body: CreateViewRequest, options?: any): Promise<CreateViewResponse>;
    /**
     * Delete a view
     * @summary Delete View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteView(workspace: string, view: string, options?: any): Promise<DeleteViewResponse>;
    /**
     * Get details about a view
     * @summary Retrieve View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getView(workspace: string, view: string, options?: any): Promise<GetViewResponse>;
    /**
     * Retrieve all views in an organization
     * @summary List Views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listViews(options?: any): Promise<ListViewsResponse>;
    /**
     * Update a view
     * @summary Update View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {UpdateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any): Promise<UpdateViewResponse>;
    /**
     * Retrieve all views in a workspace.
     * @summary List Views in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceViews(workspace: string, options?: any): Promise<ListViewsResponse>;
};
/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export declare class ViewsApi extends BaseAPI {
    /**
     * Create a view
     * @summary Create View
     * @param {string} workspace name of the workspace
     * @param {CreateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    createView(workspace: string, body: CreateViewRequest, options?: any): Promise<CreateViewResponse>;
    /**
     * Delete a view
     * @summary Delete View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    deleteView(workspace: string, view: string, options?: any): Promise<DeleteViewResponse>;
    /**
     * Get details about a view
     * @summary Retrieve View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    getView(workspace: string, view: string, options?: any): Promise<GetViewResponse>;
    /**
     * Retrieve all views in an organization
     * @summary List Views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    listViews(options?: any): Promise<ListViewsResponse>;
    /**
     * Update a view
     * @summary Update View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {UpdateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any): Promise<UpdateViewResponse>;
    /**
     * Retrieve all views in a workspace.
     * @summary List Views in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    workspaceViews(workspace: string, options?: any): Promise<ListViewsResponse>;
}
/**
 * VirtualInstancesApi - fetch parameter creator
 * @export
 */
export declare const VirtualInstancesApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * [beta] Create virtual instance
     * @summary Create Virtual Instance
     * @param {CreateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualInstance(body: CreateVirtualInstanceRequest, options?: any): FetchArgs;
    /**
     * [beta] Delete a virtual instance.
     * @summary Delete Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualInstance(virtualInstanceId: string, options?: any): FetchArgs;
    /**
     * [beta] Get a mount on this virtual instance.
     * @summary Get Collection Mount
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionMount(virtualInstanceId: string, collectionPath: string, options?: any): FetchArgs;
    /**
     * Get details about a virtual instance.
     * @summary Retrieve Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstance(virtualInstanceId: string, options?: any): FetchArgs;
    /**
     * [beta] Lists actively queued and running queries for a particular Virtual Instance.
     * @summary List Queries
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstanceQueries(virtualInstanceId: string, options?: any): FetchArgs;
    /**
     * [beta] List collection mounts for a particular VI.
     * @summary List Collection Mounts
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionMounts(virtualInstanceId: string, options?: any): FetchArgs;
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualInstances(options?: any): FetchArgs;
    /**
     * [beta] Mount a collection to this virtual instance.
     * @summary Mount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {CreateCollectionMountRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options?: any): FetchArgs;
    /**
     * [beta] Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options?: any): FetchArgs;
    /**
     * [beta] Resume a virtual instance.
     * @summary Resume Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resumeVirtualInstance(virtualInstanceId: string, options?: any): FetchArgs;
    /**
     * Update the properties of a virtual instance.
     * @summary Update Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {UpdateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any): FetchArgs;
    /**
     * [beta] Suspend a virtual instance.
     * @summary Suspend Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendVirtualInstance(virtualInstanceId: string, options?: any): FetchArgs;
    /**
     * [beta] Unmount a collection from this virtual instance.
     * @summary Unmount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unmountCollection(virtualInstanceId: string, collectionPath: string, options?: any): FetchArgs;
};
/**
 * VirtualInstancesApi - functional programming interface
 * @export
 */
export declare const VirtualInstancesApiFp: (configuration?: Configuration | undefined) => {
    /**
     * [beta] Create virtual instance
     * @summary Create Virtual Instance
     * @param {CreateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualInstance(body: CreateVirtualInstanceRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateVirtualInstanceResponse>;
    /**
     * [beta] Delete a virtual instance.
     * @summary Delete Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteVirtualInstanceResponse>;
    /**
     * [beta] Get a mount on this virtual instance.
     * @summary Get Collection Mount
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionMount(virtualInstanceId: string, collectionPath: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CollectionMountResponse>;
    /**
     * Get details about a virtual instance.
     * @summary Retrieve Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetVirtualInstanceResponse>;
    /**
     * [beta] Lists actively queued and running queries for a particular Virtual Instance.
     * @summary List Queries
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstanceQueries(virtualInstanceId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListQueriesResponse>;
    /**
     * [beta] List collection mounts for a particular VI.
     * @summary List Collection Mounts
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionMounts(virtualInstanceId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListCollectionMountsResponse>;
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualInstances(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListVirtualInstancesResponse>;
    /**
     * [beta] Mount a collection to this virtual instance.
     * @summary Mount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {CreateCollectionMountRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateCollectionMountsResponse>;
    /**
     * [beta] Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<QueryResponse>;
    /**
     * [beta] Resume a virtual instance.
     * @summary Resume Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resumeVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ResumeVirtualInstanceResponse>;
    /**
     * Update the properties of a virtual instance.
     * @summary Update Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {UpdateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<UpdateVirtualInstanceResponse>;
    /**
     * [beta] Suspend a virtual instance.
     * @summary Suspend Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<SuspendVirtualInstanceResponse>;
    /**
     * [beta] Unmount a collection from this virtual instance.
     * @summary Unmount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unmountCollection(virtualInstanceId: string, collectionPath: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CollectionMountResponse>;
};
/**
 * VirtualInstancesApi - factory interface
 * @export
 */
export declare const VirtualInstancesApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * [beta] Create virtual instance
     * @summary Create Virtual Instance
     * @param {CreateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualInstance(body: CreateVirtualInstanceRequest, options?: any): Promise<CreateVirtualInstanceResponse>;
    /**
     * [beta] Delete a virtual instance.
     * @summary Delete Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualInstance(virtualInstanceId: string, options?: any): Promise<DeleteVirtualInstanceResponse>;
    /**
     * [beta] Get a mount on this virtual instance.
     * @summary Get Collection Mount
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionMount(virtualInstanceId: string, collectionPath: string, options?: any): Promise<CollectionMountResponse>;
    /**
     * Get details about a virtual instance.
     * @summary Retrieve Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstance(virtualInstanceId: string, options?: any): Promise<GetVirtualInstanceResponse>;
    /**
     * [beta] Lists actively queued and running queries for a particular Virtual Instance.
     * @summary List Queries
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstanceQueries(virtualInstanceId: string, options?: any): Promise<ListQueriesResponse>;
    /**
     * [beta] List collection mounts for a particular VI.
     * @summary List Collection Mounts
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollectionMounts(virtualInstanceId: string, options?: any): Promise<ListCollectionMountsResponse>;
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualInstances(options?: any): Promise<ListVirtualInstancesResponse>;
    /**
     * [beta] Mount a collection to this virtual instance.
     * @summary Mount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {CreateCollectionMountRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options?: any): Promise<CreateCollectionMountsResponse>;
    /**
     * [beta] Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options?: any): Promise<QueryResponse>;
    /**
     * [beta] Resume a virtual instance.
     * @summary Resume Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resumeVirtualInstance(virtualInstanceId: string, options?: any): Promise<ResumeVirtualInstanceResponse>;
    /**
     * Update the properties of a virtual instance.
     * @summary Update Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {UpdateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any): Promise<UpdateVirtualInstanceResponse>;
    /**
     * [beta] Suspend a virtual instance.
     * @summary Suspend Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suspendVirtualInstance(virtualInstanceId: string, options?: any): Promise<SuspendVirtualInstanceResponse>;
    /**
     * [beta] Unmount a collection from this virtual instance.
     * @summary Unmount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unmountCollection(virtualInstanceId: string, collectionPath: string, options?: any): Promise<CollectionMountResponse>;
};
/**
 * VirtualInstancesApi - object-oriented interface
 * @export
 * @class VirtualInstancesApi
 * @extends {BaseAPI}
 */
export declare class VirtualInstancesApi extends BaseAPI {
    /**
     * [beta] Create virtual instance
     * @summary Create Virtual Instance
     * @param {CreateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    createVirtualInstance(body: CreateVirtualInstanceRequest, options?: any): Promise<CreateVirtualInstanceResponse>;
    /**
     * [beta] Delete a virtual instance.
     * @summary Delete Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    deleteVirtualInstance(virtualInstanceId: string, options?: any): Promise<DeleteVirtualInstanceResponse>;
    /**
     * [beta] Get a mount on this virtual instance.
     * @summary Get Collection Mount
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    getCollectionMount(virtualInstanceId: string, collectionPath: string, options?: any): Promise<CollectionMountResponse>;
    /**
     * Get details about a virtual instance.
     * @summary Retrieve Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    getVirtualInstance(virtualInstanceId: string, options?: any): Promise<GetVirtualInstanceResponse>;
    /**
     * [beta] Lists actively queued and running queries for a particular Virtual Instance.
     * @summary List Queries
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    getVirtualInstanceQueries(virtualInstanceId: string, options?: any): Promise<ListQueriesResponse>;
    /**
     * [beta] List collection mounts for a particular VI.
     * @summary List Collection Mounts
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    listCollectionMounts(virtualInstanceId: string, options?: any): Promise<ListCollectionMountsResponse>;
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    listVirtualInstances(options?: any): Promise<ListVirtualInstancesResponse>;
    /**
     * [beta] Mount a collection to this virtual instance.
     * @summary Mount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {CreateCollectionMountRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options?: any): Promise<CreateCollectionMountsResponse>;
    /**
     * [beta] Make a SQL query to Rockset.
     * @summary Execute SQL Query
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options?: any): Promise<QueryResponse>;
    /**
     * [beta] Resume a virtual instance.
     * @summary Resume Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    resumeVirtualInstance(virtualInstanceId: string, options?: any): Promise<ResumeVirtualInstanceResponse>;
    /**
     * Update the properties of a virtual instance.
     * @summary Update Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {UpdateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any): Promise<UpdateVirtualInstanceResponse>;
    /**
     * [beta] Suspend a virtual instance.
     * @summary Suspend Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    suspendVirtualInstance(virtualInstanceId: string, options?: any): Promise<SuspendVirtualInstanceResponse>;
    /**
     * [beta] Unmount a collection from this virtual instance.
     * @summary Unmount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    unmountCollection(virtualInstanceId: string, collectionPath: string, options?: any): Promise<CollectionMountResponse>;
}
/**
 * WorkspacesApi - fetch parameter creator
 * @export
 */
export declare const WorkspacesApiFetchParamCreator: (configuration?: Configuration | undefined) => {
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(body: CreateWorkspaceRequest, options?: any): FetchArgs;
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(workspace: string, options?: any): FetchArgs;
    /**
     * Get information about a single workspace.
     * @summary Retrieve Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace(workspace: string, options?: any): FetchArgs;
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces(options?: any): FetchArgs;
};
/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export declare const WorkspacesApiFp: (configuration?: Configuration | undefined) => {
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(body: CreateWorkspaceRequest, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<CreateWorkspaceResponse>;
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(workspace: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<DeleteWorkspaceResponse>;
    /**
     * Get information about a single workspace.
     * @summary Retrieve Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace(workspace: string, options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<GetWorkspaceResponse>;
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces(options?: any): (fetch?: FetchAPI | undefined, basePath?: string | undefined) => Promise<ListWorkspacesResponse>;
};
/**
 * WorkspacesApi - factory interface
 * @export
 */
export declare const WorkspacesApiFactory: (configuration?: Configuration | undefined, fetch?: FetchAPI | undefined, basePath?: string | undefined) => {
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(body: CreateWorkspaceRequest, options?: any): Promise<CreateWorkspaceResponse>;
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(workspace: string, options?: any): Promise<DeleteWorkspaceResponse>;
    /**
     * Get information about a single workspace.
     * @summary Retrieve Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace(workspace: string, options?: any): Promise<GetWorkspaceResponse>;
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces(options?: any): Promise<ListWorkspacesResponse>;
};
/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export declare class WorkspacesApi extends BaseAPI {
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    createWorkspace(body: CreateWorkspaceRequest, options?: any): Promise<CreateWorkspaceResponse>;
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    deleteWorkspace(workspace: string, options?: any): Promise<DeleteWorkspaceResponse>;
    /**
     * Get information about a single workspace.
     * @summary Retrieve Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    getWorkspace(workspace: string, options?: any): Promise<GetWorkspaceResponse>;
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    listWorkspaces(options?: any): Promise<ListWorkspacesResponse>;
}
