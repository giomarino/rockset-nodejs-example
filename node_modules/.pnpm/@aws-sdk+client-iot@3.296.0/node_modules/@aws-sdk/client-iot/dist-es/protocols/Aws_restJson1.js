import { HttpRequest as __HttpRequest } from "@aws-sdk/protocol-http";
import { decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, expectUnion as __expectUnion, limitedParseDouble as __limitedParseDouble, map as __map, parseEpochTimestamp as __parseEpochTimestamp, resolvedPath as __resolvedPath, serializeFloat as __serializeFloat, throwDefaultError, } from "@aws-sdk/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { IoTServiceException as __BaseException } from "../models/IoTServiceException";
import { AssetPropertyVariant, CertificateStateException, CertificateValidationException, ConflictException, ConflictingResourceUpdateException, DeleteConflictException, IndexNotReadyException, InternalException, InternalFailureException, InvalidAggregationException, InvalidQueryException, InvalidRequestException, InvalidStateTransitionException, LimitExceededException, MalformedPolicyException, ResourceAlreadyExistsException, ResourceNotFoundException, ServiceUnavailableException, SqlParseException, ThrottlingException, TransferAlreadyCompletedException, UnauthorizedException, VersionConflictException, VersionsLimitExceededException, } from "../models/models_0";
import { InternalServerException, NotConfiguredException, } from "../models/models_1";
import { CertificateConflictException, InvalidResponseException, RegistrationCodeValidationException, ResourceRegistrationFailureException, TaskAlreadyExistsException, TransferConflictException, } from "../models/models_2";
export const serializeAws_restJson1AcceptCertificateTransferCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/accept-certificate-transfer/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1AddThingToBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/addThingToBillingGroup";
    let body;
    body = JSON.stringify({
        ...(input.billingGroupArn != null && { billingGroupArn: input.billingGroupArn }),
        ...(input.billingGroupName != null && { billingGroupName: input.billingGroupName }),
        ...(input.thingArn != null && { thingArn: input.thingArn }),
        ...(input.thingName != null && { thingName: input.thingName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1AddThingToThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/addThingToThingGroup";
    let body;
    body = JSON.stringify({
        ...(input.overrideDynamicGroups != null && { overrideDynamicGroups: input.overrideDynamicGroups }),
        ...(input.thingArn != null && { thingArn: input.thingArn }),
        ...(input.thingGroupArn != null && { thingGroupArn: input.thingGroupArn }),
        ...(input.thingGroupName != null && { thingGroupName: input.thingGroupName }),
        ...(input.thingName != null && { thingName: input.thingName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1AssociateTargetsWithJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/targets";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        namespaceId: [, input.namespaceId],
    });
    let body;
    body = JSON.stringify({
        ...(input.comment != null && { comment: input.comment }),
        ...(input.targets != null && { targets: serializeAws_restJson1JobTargets(input.targets, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1AttachPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/target-policies/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify({
        ...(input.target != null && { target: input.target }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1AttachPrincipalPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-iot-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1AttachSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/security-profiles/{securityProfileName}/targets";
    resolvedPath = __resolvedPath(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        securityProfileTargetArn: [, __expectNonNull(input.securityProfileTargetArn, `securityProfileTargetArn`)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1AttachThingPrincipalCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CancelAuditMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/mitigationactions/tasks/{taskId}/cancel";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CancelAuditTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks/{taskId}/cancel";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CancelCertificateTransferCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/cancel-certificate-transfer/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CancelDetectMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/detect/mitigationactions/tasks/{taskId}/cancel";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CancelJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/cancel";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        force: [() => input.force !== void 0, () => input.force.toString()],
    });
    let body;
    body = JSON.stringify({
        ...(input.comment != null && { comment: input.comment }),
        ...(input.reasonCode != null && { reasonCode: input.reasonCode }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1CancelJobExecutionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs/{jobId}/cancel";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        force: [() => input.force !== void 0, () => input.force.toString()],
    });
    let body;
    body = JSON.stringify({
        ...(input.expectedVersion != null && { expectedVersion: input.expectedVersion }),
        ...(input.statusDetails != null && {
            statusDetails: serializeAws_restJson1DetailsMap(input.statusDetails, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ClearDefaultAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ConfirmTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/confirmdestination/{confirmationToken+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "confirmationToken", () => input.confirmationToken, "{confirmationToken+}", true);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/create";
    let body;
    body = JSON.stringify({
        ...(input.checkName != null && { checkName: input.checkName }),
        clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
        ...(input.description != null && { description: input.description }),
        ...(input.expirationDate != null && { expirationDate: Math.round(input.expirationDate.getTime() / 1000) }),
        ...(input.resourceIdentifier != null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
        ...(input.suppressIndefinitely != null && { suppressIndefinitely: input.suppressIndefinitely }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify({
        ...(input.authorizerFunctionArn != null && { authorizerFunctionArn: input.authorizerFunctionArn }),
        ...(input.enableCachingForHttp != null && { enableCachingForHttp: input.enableCachingForHttp }),
        ...(input.signingDisabled != null && { signingDisabled: input.signingDisabled }),
        ...(input.status != null && { status: input.status }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.tokenKeyName != null && { tokenKeyName: input.tokenKeyName }),
        ...(input.tokenSigningPublicKeys != null && {
            tokenSigningPublicKeys: serializeAws_restJson1PublicKeyMap(input.tokenSigningPublicKeys, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    body = JSON.stringify({
        ...(input.billingGroupProperties != null && {
            billingGroupProperties: serializeAws_restJson1BillingGroupProperties(input.billingGroupProperties, context),
        }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateCertificateFromCsrCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates";
    const query = map({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    body = JSON.stringify({
        ...(input.certificateSigningRequest != null && { certificateSigningRequest: input.certificateSigningRequest }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1CreateCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify({
        clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
        ...(input.displayName != null && { displayName: input.displayName }),
        ...(input.metricType != null && { metricType: input.metricType }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    body = JSON.stringify({
        clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
        ...(input.stringValues != null && {
            stringValues: serializeAws_restJson1DimensionStringValues(input.stringValues, context),
        }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.type != null && { type: input.type }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    body = JSON.stringify({
        ...(input.authorizerConfig != null && {
            authorizerConfig: serializeAws_restJson1AuthorizerConfig(input.authorizerConfig, context),
        }),
        ...(input.domainName != null && { domainName: input.domainName }),
        ...(input.serverCertificateArns != null && {
            serverCertificateArns: serializeAws_restJson1ServerCertificateArns(input.serverCertificateArns, context),
        }),
        ...(input.serviceType != null && { serviceType: input.serviceType }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.validationCertificateArn != null && { validationCertificateArn: input.validationCertificateArn }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateDynamicThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify({
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.thingGroupProperties != null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify({
        ...(input.aggregationField != null && { aggregationField: input.aggregationField }),
        ...(input.aggregationType != null && {
            aggregationType: serializeAws_restJson1AggregationType(input.aggregationType, context),
        }),
        ...(input.description != null && { description: input.description }),
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.period != null && { period: input.period }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.unit != null && { unit: input.unit }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    let body;
    body = JSON.stringify({
        ...(input.abortConfig != null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
        ...(input.description != null && { description: input.description }),
        ...(input.document != null && { document: input.document }),
        ...(input.documentParameters != null && {
            documentParameters: serializeAws_restJson1ParameterMap(input.documentParameters, context),
        }),
        ...(input.documentSource != null && { documentSource: input.documentSource }),
        ...(input.jobExecutionsRetryConfig != null && {
            jobExecutionsRetryConfig: serializeAws_restJson1JobExecutionsRetryConfig(input.jobExecutionsRetryConfig, context),
        }),
        ...(input.jobExecutionsRolloutConfig != null && {
            jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(input.jobExecutionsRolloutConfig, context),
        }),
        ...(input.jobTemplateArn != null && { jobTemplateArn: input.jobTemplateArn }),
        ...(input.namespaceId != null && { namespaceId: input.namespaceId }),
        ...(input.presignedUrlConfig != null && {
            presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
        }),
        ...(input.schedulingConfig != null && {
            schedulingConfig: serializeAws_restJson1SchedulingConfig(input.schedulingConfig, context),
        }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.targetSelection != null && { targetSelection: input.targetSelection }),
        ...(input.targets != null && { targets: serializeAws_restJson1JobTargets(input.targets, context) }),
        ...(input.timeoutConfig != null && {
            timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    body = JSON.stringify({
        ...(input.abortConfig != null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
        ...(input.description != null && { description: input.description }),
        ...(input.document != null && { document: input.document }),
        ...(input.documentSource != null && { documentSource: input.documentSource }),
        ...(input.jobArn != null && { jobArn: input.jobArn }),
        ...(input.jobExecutionsRetryConfig != null && {
            jobExecutionsRetryConfig: serializeAws_restJson1JobExecutionsRetryConfig(input.jobExecutionsRetryConfig, context),
        }),
        ...(input.jobExecutionsRolloutConfig != null && {
            jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(input.jobExecutionsRolloutConfig, context),
        }),
        ...(input.maintenanceWindows != null && {
            maintenanceWindows: serializeAws_restJson1MaintenanceWindows(input.maintenanceWindows, context),
        }),
        ...(input.presignedUrlConfig != null && {
            presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
        }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.timeoutConfig != null && {
            timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateKeysAndCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/keys-and-certificate";
    const query = map({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1CreateMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    body = JSON.stringify({
        ...(input.actionParams != null && {
            actionParams: serializeAws_restJson1MitigationActionParams(input.actionParams, context),
        }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateOTAUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    let body;
    body = JSON.stringify({
        ...(input.additionalParameters != null && {
            additionalParameters: serializeAws_restJson1AdditionalParameterMap(input.additionalParameters, context),
        }),
        ...(input.awsJobAbortConfig != null && {
            awsJobAbortConfig: serializeAws_restJson1AwsJobAbortConfig(input.awsJobAbortConfig, context),
        }),
        ...(input.awsJobExecutionsRolloutConfig != null && {
            awsJobExecutionsRolloutConfig: serializeAws_restJson1AwsJobExecutionsRolloutConfig(input.awsJobExecutionsRolloutConfig, context),
        }),
        ...(input.awsJobPresignedUrlConfig != null && {
            awsJobPresignedUrlConfig: serializeAws_restJson1AwsJobPresignedUrlConfig(input.awsJobPresignedUrlConfig, context),
        }),
        ...(input.awsJobTimeoutConfig != null && {
            awsJobTimeoutConfig: serializeAws_restJson1AwsJobTimeoutConfig(input.awsJobTimeoutConfig, context),
        }),
        ...(input.description != null && { description: input.description }),
        ...(input.files != null && { files: serializeAws_restJson1OTAUpdateFiles(input.files, context) }),
        ...(input.protocols != null && { protocols: serializeAws_restJson1Protocols(input.protocols, context) }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.targetSelection != null && { targetSelection: input.targetSelection }),
        ...(input.targets != null && { targets: serializeAws_restJson1Targets(input.targets, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreatePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify({
        ...(input.policyDocument != null && { policyDocument: input.policyDocument }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreatePolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}/version";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    const query = map({
        setAsDefault: [() => input.setAsDefault !== void 0, () => input.setAsDefault.toString()],
    });
    let body;
    body = JSON.stringify({
        ...(input.policyDocument != null && { policyDocument: input.policyDocument }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1CreateProvisioningClaimCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/provisioning-claim";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates";
    let body;
    body = JSON.stringify({
        ...(input.description != null && { description: input.description }),
        ...(input.enabled != null && { enabled: input.enabled }),
        ...(input.preProvisioningHook != null && {
            preProvisioningHook: serializeAws_restJson1ProvisioningHook(input.preProvisioningHook, context),
        }),
        ...(input.provisioningRoleArn != null && { provisioningRoleArn: input.provisioningRoleArn }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.templateBody != null && { templateBody: input.templateBody }),
        ...(input.templateName != null && { templateName: input.templateName }),
        ...(input.type != null && { type: input.type }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateProvisioningTemplateVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    const query = map({
        setAsDefault: [() => input.setAsDefault !== void 0, () => input.setAsDefault.toString()],
    });
    let body;
    body = JSON.stringify({
        ...(input.templateBody != null && { templateBody: input.templateBody }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1CreateRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = __resolvedPath(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    body = JSON.stringify({
        ...(input.credentialDurationSeconds != null && { credentialDurationSeconds: input.credentialDurationSeconds }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    body = JSON.stringify({
        ...(input.dayOfMonth != null && { dayOfMonth: input.dayOfMonth }),
        ...(input.dayOfWeek != null && { dayOfWeek: input.dayOfWeek }),
        ...(input.frequency != null && { frequency: input.frequency }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.targetCheckNames != null && {
            targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    let body;
    body = JSON.stringify({
        ...(input.additionalMetricsToRetain != null && {
            additionalMetricsToRetain: serializeAws_restJson1AdditionalMetricsToRetainList(input.additionalMetricsToRetain, context),
        }),
        ...(input.additionalMetricsToRetainV2 != null && {
            additionalMetricsToRetainV2: serializeAws_restJson1AdditionalMetricsToRetainV2List(input.additionalMetricsToRetainV2, context),
        }),
        ...(input.alertTargets != null && {
            alertTargets: serializeAws_restJson1AlertTargets(input.alertTargets, context),
        }),
        ...(input.behaviors != null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
        ...(input.securityProfileDescription != null && { securityProfileDescription: input.securityProfileDescription }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    body = JSON.stringify({
        ...(input.description != null && { description: input.description }),
        ...(input.files != null && { files: serializeAws_restJson1StreamFiles(input.files, context) }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    body = JSON.stringify({
        ...(input.attributePayload != null && {
            attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
        }),
        ...(input.billingGroupName != null && { billingGroupName: input.billingGroupName }),
        ...(input.thingTypeName != null && { thingTypeName: input.thingTypeName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify({
        ...(input.parentGroupName != null && { parentGroupName: input.parentGroupName }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.thingGroupProperties != null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    body = JSON.stringify({
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.thingTypeProperties != null && {
            thingTypeProperties: serializeAws_restJson1ThingTypeProperties(input.thingTypeProperties, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        "x-amz-tagging": input.tags,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    if (input.topicRulePayload !== undefined) {
        body = serializeAws_restJson1TopicRulePayload(input.topicRulePayload, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
    let body;
    body = JSON.stringify({
        ...(input.destinationConfiguration != null && {
            destinationConfiguration: serializeAws_restJson1TopicRuleDestinationConfiguration(input.destinationConfiguration, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteAccountAuditConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
    const query = map({
        deleteScheduledAudits: [
            () => input.deleteScheduledAudits !== void 0,
            () => input.deleteScheduledAudits.toString(),
        ],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/delete";
    let body;
    body = JSON.stringify({
        ...(input.checkName != null && { checkName: input.checkName }),
        ...(input.resourceIdentifier != null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    const query = map({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        forceDelete: [() => input.forceDelete !== void 0, () => input.forceDelete.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteDynamicThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = map({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    const query = map({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        force: [() => input.force !== void 0, () => input.force.toString()],
        namespaceId: [, input.namespaceId],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteJobExecutionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "executionNumber", () => input.executionNumber.toString(), "{executionNumber}", false);
    const query = map({
        force: [() => input.force !== void 0, () => input.force.toString()],
        namespaceId: [, input.namespaceId],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteOTAUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    const query = map({
        deleteStream: [() => input.deleteStream !== void 0, () => input.deleteStream.toString()],
        forceDeleteAWSJob: [() => input.forceDeleteAWSJob !== void 0, () => input.forceDeleteAWSJob.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeletePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeletePolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/policies/{policyName}/version/{policyVersionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteProvisioningTemplateVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions/{versionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "versionId", () => input.versionId.toString(), "{versionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteRegistrationCodeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/registrationcode";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = __resolvedPath(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = map({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeleteThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations/{arn+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "arn", () => input.arn, "{arn+}", true);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteV2LoggingLevelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
    const query = map({
        targetType: [, __expectNonNull(input.targetType, `targetType`)],
        targetName: [, __expectNonNull(input.targetName, `targetName`)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DeprecateThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}/deprecate";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    body = JSON.stringify({
        ...(input.undoDeprecate != null && { undoDeprecate: input.undoDeprecate }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeAccountAuditConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeAuditFindingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/findings/{findingId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "findingId", () => input.findingId, "{findingId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks/{taskId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/describe";
    let body;
    body = JSON.stringify({
        ...(input.checkName != null && { checkName: input.checkName }),
        ...(input.resourceIdentifier != null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeAuditTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks/{taskId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeDefaultAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeDetectMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks/{taskId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeEndpointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/endpoint";
    const query = map({
        endpointType: [, input.endpointType],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DescribeEventConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/event-configurations";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeIndexCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/{indexName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "indexName", () => input.indexName, "{indexName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeJobExecutionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs/{jobId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        executionNumber: [() => input.executionNumber !== void 0, () => input.executionNumber.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DescribeJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeManagedJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/managed-job-templates/{templateName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    const query = map({
        templateVersion: [, input.templateVersion],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DescribeMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeProvisioningTemplateVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions/{versionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "versionId", () => input.versionId.toString(), "{versionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = __resolvedPath(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeThingRegistrationTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks/{taskId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DetachPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/target-policies/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify({
        ...(input.target != null && { target: input.target }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DetachPrincipalPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-iot-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DetachSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/security-profiles/{securityProfileName}/targets";
    resolvedPath = __resolvedPath(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        securityProfileTargetArn: [, __expectNonNull(input.securityProfileTargetArn, `securityProfileTargetArn`)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DetachThingPrincipalCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DisableTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}/disable";
    resolvedPath = __resolvedPath(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1EnableTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}/enable";
    resolvedPath = __resolvedPath(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetBehaviorModelTrainingSummariesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/behavior-model-training/summaries";
    const query = map({
        securityProfileName: [, input.securityProfileName],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1GetBucketsAggregationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/buckets";
    let body;
    body = JSON.stringify({
        ...(input.aggregationField != null && { aggregationField: input.aggregationField }),
        ...(input.bucketsAggregationType != null && {
            bucketsAggregationType: serializeAws_restJson1BucketsAggregationType(input.bucketsAggregationType, context),
        }),
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetCardinalityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/cardinality";
    let body;
    body = JSON.stringify({
        ...(input.aggregationField != null && { aggregationField: input.aggregationField }),
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetEffectivePoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/effective-policies";
    const query = map({
        thingName: [, input.thingName],
    });
    let body;
    body = JSON.stringify({
        ...(input.cognitoIdentityPoolId != null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
        ...(input.principal != null && { principal: input.principal }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1GetIndexingConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indexing/config";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetJobDocumentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/job-document";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetLoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/loggingOptions";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetOTAUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetPercentilesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/percentiles";
    let body;
    body = JSON.stringify({
        ...(input.aggregationField != null && { aggregationField: input.aggregationField }),
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.percents != null && { percents: serializeAws_restJson1PercentList(input.percents, context) }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetPolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/policies/{policyName}/version/{policyVersionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetRegistrationCodeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/registrationcode";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetStatisticsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/statistics";
    let body;
    body = JSON.stringify({
        ...(input.aggregationField != null && { aggregationField: input.aggregationField }),
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations/{arn+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "arn", () => input.arn, "{arn+}", true);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetV2LoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingOptions";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ListActiveViolationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/active-violations";
    const query = map({
        thingName: [, input.thingName],
        securityProfileName: [, input.securityProfileName],
        behaviorCriteriaType: [, input.behaviorCriteriaType],
        listSuppressedAlerts: [() => input.listSuppressedAlerts !== void 0, () => input.listSuppressedAlerts.toString()],
        verificationState: [, input.verificationState],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListAttachedPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/attached-policies/{target}";
    resolvedPath = __resolvedPath(resolvedPath, input, "target", () => input.target, "{target}", false);
    const query = map({
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListAuditFindingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/findings";
    let body;
    body = JSON.stringify({
        ...(input.checkName != null && { checkName: input.checkName }),
        ...(input.endTime != null && { endTime: Math.round(input.endTime.getTime() / 1000) }),
        ...(input.listSuppressedFindings != null && { listSuppressedFindings: input.listSuppressedFindings }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.resourceIdentifier != null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
        ...(input.startTime != null && { startTime: Math.round(input.startTime.getTime() / 1000) }),
        ...(input.taskId != null && { taskId: input.taskId }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/executions";
    const query = map({
        taskId: [, __expectNonNull(input.taskId, `taskId`)],
        actionStatus: [, input.actionStatus],
        findingId: [, __expectNonNull(input.findingId, `findingId`)],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListAuditMitigationActionsTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks";
    const query = map({
        auditTaskId: [, input.auditTaskId],
        findingId: [, input.findingId],
        taskStatus: [, input.taskStatus],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        startTime: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListAuditSuppressionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/list";
    let body;
    body = JSON.stringify({
        ...(input.ascendingOrder != null && { ascendingOrder: input.ascendingOrder }),
        ...(input.checkName != null && { checkName: input.checkName }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.resourceIdentifier != null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ListAuditTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks";
    const query = map({
        startTime: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        taskType: [, input.taskType],
        taskStatus: [, input.taskStatus],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListAuthorizersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizers";
    const query = map({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
        status: [, input.status],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListBillingGroupsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        namePrefixFilter: [, input.namePrefixFilter],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListCACertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificates";
    const query = map({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
        templateName: [, input.templateName],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListCertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates";
    const query = map({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListCertificatesByCACommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates-by-ca/{caCertificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "caCertificateId", () => input.caCertificateId, "{caCertificateId}", false);
    const query = map({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListCustomMetricsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metrics";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListDetectMitigationActionsExecutionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/executions";
    const query = map({
        taskId: [, input.taskId],
        violationId: [, input.violationId],
        thingName: [, input.thingName],
        startTime: [
            () => input.startTime !== void 0,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [() => input.endTime !== void 0, () => (input.endTime.toISOString().split(".")[0] + "Z").toString()],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListDetectMitigationActionsTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks";
    const query = map({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        startTime: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListDimensionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListDomainConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainConfigurations";
    const query = map({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        serviceType: [, input.serviceType],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListFleetMetricsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metrics";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListIndicesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListJobExecutionsForJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/things";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        status: [, input.status],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListJobExecutionsForThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        status: [, input.status],
        namespaceId: [, input.namespaceId],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        jobId: [, input.jobId],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListJobsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs";
    const query = map({
        status: [, input.status],
        targetSelection: [, input.targetSelection],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        thingGroupName: [, input.thingGroupName],
        thingGroupId: [, input.thingGroupId],
        namespaceId: [, input.namespaceId],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListJobTemplatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates";
    const query = map({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListManagedJobTemplatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/managed-job-templates";
    const query = map({
        templateName: [, input.templateName],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListMetricValuesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/metric-values";
    const query = map({
        thingName: [, __expectNonNull(input.thingName, `thingName`)],
        metricName: [, __expectNonNull(input.metricName, `metricName`)],
        dimensionName: [, input.dimensionName],
        dimensionValueOperator: [, input.dimensionValueOperator],
        startTime: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListMitigationActionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions";
    const query = map({
        actionType: [, input.actionType],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListOTAUpdatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates";
    const query = map({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        otaUpdateStatus: [, input.otaUpdateStatus],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListOutgoingCertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates-out-going";
    const query = map({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies";
    const query = map({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListPolicyPrincipalsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-iot-policy": input.policyName,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policy-principals";
    const query = map({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListPolicyVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}/version";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ListPrincipalPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-iot-principal": input.principal,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies";
    const query = map({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListPrincipalThingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amzn-principal": input.principal,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principals/things";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListProvisioningTemplatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates";
    const query = map({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListProvisioningTemplateVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    const query = map({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListRelatedResourcesForAuditFindingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/relatedResources";
    const query = map({
        findingId: [, __expectNonNull(input.findingId, `findingId`)],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListRoleAliasesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases";
    const query = map({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListScheduledAuditsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/scheduledaudits";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListSecurityProfilesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        dimensionName: [, input.dimensionName],
        metricName: [, input.metricName],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListSecurityProfilesForTargetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles-for-target";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
        securityProfileTargetArn: [, __expectNonNull(input.securityProfileTargetArn, `securityProfileTargetArn`)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListStreamsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams";
    const query = map({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
    const query = map({
        resourceArn: [, __expectNonNull(input.resourceArn, `resourceArn`)],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListTargetsForPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policy-targets/{policyName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    const query = map({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListTargetsForSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/security-profiles/{securityProfileName}/targets";
    resolvedPath = __resolvedPath(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingGroupsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        parentGroup: [, input.parentGroup],
        namePrefixFilter: [, input.namePrefixFilter],
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingGroupsForThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/thing-groups";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingPrincipalsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingRegistrationTaskReportsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/thing-registration-tasks/{taskId}/reports";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    const query = map({
        reportType: [, __expectNonNull(input.reportType, `reportType`)],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingRegistrationTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        status: [, input.status],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        attributeName: [, input.attributeName],
        attributeValue: [, input.attributeValue],
        thingTypeName: [, input.thingTypeName],
        usePrefixAttributeValue: [
            () => input.usePrefixAttributeValue !== void 0,
            () => input.usePrefixAttributeValue.toString(),
        ],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingsInBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}/things";
    resolvedPath = __resolvedPath(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingsInThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}/things";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = map({
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListThingTypesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types";
    const query = map({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        thingTypeName: [, input.thingTypeName],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListTopicRuleDestinationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
    const query = map({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListTopicRulesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules";
    const query = map({
        topic: [, input.topic],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        ruleDisabled: [() => input.ruleDisabled !== void 0, () => input.ruleDisabled.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListV2LoggingLevelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
    const query = map({
        targetType: [, input.targetType],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListViolationEventsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/violation-events";
    const query = map({
        startTime: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        thingName: [, input.thingName],
        securityProfileName: [, input.securityProfileName],
        behaviorCriteriaType: [, input.behaviorCriteriaType],
        listSuppressedAlerts: [() => input.listSuppressedAlerts !== void 0, () => input.listSuppressedAlerts.toString()],
        verificationState: [, input.verificationState],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1PutVerificationStateOnViolationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/violations/verification-state/{violationId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "violationId", () => input.violationId, "{violationId}", false);
    let body;
    body = JSON.stringify({
        ...(input.verificationState != null && { verificationState: input.verificationState }),
        ...(input.verificationStateDescription != null && {
            verificationStateDescription: input.verificationStateDescription,
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RegisterCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate";
    const query = map({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
        allowAutoRegistration: [
            () => input.allowAutoRegistration !== void 0,
            () => input.allowAutoRegistration.toString(),
        ],
    });
    let body;
    body = JSON.stringify({
        ...(input.caCertificate != null && { caCertificate: input.caCertificate }),
        ...(input.certificateMode != null && { certificateMode: input.certificateMode }),
        ...(input.registrationConfig != null && {
            registrationConfig: serializeAws_restJson1RegistrationConfig(input.registrationConfig, context),
        }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.verificationCertificate != null && { verificationCertificate: input.verificationCertificate }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1RegisterCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificate/register";
    const query = map({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    body = JSON.stringify({
        ...(input.caCertificatePem != null && { caCertificatePem: input.caCertificatePem }),
        ...(input.certificatePem != null && { certificatePem: input.certificatePem }),
        ...(input.status != null && { status: input.status }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1RegisterCertificateWithoutCACommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificate/register-no-ca";
    let body;
    body = JSON.stringify({
        ...(input.certificatePem != null && { certificatePem: input.certificatePem }),
        ...(input.status != null && { status: input.status }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RegisterThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things";
    let body;
    body = JSON.stringify({
        ...(input.parameters != null && { parameters: serializeAws_restJson1Parameters(input.parameters, context) }),
        ...(input.templateBody != null && { templateBody: input.templateBody }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RejectCertificateTransferCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/reject-certificate-transfer/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    body = JSON.stringify({
        ...(input.rejectReason != null && { rejectReason: input.rejectReason }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RemoveThingFromBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/billing-groups/removeThingFromBillingGroup";
    let body;
    body = JSON.stringify({
        ...(input.billingGroupArn != null && { billingGroupArn: input.billingGroupArn }),
        ...(input.billingGroupName != null && { billingGroupName: input.billingGroupName }),
        ...(input.thingArn != null && { thingArn: input.thingArn }),
        ...(input.thingName != null && { thingName: input.thingName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RemoveThingFromThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/removeThingFromThingGroup";
    let body;
    body = JSON.stringify({
        ...(input.thingArn != null && { thingArn: input.thingArn }),
        ...(input.thingGroupArn != null && { thingGroupArn: input.thingGroupArn }),
        ...(input.thingGroupName != null && { thingGroupName: input.thingGroupName }),
        ...(input.thingName != null && { thingName: input.thingName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ReplaceTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    if (input.topicRulePayload !== undefined) {
        body = serializeAws_restJson1TopicRulePayload(input.topicRulePayload, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1SearchIndexCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/search";
    let body;
    body = JSON.stringify({
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1SetDefaultAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
    let body;
    body = JSON.stringify({
        ...(input.authorizerName != null && { authorizerName: input.authorizerName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1SetDefaultPolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/policies/{policyName}/version/{policyVersionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1SetLoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/loggingOptions";
    let body;
    if (input.loggingOptionsPayload !== undefined) {
        body = serializeAws_restJson1LoggingOptionsPayload(input.loggingOptionsPayload, context);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1SetV2LoggingLevelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
    let body;
    body = JSON.stringify({
        ...(input.logLevel != null && { logLevel: input.logLevel }),
        ...(input.logTarget != null && { logTarget: serializeAws_restJson1LogTarget(input.logTarget, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1SetV2LoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingOptions";
    let body;
    body = JSON.stringify({
        ...(input.defaultLogLevel != null && { defaultLogLevel: input.defaultLogLevel }),
        ...(input.disableAllLogs != null && { disableAllLogs: input.disableAllLogs }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1StartAuditMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks/{taskId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    body = JSON.stringify({
        ...(input.auditCheckToActionsMapping != null && {
            auditCheckToActionsMapping: serializeAws_restJson1AuditCheckToActionsMapping(input.auditCheckToActionsMapping, context),
        }),
        clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
        ...(input.target != null && {
            target: serializeAws_restJson1AuditMitigationActionsTaskTarget(input.target, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1StartDetectMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks/{taskId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    body = JSON.stringify({
        ...(input.actions != null && {
            actions: serializeAws_restJson1DetectMitigationActionsToExecuteList(input.actions, context),
        }),
        clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
        ...(input.includeOnlyActiveViolations != null && {
            includeOnlyActiveViolations: input.includeOnlyActiveViolations,
        }),
        ...(input.includeSuppressedAlerts != null && { includeSuppressedAlerts: input.includeSuppressedAlerts }),
        ...(input.target != null && {
            target: serializeAws_restJson1DetectMitigationActionsTaskTarget(input.target, context),
        }),
        ...(input.violationEventOccurrenceRange != null && {
            violationEventOccurrenceRange: serializeAws_restJson1ViolationEventOccurrenceRange(input.violationEventOccurrenceRange, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1StartOnDemandAuditTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks";
    let body;
    body = JSON.stringify({
        ...(input.targetCheckNames != null && {
            targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1StartThingRegistrationTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks";
    let body;
    body = JSON.stringify({
        ...(input.inputFileBucket != null && { inputFileBucket: input.inputFileBucket }),
        ...(input.inputFileKey != null && { inputFileKey: input.inputFileKey }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.templateBody != null && { templateBody: input.templateBody }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1StopThingRegistrationTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks/{taskId}/cancel";
    resolvedPath = __resolvedPath(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
    let body;
    body = JSON.stringify({
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1TestAuthorizationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/test-authorization";
    const query = map({
        clientId: [, input.clientId],
    });
    let body;
    body = JSON.stringify({
        ...(input.authInfos != null && { authInfos: serializeAws_restJson1AuthInfos(input.authInfos, context) }),
        ...(input.cognitoIdentityPoolId != null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
        ...(input.policyNamesToAdd != null && {
            policyNamesToAdd: serializeAws_restJson1PolicyNames(input.policyNamesToAdd, context),
        }),
        ...(input.policyNamesToSkip != null && {
            policyNamesToSkip: serializeAws_restJson1PolicyNames(input.policyNamesToSkip, context),
        }),
        ...(input.principal != null && { principal: input.principal }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1TestInvokeAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}/test";
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify({
        ...(input.httpContext != null && { httpContext: serializeAws_restJson1HttpContext(input.httpContext, context) }),
        ...(input.mqttContext != null && { mqttContext: serializeAws_restJson1MqttContext(input.mqttContext, context) }),
        ...(input.tlsContext != null && { tlsContext: serializeAws_restJson1TlsContext(input.tlsContext, context) }),
        ...(input.token != null && { token: input.token }),
        ...(input.tokenSignature != null && { tokenSignature: input.tokenSignature }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1TransferCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/transfer-certificate/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        targetAwsAccount: [, __expectNonNull(input.targetAwsAccount, `targetAwsAccount`)],
    });
    let body;
    body = JSON.stringify({
        ...(input.transferMessage != null && { transferMessage: input.transferMessage }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/untag";
    let body;
    body = JSON.stringify({
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
        ...(input.tagKeys != null && { tagKeys: serializeAws_restJson1TagKeyList(input.tagKeys, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateAccountAuditConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
    let body;
    body = JSON.stringify({
        ...(input.auditCheckConfigurations != null && {
            auditCheckConfigurations: serializeAws_restJson1AuditCheckConfigurations(input.auditCheckConfigurations, context),
        }),
        ...(input.auditNotificationTargetConfigurations != null && {
            auditNotificationTargetConfigurations: serializeAws_restJson1AuditNotificationTargetConfigurations(input.auditNotificationTargetConfigurations, context),
        }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/update";
    let body;
    body = JSON.stringify({
        ...(input.checkName != null && { checkName: input.checkName }),
        ...(input.description != null && { description: input.description }),
        ...(input.expirationDate != null && { expirationDate: Math.round(input.expirationDate.getTime() / 1000) }),
        ...(input.resourceIdentifier != null && {
            resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
        }),
        ...(input.suppressIndefinitely != null && { suppressIndefinitely: input.suppressIndefinitely }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify({
        ...(input.authorizerFunctionArn != null && { authorizerFunctionArn: input.authorizerFunctionArn }),
        ...(input.enableCachingForHttp != null && { enableCachingForHttp: input.enableCachingForHttp }),
        ...(input.status != null && { status: input.status }),
        ...(input.tokenKeyName != null && { tokenKeyName: input.tokenKeyName }),
        ...(input.tokenSigningPublicKeys != null && {
            tokenSigningPublicKeys: serializeAws_restJson1PublicKeyMap(input.tokenSigningPublicKeys, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    body = JSON.stringify({
        ...(input.billingGroupProperties != null && {
            billingGroupProperties: serializeAws_restJson1BillingGroupProperties(input.billingGroupProperties, context),
        }),
        ...(input.expectedVersion != null && { expectedVersion: input.expectedVersion }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        newStatus: [, input.newStatus],
        newAutoRegistrationStatus: [, input.newAutoRegistrationStatus],
    });
    let body;
    body = JSON.stringify({
        ...(input.registrationConfig != null && {
            registrationConfig: serializeAws_restJson1RegistrationConfig(input.registrationConfig, context),
        }),
        ...(input.removeAutoRegistration != null && { removeAutoRegistration: input.removeAutoRegistration }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1UpdateCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        newStatus: [, __expectNonNull(input.newStatus, `newStatus`)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1UpdateCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify({
        ...(input.displayName != null && { displayName: input.displayName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    body = JSON.stringify({
        ...(input.stringValues != null && {
            stringValues: serializeAws_restJson1DimensionStringValues(input.stringValues, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    body = JSON.stringify({
        ...(input.authorizerConfig != null && {
            authorizerConfig: serializeAws_restJson1AuthorizerConfig(input.authorizerConfig, context),
        }),
        ...(input.domainConfigurationStatus != null && { domainConfigurationStatus: input.domainConfigurationStatus }),
        ...(input.removeAuthorizerConfig != null && { removeAuthorizerConfig: input.removeAuthorizerConfig }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateDynamicThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify({
        ...(input.expectedVersion != null && { expectedVersion: input.expectedVersion }),
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
        ...(input.thingGroupProperties != null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateEventConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/event-configurations";
    let body;
    body = JSON.stringify({
        ...(input.eventConfigurations != null && {
            eventConfigurations: serializeAws_restJson1EventConfigurations(input.eventConfigurations, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify({
        ...(input.aggregationField != null && { aggregationField: input.aggregationField }),
        ...(input.aggregationType != null && {
            aggregationType: serializeAws_restJson1AggregationType(input.aggregationType, context),
        }),
        ...(input.description != null && { description: input.description }),
        ...(input.expectedVersion != null && { expectedVersion: input.expectedVersion }),
        ...(input.indexName != null && { indexName: input.indexName }),
        ...(input.period != null && { period: input.period }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.queryVersion != null && { queryVersion: input.queryVersion }),
        ...(input.unit != null && { unit: input.unit }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateIndexingConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indexing/config";
    let body;
    body = JSON.stringify({
        ...(input.thingGroupIndexingConfiguration != null && {
            thingGroupIndexingConfiguration: serializeAws_restJson1ThingGroupIndexingConfiguration(input.thingGroupIndexingConfiguration, context),
        }),
        ...(input.thingIndexingConfiguration != null && {
            thingIndexingConfiguration: serializeAws_restJson1ThingIndexingConfiguration(input.thingIndexingConfiguration, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        namespaceId: [, input.namespaceId],
    });
    let body;
    body = JSON.stringify({
        ...(input.abortConfig != null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
        ...(input.description != null && { description: input.description }),
        ...(input.jobExecutionsRetryConfig != null && {
            jobExecutionsRetryConfig: serializeAws_restJson1JobExecutionsRetryConfig(input.jobExecutionsRetryConfig, context),
        }),
        ...(input.jobExecutionsRolloutConfig != null && {
            jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(input.jobExecutionsRolloutConfig, context),
        }),
        ...(input.presignedUrlConfig != null && {
            presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
        }),
        ...(input.timeoutConfig != null && {
            timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1UpdateMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    body = JSON.stringify({
        ...(input.actionParams != null && {
            actionParams: serializeAws_restJson1MitigationActionParams(input.actionParams, context),
        }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    body = JSON.stringify({
        ...(input.defaultVersionId != null && { defaultVersionId: input.defaultVersionId }),
        ...(input.description != null && { description: input.description }),
        ...(input.enabled != null && { enabled: input.enabled }),
        ...(input.preProvisioningHook != null && {
            preProvisioningHook: serializeAws_restJson1ProvisioningHook(input.preProvisioningHook, context),
        }),
        ...(input.provisioningRoleArn != null && { provisioningRoleArn: input.provisioningRoleArn }),
        ...(input.removePreProvisioningHook != null && { removePreProvisioningHook: input.removePreProvisioningHook }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = __resolvedPath(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    body = JSON.stringify({
        ...(input.credentialDurationSeconds != null && { credentialDurationSeconds: input.credentialDurationSeconds }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    body = JSON.stringify({
        ...(input.dayOfMonth != null && { dayOfMonth: input.dayOfMonth }),
        ...(input.dayOfWeek != null && { dayOfWeek: input.dayOfWeek }),
        ...(input.frequency != null && { frequency: input.frequency }),
        ...(input.targetCheckNames != null && {
            targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    body = JSON.stringify({
        ...(input.additionalMetricsToRetain != null && {
            additionalMetricsToRetain: serializeAws_restJson1AdditionalMetricsToRetainList(input.additionalMetricsToRetain, context),
        }),
        ...(input.additionalMetricsToRetainV2 != null && {
            additionalMetricsToRetainV2: serializeAws_restJson1AdditionalMetricsToRetainV2List(input.additionalMetricsToRetainV2, context),
        }),
        ...(input.alertTargets != null && {
            alertTargets: serializeAws_restJson1AlertTargets(input.alertTargets, context),
        }),
        ...(input.behaviors != null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
        ...(input.deleteAdditionalMetricsToRetain != null && {
            deleteAdditionalMetricsToRetain: input.deleteAdditionalMetricsToRetain,
        }),
        ...(input.deleteAlertTargets != null && { deleteAlertTargets: input.deleteAlertTargets }),
        ...(input.deleteBehaviors != null && { deleteBehaviors: input.deleteBehaviors }),
        ...(input.securityProfileDescription != null && { securityProfileDescription: input.securityProfileDescription }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1UpdateStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    body = JSON.stringify({
        ...(input.description != null && { description: input.description }),
        ...(input.files != null && { files: serializeAws_restJson1StreamFiles(input.files, context) }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    body = JSON.stringify({
        ...(input.attributePayload != null && {
            attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
        }),
        ...(input.expectedVersion != null && { expectedVersion: input.expectedVersion }),
        ...(input.removeThingType != null && { removeThingType: input.removeThingType }),
        ...(input.thingTypeName != null && { thingTypeName: input.thingTypeName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify({
        ...(input.expectedVersion != null && { expectedVersion: input.expectedVersion }),
        ...(input.thingGroupProperties != null && {
            thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateThingGroupsForThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/updateThingGroupsForThing";
    let body;
    body = JSON.stringify({
        ...(input.overrideDynamicGroups != null && { overrideDynamicGroups: input.overrideDynamicGroups }),
        ...(input.thingGroupsToAdd != null && {
            thingGroupsToAdd: serializeAws_restJson1ThingGroupList(input.thingGroupsToAdd, context),
        }),
        ...(input.thingGroupsToRemove != null && {
            thingGroupsToRemove: serializeAws_restJson1ThingGroupList(input.thingGroupsToRemove, context),
        }),
        ...(input.thingName != null && { thingName: input.thingName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
    let body;
    body = JSON.stringify({
        ...(input.arn != null && { arn: input.arn }),
        ...(input.status != null && { status: input.status }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profile-behaviors/validate";
    let body;
    body = JSON.stringify({
        ...(input.behaviors != null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const deserializeAws_restJson1AcceptCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AcceptCertificateTransferCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AcceptCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AddThingToBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AddThingToBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AddThingToBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AddThingToThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AddThingToThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AddThingToThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AssociateTargetsWithJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AssociateTargetsWithJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.jobArn != null) {
        contents.jobArn = __expectString(data.jobArn);
    }
    if (data.jobId != null) {
        contents.jobId = __expectString(data.jobId);
    }
    return contents;
};
const deserializeAws_restJson1AssociateTargetsWithJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AttachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AttachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AttachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachPrincipalPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AttachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AttachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AttachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AttachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AttachThingPrincipalCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AttachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CancelAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1CancelAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CancelAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelAuditTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1CancelAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CancelCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelCertificateTransferCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1CancelCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CancelDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1CancelDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CancelJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.jobArn != null) {
        contents.jobArn = __expectString(data.jobArn);
    }
    if (data.jobId != null) {
        contents.jobId = __expectString(data.jobId);
    }
    return contents;
};
const deserializeAws_restJson1CancelJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CancelJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelJobExecutionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1CancelJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ClearDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ClearDefaultAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1ClearDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ConfirmTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ConfirmTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1ConfirmTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1CreateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authorizerArn != null) {
        contents.authorizerArn = __expectString(data.authorizerArn);
    }
    if (data.authorizerName != null) {
        contents.authorizerName = __expectString(data.authorizerName);
    }
    return contents;
};
const deserializeAws_restJson1CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.billingGroupArn != null) {
        contents.billingGroupArn = __expectString(data.billingGroupArn);
    }
    if (data.billingGroupId != null) {
        contents.billingGroupId = __expectString(data.billingGroupId);
    }
    if (data.billingGroupName != null) {
        contents.billingGroupName = __expectString(data.billingGroupName);
    }
    return contents;
};
const deserializeAws_restJson1CreateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateCertificateFromCsrCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateCertificateFromCsrCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateArn != null) {
        contents.certificateArn = __expectString(data.certificateArn);
    }
    if (data.certificateId != null) {
        contents.certificateId = __expectString(data.certificateId);
    }
    if (data.certificatePem != null) {
        contents.certificatePem = __expectString(data.certificatePem);
    }
    return contents;
};
const deserializeAws_restJson1CreateCertificateFromCsrCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.metricArn != null) {
        contents.metricArn = __expectString(data.metricArn);
    }
    if (data.metricName != null) {
        contents.metricName = __expectString(data.metricName);
    }
    return contents;
};
const deserializeAws_restJson1CreateCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.arn != null) {
        contents.arn = __expectString(data.arn);
    }
    if (data.name != null) {
        contents.name = __expectString(data.name);
    }
    return contents;
};
const deserializeAws_restJson1CreateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.domainConfigurationArn != null) {
        contents.domainConfigurationArn = __expectString(data.domainConfigurationArn);
    }
    if (data.domainConfigurationName != null) {
        contents.domainConfigurationName = __expectString(data.domainConfigurationName);
    }
    return contents;
};
const deserializeAws_restJson1CreateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateDynamicThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.indexName != null) {
        contents.indexName = __expectString(data.indexName);
    }
    if (data.queryString != null) {
        contents.queryString = __expectString(data.queryString);
    }
    if (data.queryVersion != null) {
        contents.queryVersion = __expectString(data.queryVersion);
    }
    if (data.thingGroupArn != null) {
        contents.thingGroupArn = __expectString(data.thingGroupArn);
    }
    if (data.thingGroupId != null) {
        contents.thingGroupId = __expectString(data.thingGroupId);
    }
    if (data.thingGroupName != null) {
        contents.thingGroupName = __expectString(data.thingGroupName);
    }
    return contents;
};
const deserializeAws_restJson1CreateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.metricArn != null) {
        contents.metricArn = __expectString(data.metricArn);
    }
    if (data.metricName != null) {
        contents.metricName = __expectString(data.metricName);
    }
    return contents;
};
const deserializeAws_restJson1CreateFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.jobArn != null) {
        contents.jobArn = __expectString(data.jobArn);
    }
    if (data.jobId != null) {
        contents.jobId = __expectString(data.jobId);
    }
    return contents;
};
const deserializeAws_restJson1CreateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.jobTemplateArn != null) {
        contents.jobTemplateArn = __expectString(data.jobTemplateArn);
    }
    if (data.jobTemplateId != null) {
        contents.jobTemplateId = __expectString(data.jobTemplateId);
    }
    return contents;
};
const deserializeAws_restJson1CreateJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateKeysAndCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateKeysAndCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateArn != null) {
        contents.certificateArn = __expectString(data.certificateArn);
    }
    if (data.certificateId != null) {
        contents.certificateId = __expectString(data.certificateId);
    }
    if (data.certificatePem != null) {
        contents.certificatePem = __expectString(data.certificatePem);
    }
    if (data.keyPair != null) {
        contents.keyPair = deserializeAws_restJson1KeyPair(data.keyPair, context);
    }
    return contents;
};
const deserializeAws_restJson1CreateKeysAndCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.actionArn != null) {
        contents.actionArn = __expectString(data.actionArn);
    }
    if (data.actionId != null) {
        contents.actionId = __expectString(data.actionId);
    }
    return contents;
};
const deserializeAws_restJson1CreateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateOTAUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.awsIotJobArn != null) {
        contents.awsIotJobArn = __expectString(data.awsIotJobArn);
    }
    if (data.awsIotJobId != null) {
        contents.awsIotJobId = __expectString(data.awsIotJobId);
    }
    if (data.otaUpdateArn != null) {
        contents.otaUpdateArn = __expectString(data.otaUpdateArn);
    }
    if (data.otaUpdateId != null) {
        contents.otaUpdateId = __expectString(data.otaUpdateId);
    }
    if (data.otaUpdateStatus != null) {
        contents.otaUpdateStatus = __expectString(data.otaUpdateStatus);
    }
    return contents;
};
const deserializeAws_restJson1CreateOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreatePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreatePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.policyArn != null) {
        contents.policyArn = __expectString(data.policyArn);
    }
    if (data.policyDocument != null) {
        contents.policyDocument = __expectString(data.policyDocument);
    }
    if (data.policyName != null) {
        contents.policyName = __expectString(data.policyName);
    }
    if (data.policyVersionId != null) {
        contents.policyVersionId = __expectString(data.policyVersionId);
    }
    return contents;
};
const deserializeAws_restJson1CreatePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            throw await deserializeAws_restJson1MalformedPolicyExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreatePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreatePolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.isDefaultVersion != null) {
        contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
    }
    if (data.policyArn != null) {
        contents.policyArn = __expectString(data.policyArn);
    }
    if (data.policyDocument != null) {
        contents.policyDocument = __expectString(data.policyDocument);
    }
    if (data.policyVersionId != null) {
        contents.policyVersionId = __expectString(data.policyVersionId);
    }
    return contents;
};
const deserializeAws_restJson1CreatePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            throw await deserializeAws_restJson1MalformedPolicyExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            throw await deserializeAws_restJson1VersionsLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateProvisioningClaimCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateProvisioningClaimCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateId != null) {
        contents.certificateId = __expectString(data.certificateId);
    }
    if (data.certificatePem != null) {
        contents.certificatePem = __expectString(data.certificatePem);
    }
    if (data.expiration != null) {
        contents.expiration = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.expiration)));
    }
    if (data.keyPair != null) {
        contents.keyPair = deserializeAws_restJson1KeyPair(data.keyPair, context);
    }
    return contents;
};
const deserializeAws_restJson1CreateProvisioningClaimCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.defaultVersionId != null) {
        contents.defaultVersionId = __expectInt32(data.defaultVersionId);
    }
    if (data.templateArn != null) {
        contents.templateArn = __expectString(data.templateArn);
    }
    if (data.templateName != null) {
        contents.templateName = __expectString(data.templateName);
    }
    return contents;
};
const deserializeAws_restJson1CreateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.isDefaultVersion != null) {
        contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
    }
    if (data.templateArn != null) {
        contents.templateArn = __expectString(data.templateArn);
    }
    if (data.templateName != null) {
        contents.templateName = __expectString(data.templateName);
    }
    if (data.versionId != null) {
        contents.versionId = __expectInt32(data.versionId);
    }
    return contents;
};
const deserializeAws_restJson1CreateProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            throw await deserializeAws_restJson1VersionsLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.roleAlias != null) {
        contents.roleAlias = __expectString(data.roleAlias);
    }
    if (data.roleAliasArn != null) {
        contents.roleAliasArn = __expectString(data.roleAliasArn);
    }
    return contents;
};
const deserializeAws_restJson1CreateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.scheduledAuditArn != null) {
        contents.scheduledAuditArn = __expectString(data.scheduledAuditArn);
    }
    return contents;
};
const deserializeAws_restJson1CreateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.securityProfileArn != null) {
        contents.securityProfileArn = __expectString(data.securityProfileArn);
    }
    if (data.securityProfileName != null) {
        contents.securityProfileName = __expectString(data.securityProfileName);
    }
    return contents;
};
const deserializeAws_restJson1CreateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.streamArn != null) {
        contents.streamArn = __expectString(data.streamArn);
    }
    if (data.streamId != null) {
        contents.streamId = __expectString(data.streamId);
    }
    if (data.streamVersion != null) {
        contents.streamVersion = __expectInt32(data.streamVersion);
    }
    return contents;
};
const deserializeAws_restJson1CreateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.thingArn != null) {
        contents.thingArn = __expectString(data.thingArn);
    }
    if (data.thingId != null) {
        contents.thingId = __expectString(data.thingId);
    }
    if (data.thingName != null) {
        contents.thingName = __expectString(data.thingName);
    }
    return contents;
};
const deserializeAws_restJson1CreateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.thingGroupArn != null) {
        contents.thingGroupArn = __expectString(data.thingGroupArn);
    }
    if (data.thingGroupId != null) {
        contents.thingGroupId = __expectString(data.thingGroupId);
    }
    if (data.thingGroupName != null) {
        contents.thingGroupName = __expectString(data.thingGroupName);
    }
    return contents;
};
const deserializeAws_restJson1CreateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.thingTypeArn != null) {
        contents.thingTypeArn = __expectString(data.thingTypeArn);
    }
    if (data.thingTypeId != null) {
        contents.thingTypeId = __expectString(data.thingTypeId);
    }
    if (data.thingTypeName != null) {
        contents.thingTypeName = __expectString(data.thingTypeName);
    }
    return contents;
};
const deserializeAws_restJson1CreateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1CreateTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            throw await deserializeAws_restJson1SqlParseExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.topicRuleDestination != null) {
        contents.topicRuleDestination = deserializeAws_restJson1TopicRuleDestination(data.topicRuleDestination, context);
    }
    return contents;
};
const deserializeAws_restJson1CreateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteAccountAuditConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDynamicThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteJobExecutionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteOTAUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeletePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeletePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeletePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeletePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeletePolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeletePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteRegistrationCodeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteV2LoggingLevelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeprecateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeprecateThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeprecateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAccountAuditConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.auditCheckConfigurations != null) {
        contents.auditCheckConfigurations = deserializeAws_restJson1AuditCheckConfigurations(data.auditCheckConfigurations, context);
    }
    if (data.auditNotificationTargetConfigurations != null) {
        contents.auditNotificationTargetConfigurations = deserializeAws_restJson1AuditNotificationTargetConfigurations(data.auditNotificationTargetConfigurations, context);
    }
    if (data.roleArn != null) {
        contents.roleArn = __expectString(data.roleArn);
    }
    return contents;
};
const deserializeAws_restJson1DescribeAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeAuditFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditFindingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.finding != null) {
        contents.finding = deserializeAws_restJson1AuditFinding(data.finding, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeAuditFindingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.actionsDefinition != null) {
        contents.actionsDefinition = deserializeAws_restJson1MitigationActionList(data.actionsDefinition, context);
    }
    if (data.auditCheckToActionsMapping != null) {
        contents.auditCheckToActionsMapping = deserializeAws_restJson1AuditCheckToActionsMapping(data.auditCheckToActionsMapping, context);
    }
    if (data.endTime != null) {
        contents.endTime = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.endTime)));
    }
    if (data.startTime != null) {
        contents.startTime = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.startTime)));
    }
    if (data.target != null) {
        contents.target = deserializeAws_restJson1AuditMitigationActionsTaskTarget(data.target, context);
    }
    if (data.taskStatistics != null) {
        contents.taskStatistics = deserializeAws_restJson1AuditMitigationActionsTaskStatistics(data.taskStatistics, context);
    }
    if (data.taskStatus != null) {
        contents.taskStatus = __expectString(data.taskStatus);
    }
    return contents;
};
const deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.checkName != null) {
        contents.checkName = __expectString(data.checkName);
    }
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.expirationDate != null) {
        contents.expirationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.expirationDate)));
    }
    if (data.resourceIdentifier != null) {
        contents.resourceIdentifier = deserializeAws_restJson1ResourceIdentifier(data.resourceIdentifier, context);
    }
    if (data.suppressIndefinitely != null) {
        contents.suppressIndefinitely = __expectBoolean(data.suppressIndefinitely);
    }
    return contents;
};
const deserializeAws_restJson1DescribeAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuditTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.auditDetails != null) {
        contents.auditDetails = deserializeAws_restJson1AuditDetails(data.auditDetails, context);
    }
    if (data.scheduledAuditName != null) {
        contents.scheduledAuditName = __expectString(data.scheduledAuditName);
    }
    if (data.taskStartTime != null) {
        contents.taskStartTime = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.taskStartTime)));
    }
    if (data.taskStatistics != null) {
        contents.taskStatistics = deserializeAws_restJson1TaskStatistics(data.taskStatistics, context);
    }
    if (data.taskStatus != null) {
        contents.taskStatus = __expectString(data.taskStatus);
    }
    if (data.taskType != null) {
        contents.taskType = __expectString(data.taskType);
    }
    return contents;
};
const deserializeAws_restJson1DescribeAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authorizerDescription != null) {
        contents.authorizerDescription = deserializeAws_restJson1AuthorizerDescription(data.authorizerDescription, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.billingGroupArn != null) {
        contents.billingGroupArn = __expectString(data.billingGroupArn);
    }
    if (data.billingGroupId != null) {
        contents.billingGroupId = __expectString(data.billingGroupId);
    }
    if (data.billingGroupMetadata != null) {
        contents.billingGroupMetadata = deserializeAws_restJson1BillingGroupMetadata(data.billingGroupMetadata, context);
    }
    if (data.billingGroupName != null) {
        contents.billingGroupName = __expectString(data.billingGroupName);
    }
    if (data.billingGroupProperties != null) {
        contents.billingGroupProperties = deserializeAws_restJson1BillingGroupProperties(data.billingGroupProperties, context);
    }
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1DescribeBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateDescription != null) {
        contents.certificateDescription = deserializeAws_restJson1CACertificateDescription(data.certificateDescription, context);
    }
    if (data.registrationConfig != null) {
        contents.registrationConfig = deserializeAws_restJson1RegistrationConfig(data.registrationConfig, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateDescription != null) {
        contents.certificateDescription = deserializeAws_restJson1CertificateDescription(data.certificateDescription, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.displayName != null) {
        contents.displayName = __expectString(data.displayName);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.metricArn != null) {
        contents.metricArn = __expectString(data.metricArn);
    }
    if (data.metricName != null) {
        contents.metricName = __expectString(data.metricName);
    }
    if (data.metricType != null) {
        contents.metricType = __expectString(data.metricType);
    }
    return contents;
};
const deserializeAws_restJson1DescribeCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDefaultAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authorizerDescription != null) {
        contents.authorizerDescription = deserializeAws_restJson1AuthorizerDescription(data.authorizerDescription, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.taskSummary != null) {
        contents.taskSummary = deserializeAws_restJson1DetectMitigationActionsTaskSummary(data.taskSummary, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.arn != null) {
        contents.arn = __expectString(data.arn);
    }
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.name != null) {
        contents.name = __expectString(data.name);
    }
    if (data.stringValues != null) {
        contents.stringValues = deserializeAws_restJson1DimensionStringValues(data.stringValues, context);
    }
    if (data.type != null) {
        contents.type = __expectString(data.type);
    }
    return contents;
};
const deserializeAws_restJson1DescribeDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authorizerConfig != null) {
        contents.authorizerConfig = deserializeAws_restJson1AuthorizerConfig(data.authorizerConfig, context);
    }
    if (data.domainConfigurationArn != null) {
        contents.domainConfigurationArn = __expectString(data.domainConfigurationArn);
    }
    if (data.domainConfigurationName != null) {
        contents.domainConfigurationName = __expectString(data.domainConfigurationName);
    }
    if (data.domainConfigurationStatus != null) {
        contents.domainConfigurationStatus = __expectString(data.domainConfigurationStatus);
    }
    if (data.domainName != null) {
        contents.domainName = __expectString(data.domainName);
    }
    if (data.domainType != null) {
        contents.domainType = __expectString(data.domainType);
    }
    if (data.lastStatusChangeDate != null) {
        contents.lastStatusChangeDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastStatusChangeDate)));
    }
    if (data.serverCertificates != null) {
        contents.serverCertificates = deserializeAws_restJson1ServerCertificates(data.serverCertificates, context);
    }
    if (data.serviceType != null) {
        contents.serviceType = __expectString(data.serviceType);
    }
    return contents;
};
const deserializeAws_restJson1DescribeDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeEndpointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.endpointAddress != null) {
        contents.endpointAddress = __expectString(data.endpointAddress);
    }
    return contents;
};
const deserializeAws_restJson1DescribeEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeEventConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.eventConfigurations != null) {
        contents.eventConfigurations = deserializeAws_restJson1EventConfigurations(data.eventConfigurations, context);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    return contents;
};
const deserializeAws_restJson1DescribeEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.aggregationField != null) {
        contents.aggregationField = __expectString(data.aggregationField);
    }
    if (data.aggregationType != null) {
        contents.aggregationType = deserializeAws_restJson1AggregationType(data.aggregationType, context);
    }
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.indexName != null) {
        contents.indexName = __expectString(data.indexName);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.metricArn != null) {
        contents.metricArn = __expectString(data.metricArn);
    }
    if (data.metricName != null) {
        contents.metricName = __expectString(data.metricName);
    }
    if (data.period != null) {
        contents.period = __expectInt32(data.period);
    }
    if (data.queryString != null) {
        contents.queryString = __expectString(data.queryString);
    }
    if (data.queryVersion != null) {
        contents.queryVersion = __expectString(data.queryVersion);
    }
    if (data.unit != null) {
        contents.unit = __expectString(data.unit);
    }
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1DescribeFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeIndexCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.indexName != null) {
        contents.indexName = __expectString(data.indexName);
    }
    if (data.indexStatus != null) {
        contents.indexStatus = __expectString(data.indexStatus);
    }
    if (data.schema != null) {
        contents.schema = __expectString(data.schema);
    }
    return contents;
};
const deserializeAws_restJson1DescribeIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.documentSource != null) {
        contents.documentSource = __expectString(data.documentSource);
    }
    if (data.job != null) {
        contents.job = deserializeAws_restJson1Job(data.job, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeJobExecutionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.execution != null) {
        contents.execution = deserializeAws_restJson1JobExecution(data.execution, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.abortConfig != null) {
        contents.abortConfig = deserializeAws_restJson1AbortConfig(data.abortConfig, context);
    }
    if (data.createdAt != null) {
        contents.createdAt = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.createdAt)));
    }
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.document != null) {
        contents.document = __expectString(data.document);
    }
    if (data.documentSource != null) {
        contents.documentSource = __expectString(data.documentSource);
    }
    if (data.jobExecutionsRetryConfig != null) {
        contents.jobExecutionsRetryConfig = deserializeAws_restJson1JobExecutionsRetryConfig(data.jobExecutionsRetryConfig, context);
    }
    if (data.jobExecutionsRolloutConfig != null) {
        contents.jobExecutionsRolloutConfig = deserializeAws_restJson1JobExecutionsRolloutConfig(data.jobExecutionsRolloutConfig, context);
    }
    if (data.jobTemplateArn != null) {
        contents.jobTemplateArn = __expectString(data.jobTemplateArn);
    }
    if (data.jobTemplateId != null) {
        contents.jobTemplateId = __expectString(data.jobTemplateId);
    }
    if (data.maintenanceWindows != null) {
        contents.maintenanceWindows = deserializeAws_restJson1MaintenanceWindows(data.maintenanceWindows, context);
    }
    if (data.presignedUrlConfig != null) {
        contents.presignedUrlConfig = deserializeAws_restJson1PresignedUrlConfig(data.presignedUrlConfig, context);
    }
    if (data.timeoutConfig != null) {
        contents.timeoutConfig = deserializeAws_restJson1TimeoutConfig(data.timeoutConfig, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeManagedJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeManagedJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.document != null) {
        contents.document = __expectString(data.document);
    }
    if (data.documentParameters != null) {
        contents.documentParameters = deserializeAws_restJson1DocumentParameters(data.documentParameters, context);
    }
    if (data.environments != null) {
        contents.environments = deserializeAws_restJson1Environments(data.environments, context);
    }
    if (data.templateArn != null) {
        contents.templateArn = __expectString(data.templateArn);
    }
    if (data.templateName != null) {
        contents.templateName = __expectString(data.templateName);
    }
    if (data.templateVersion != null) {
        contents.templateVersion = __expectString(data.templateVersion);
    }
    return contents;
};
const deserializeAws_restJson1DescribeManagedJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.actionArn != null) {
        contents.actionArn = __expectString(data.actionArn);
    }
    if (data.actionId != null) {
        contents.actionId = __expectString(data.actionId);
    }
    if (data.actionName != null) {
        contents.actionName = __expectString(data.actionName);
    }
    if (data.actionParams != null) {
        contents.actionParams = deserializeAws_restJson1MitigationActionParams(data.actionParams, context);
    }
    if (data.actionType != null) {
        contents.actionType = __expectString(data.actionType);
    }
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.roleArn != null) {
        contents.roleArn = __expectString(data.roleArn);
    }
    return contents;
};
const deserializeAws_restJson1DescribeMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.defaultVersionId != null) {
        contents.defaultVersionId = __expectInt32(data.defaultVersionId);
    }
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.enabled != null) {
        contents.enabled = __expectBoolean(data.enabled);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.preProvisioningHook != null) {
        contents.preProvisioningHook = deserializeAws_restJson1ProvisioningHook(data.preProvisioningHook, context);
    }
    if (data.provisioningRoleArn != null) {
        contents.provisioningRoleArn = __expectString(data.provisioningRoleArn);
    }
    if (data.templateArn != null) {
        contents.templateArn = __expectString(data.templateArn);
    }
    if (data.templateBody != null) {
        contents.templateBody = __expectString(data.templateBody);
    }
    if (data.templateName != null) {
        contents.templateName = __expectString(data.templateName);
    }
    if (data.type != null) {
        contents.type = __expectString(data.type);
    }
    return contents;
};
const deserializeAws_restJson1DescribeProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.isDefaultVersion != null) {
        contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
    }
    if (data.templateBody != null) {
        contents.templateBody = __expectString(data.templateBody);
    }
    if (data.versionId != null) {
        contents.versionId = __expectInt32(data.versionId);
    }
    return contents;
};
const deserializeAws_restJson1DescribeProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.roleAliasDescription != null) {
        contents.roleAliasDescription = deserializeAws_restJson1RoleAliasDescription(data.roleAliasDescription, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.dayOfMonth != null) {
        contents.dayOfMonth = __expectString(data.dayOfMonth);
    }
    if (data.dayOfWeek != null) {
        contents.dayOfWeek = __expectString(data.dayOfWeek);
    }
    if (data.frequency != null) {
        contents.frequency = __expectString(data.frequency);
    }
    if (data.scheduledAuditArn != null) {
        contents.scheduledAuditArn = __expectString(data.scheduledAuditArn);
    }
    if (data.scheduledAuditName != null) {
        contents.scheduledAuditName = __expectString(data.scheduledAuditName);
    }
    if (data.targetCheckNames != null) {
        contents.targetCheckNames = deserializeAws_restJson1TargetAuditCheckNames(data.targetCheckNames, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.additionalMetricsToRetain != null) {
        contents.additionalMetricsToRetain = deserializeAws_restJson1AdditionalMetricsToRetainList(data.additionalMetricsToRetain, context);
    }
    if (data.additionalMetricsToRetainV2 != null) {
        contents.additionalMetricsToRetainV2 = deserializeAws_restJson1AdditionalMetricsToRetainV2List(data.additionalMetricsToRetainV2, context);
    }
    if (data.alertTargets != null) {
        contents.alertTargets = deserializeAws_restJson1AlertTargets(data.alertTargets, context);
    }
    if (data.behaviors != null) {
        contents.behaviors = deserializeAws_restJson1Behaviors(data.behaviors, context);
    }
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.securityProfileArn != null) {
        contents.securityProfileArn = __expectString(data.securityProfileArn);
    }
    if (data.securityProfileDescription != null) {
        contents.securityProfileDescription = __expectString(data.securityProfileDescription);
    }
    if (data.securityProfileName != null) {
        contents.securityProfileName = __expectString(data.securityProfileName);
    }
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1DescribeSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.streamInfo != null) {
        contents.streamInfo = deserializeAws_restJson1StreamInfo(data.streamInfo, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.attributes != null) {
        contents.attributes = deserializeAws_restJson1Attributes(data.attributes, context);
    }
    if (data.billingGroupName != null) {
        contents.billingGroupName = __expectString(data.billingGroupName);
    }
    if (data.defaultClientId != null) {
        contents.defaultClientId = __expectString(data.defaultClientId);
    }
    if (data.thingArn != null) {
        contents.thingArn = __expectString(data.thingArn);
    }
    if (data.thingId != null) {
        contents.thingId = __expectString(data.thingId);
    }
    if (data.thingName != null) {
        contents.thingName = __expectString(data.thingName);
    }
    if (data.thingTypeName != null) {
        contents.thingTypeName = __expectString(data.thingTypeName);
    }
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1DescribeThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.indexName != null) {
        contents.indexName = __expectString(data.indexName);
    }
    if (data.queryString != null) {
        contents.queryString = __expectString(data.queryString);
    }
    if (data.queryVersion != null) {
        contents.queryVersion = __expectString(data.queryVersion);
    }
    if (data.status != null) {
        contents.status = __expectString(data.status);
    }
    if (data.thingGroupArn != null) {
        contents.thingGroupArn = __expectString(data.thingGroupArn);
    }
    if (data.thingGroupId != null) {
        contents.thingGroupId = __expectString(data.thingGroupId);
    }
    if (data.thingGroupMetadata != null) {
        contents.thingGroupMetadata = deserializeAws_restJson1ThingGroupMetadata(data.thingGroupMetadata, context);
    }
    if (data.thingGroupName != null) {
        contents.thingGroupName = __expectString(data.thingGroupName);
    }
    if (data.thingGroupProperties != null) {
        contents.thingGroupProperties = deserializeAws_restJson1ThingGroupProperties(data.thingGroupProperties, context);
    }
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1DescribeThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingRegistrationTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.failureCount != null) {
        contents.failureCount = __expectInt32(data.failureCount);
    }
    if (data.inputFileBucket != null) {
        contents.inputFileBucket = __expectString(data.inputFileBucket);
    }
    if (data.inputFileKey != null) {
        contents.inputFileKey = __expectString(data.inputFileKey);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    if (data.percentageProgress != null) {
        contents.percentageProgress = __expectInt32(data.percentageProgress);
    }
    if (data.roleArn != null) {
        contents.roleArn = __expectString(data.roleArn);
    }
    if (data.status != null) {
        contents.status = __expectString(data.status);
    }
    if (data.successCount != null) {
        contents.successCount = __expectInt32(data.successCount);
    }
    if (data.taskId != null) {
        contents.taskId = __expectString(data.taskId);
    }
    if (data.templateBody != null) {
        contents.templateBody = __expectString(data.templateBody);
    }
    return contents;
};
const deserializeAws_restJson1DescribeThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.thingTypeArn != null) {
        contents.thingTypeArn = __expectString(data.thingTypeArn);
    }
    if (data.thingTypeId != null) {
        contents.thingTypeId = __expectString(data.thingTypeId);
    }
    if (data.thingTypeMetadata != null) {
        contents.thingTypeMetadata = deserializeAws_restJson1ThingTypeMetadata(data.thingTypeMetadata, context);
    }
    if (data.thingTypeName != null) {
        contents.thingTypeName = __expectString(data.thingTypeName);
    }
    if (data.thingTypeProperties != null) {
        contents.thingTypeProperties = deserializeAws_restJson1ThingTypeProperties(data.thingTypeProperties, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DetachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DetachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DetachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachPrincipalPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DetachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DetachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DetachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DetachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DetachThingPrincipalCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DetachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DisableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DisableTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DisableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1EnableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1EnableTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1EnableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetBehaviorModelTrainingSummariesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetBehaviorModelTrainingSummariesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.summaries != null) {
        contents.summaries = deserializeAws_restJson1BehaviorModelTrainingSummaries(data.summaries, context);
    }
    return contents;
};
const deserializeAws_restJson1GetBehaviorModelTrainingSummariesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetBucketsAggregationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetBucketsAggregationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.buckets != null) {
        contents.buckets = deserializeAws_restJson1Buckets(data.buckets, context);
    }
    if (data.totalCount != null) {
        contents.totalCount = __expectInt32(data.totalCount);
    }
    return contents;
};
const deserializeAws_restJson1GetBucketsAggregationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetCardinalityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetCardinalityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.cardinality != null) {
        contents.cardinality = __expectInt32(data.cardinality);
    }
    return contents;
};
const deserializeAws_restJson1GetCardinalityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetEffectivePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetEffectivePoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.effectivePolicies != null) {
        contents.effectivePolicies = deserializeAws_restJson1EffectivePolicies(data.effectivePolicies, context);
    }
    return contents;
};
const deserializeAws_restJson1GetEffectivePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetIndexingConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.thingGroupIndexingConfiguration != null) {
        contents.thingGroupIndexingConfiguration = deserializeAws_restJson1ThingGroupIndexingConfiguration(data.thingGroupIndexingConfiguration, context);
    }
    if (data.thingIndexingConfiguration != null) {
        contents.thingIndexingConfiguration = deserializeAws_restJson1ThingIndexingConfiguration(data.thingIndexingConfiguration, context);
    }
    return contents;
};
const deserializeAws_restJson1GetIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetJobDocumentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetJobDocumentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.document != null) {
        contents.document = __expectString(data.document);
    }
    return contents;
};
const deserializeAws_restJson1GetJobDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetLoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.logLevel != null) {
        contents.logLevel = __expectString(data.logLevel);
    }
    if (data.roleArn != null) {
        contents.roleArn = __expectString(data.roleArn);
    }
    return contents;
};
const deserializeAws_restJson1GetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetOTAUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.otaUpdateInfo != null) {
        contents.otaUpdateInfo = deserializeAws_restJson1OTAUpdateInfo(data.otaUpdateInfo, context);
    }
    return contents;
};
const deserializeAws_restJson1GetOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetPercentilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPercentilesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.percentiles != null) {
        contents.percentiles = deserializeAws_restJson1Percentiles(data.percentiles, context);
    }
    return contents;
};
const deserializeAws_restJson1GetPercentilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.defaultVersionId != null) {
        contents.defaultVersionId = __expectString(data.defaultVersionId);
    }
    if (data.generationId != null) {
        contents.generationId = __expectString(data.generationId);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.policyArn != null) {
        contents.policyArn = __expectString(data.policyArn);
    }
    if (data.policyDocument != null) {
        contents.policyDocument = __expectString(data.policyDocument);
    }
    if (data.policyName != null) {
        contents.policyName = __expectString(data.policyName);
    }
    return contents;
};
const deserializeAws_restJson1GetPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.generationId != null) {
        contents.generationId = __expectString(data.generationId);
    }
    if (data.isDefaultVersion != null) {
        contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.policyArn != null) {
        contents.policyArn = __expectString(data.policyArn);
    }
    if (data.policyDocument != null) {
        contents.policyDocument = __expectString(data.policyDocument);
    }
    if (data.policyName != null) {
        contents.policyName = __expectString(data.policyName);
    }
    if (data.policyVersionId != null) {
        contents.policyVersionId = __expectString(data.policyVersionId);
    }
    return contents;
};
const deserializeAws_restJson1GetPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetRegistrationCodeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.registrationCode != null) {
        contents.registrationCode = __expectString(data.registrationCode);
    }
    return contents;
};
const deserializeAws_restJson1GetRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetStatisticsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetStatisticsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.statistics != null) {
        contents.statistics = deserializeAws_restJson1Statistics(data.statistics, context);
    }
    return contents;
};
const deserializeAws_restJson1GetStatisticsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.rule != null) {
        contents.rule = deserializeAws_restJson1TopicRule(data.rule, context);
    }
    if (data.ruleArn != null) {
        contents.ruleArn = __expectString(data.ruleArn);
    }
    return contents;
};
const deserializeAws_restJson1GetTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.topicRuleDestination != null) {
        contents.topicRuleDestination = deserializeAws_restJson1TopicRuleDestination(data.topicRuleDestination, context);
    }
    return contents;
};
const deserializeAws_restJson1GetTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetV2LoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.defaultLogLevel != null) {
        contents.defaultLogLevel = __expectString(data.defaultLogLevel);
    }
    if (data.disableAllLogs != null) {
        contents.disableAllLogs = __expectBoolean(data.disableAllLogs);
    }
    if (data.roleArn != null) {
        contents.roleArn = __expectString(data.roleArn);
    }
    return contents;
};
const deserializeAws_restJson1GetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListActiveViolationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListActiveViolationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.activeViolations != null) {
        contents.activeViolations = deserializeAws_restJson1ActiveViolations(data.activeViolations, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListActiveViolationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListAttachedPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAttachedPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    if (data.policies != null) {
        contents.policies = deserializeAws_restJson1Policies(data.policies, context);
    }
    return contents;
};
const deserializeAws_restJson1ListAttachedPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListAuditFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditFindingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.findings != null) {
        contents.findings = deserializeAws_restJson1AuditFindings(data.findings, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListAuditFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.actionsExecutions != null) {
        contents.actionsExecutions = deserializeAws_restJson1AuditMitigationActionExecutionMetadataList(data.actionsExecutions, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListAuditMitigationActionsTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditMitigationActionsTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.tasks != null) {
        contents.tasks = deserializeAws_restJson1AuditMitigationActionsTaskMetadataList(data.tasks, context);
    }
    return contents;
};
const deserializeAws_restJson1ListAuditMitigationActionsTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListAuditSuppressionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditSuppressionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.suppressions != null) {
        contents.suppressions = deserializeAws_restJson1AuditSuppressionList(data.suppressions, context);
    }
    return contents;
};
const deserializeAws_restJson1ListAuditSuppressionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListAuditTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuditTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.tasks != null) {
        contents.tasks = deserializeAws_restJson1AuditTaskMetadataList(data.tasks, context);
    }
    return contents;
};
const deserializeAws_restJson1ListAuditTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAuthorizersCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authorizers != null) {
        contents.authorizers = deserializeAws_restJson1Authorizers(data.authorizers, context);
    }
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    return contents;
};
const deserializeAws_restJson1ListAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListBillingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListBillingGroupsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.billingGroups != null) {
        contents.billingGroups = deserializeAws_restJson1BillingGroupNameAndArnList(data.billingGroups, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListBillingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListCACertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListCACertificatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificates != null) {
        contents.certificates = deserializeAws_restJson1CACertificates(data.certificates, context);
    }
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    return contents;
};
const deserializeAws_restJson1ListCACertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListCertificatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificates != null) {
        contents.certificates = deserializeAws_restJson1Certificates(data.certificates, context);
    }
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    return contents;
};
const deserializeAws_restJson1ListCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListCertificatesByCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListCertificatesByCACommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificates != null) {
        contents.certificates = deserializeAws_restJson1Certificates(data.certificates, context);
    }
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    return contents;
};
const deserializeAws_restJson1ListCertificatesByCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListCustomMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListCustomMetricsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.metricNames != null) {
        contents.metricNames = deserializeAws_restJson1MetricNames(data.metricNames, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListCustomMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListDetectMitigationActionsExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDetectMitigationActionsExecutionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.actionsExecutions != null) {
        contents.actionsExecutions = deserializeAws_restJson1DetectMitigationActionExecutionList(data.actionsExecutions, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListDetectMitigationActionsExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListDetectMitigationActionsTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDetectMitigationActionsTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.tasks != null) {
        contents.tasks = deserializeAws_restJson1DetectMitigationActionsTaskSummaryList(data.tasks, context);
    }
    return contents;
};
const deserializeAws_restJson1ListDetectMitigationActionsTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListDimensionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDimensionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.dimensionNames != null) {
        contents.dimensionNames = deserializeAws_restJson1DimensionNames(data.dimensionNames, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListDimensionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListDomainConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDomainConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.domainConfigurations != null) {
        contents.domainConfigurations = deserializeAws_restJson1DomainConfigurations(data.domainConfigurations, context);
    }
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    return contents;
};
const deserializeAws_restJson1ListDomainConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListFleetMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListFleetMetricsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.fleetMetrics != null) {
        contents.fleetMetrics = deserializeAws_restJson1FleetMetricNameAndArnList(data.fleetMetrics, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListFleetMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListIndicesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListIndicesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.indexNames != null) {
        contents.indexNames = deserializeAws_restJson1IndexNamesList(data.indexNames, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListIndicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListJobExecutionsForJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListJobExecutionsForJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.executionSummaries != null) {
        contents.executionSummaries = deserializeAws_restJson1JobExecutionSummaryForJobList(data.executionSummaries, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListJobExecutionsForJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListJobExecutionsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListJobExecutionsForThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.executionSummaries != null) {
        contents.executionSummaries = deserializeAws_restJson1JobExecutionSummaryForThingList(data.executionSummaries, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListJobExecutionsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListJobsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.jobs != null) {
        contents.jobs = deserializeAws_restJson1JobSummaryList(data.jobs, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListJobTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListJobTemplatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.jobTemplates != null) {
        contents.jobTemplates = deserializeAws_restJson1JobTemplateSummaryList(data.jobTemplates, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListJobTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListManagedJobTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListManagedJobTemplatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.managedJobTemplates != null) {
        contents.managedJobTemplates = deserializeAws_restJson1ManagedJobTemplatesSummaryList(data.managedJobTemplates, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListManagedJobTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListMetricValuesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListMetricValuesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.metricDatumList != null) {
        contents.metricDatumList = deserializeAws_restJson1MetricDatumList(data.metricDatumList, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListMetricValuesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListMitigationActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListMitigationActionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.actionIdentifiers != null) {
        contents.actionIdentifiers = deserializeAws_restJson1MitigationActionIdentifierList(data.actionIdentifiers, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListMitigationActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListOTAUpdatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListOTAUpdatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.otaUpdates != null) {
        contents.otaUpdates = deserializeAws_restJson1OTAUpdatesSummary(data.otaUpdates, context);
    }
    return contents;
};
const deserializeAws_restJson1ListOTAUpdatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListOutgoingCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListOutgoingCertificatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    if (data.outgoingCertificates != null) {
        contents.outgoingCertificates = deserializeAws_restJson1OutgoingCertificates(data.outgoingCertificates, context);
    }
    return contents;
};
const deserializeAws_restJson1ListOutgoingCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    if (data.policies != null) {
        contents.policies = deserializeAws_restJson1Policies(data.policies, context);
    }
    return contents;
};
const deserializeAws_restJson1ListPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListPolicyPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPolicyPrincipalsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    if (data.principals != null) {
        contents.principals = deserializeAws_restJson1Principals(data.principals, context);
    }
    return contents;
};
const deserializeAws_restJson1ListPolicyPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPolicyVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.policyVersions != null) {
        contents.policyVersions = deserializeAws_restJson1PolicyVersions(data.policyVersions, context);
    }
    return contents;
};
const deserializeAws_restJson1ListPolicyVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListPrincipalPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPrincipalPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    if (data.policies != null) {
        contents.policies = deserializeAws_restJson1Policies(data.policies, context);
    }
    return contents;
};
const deserializeAws_restJson1ListPrincipalPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListPrincipalThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPrincipalThingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.things != null) {
        contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
    }
    return contents;
};
const deserializeAws_restJson1ListPrincipalThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListProvisioningTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListProvisioningTemplatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.templates != null) {
        contents.templates = deserializeAws_restJson1ProvisioningTemplateListing(data.templates, context);
    }
    return contents;
};
const deserializeAws_restJson1ListProvisioningTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListProvisioningTemplateVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListProvisioningTemplateVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.versions != null) {
        contents.versions = deserializeAws_restJson1ProvisioningTemplateVersionListing(data.versions, context);
    }
    return contents;
};
const deserializeAws_restJson1ListProvisioningTemplateVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListRelatedResourcesForAuditFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListRelatedResourcesForAuditFindingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.relatedResources != null) {
        contents.relatedResources = deserializeAws_restJson1RelatedResources(data.relatedResources, context);
    }
    return contents;
};
const deserializeAws_restJson1ListRelatedResourcesForAuditFindingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListRoleAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListRoleAliasesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    if (data.roleAliases != null) {
        contents.roleAliases = deserializeAws_restJson1RoleAliases(data.roleAliases, context);
    }
    return contents;
};
const deserializeAws_restJson1ListRoleAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListScheduledAuditsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListScheduledAuditsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.scheduledAudits != null) {
        contents.scheduledAudits = deserializeAws_restJson1ScheduledAuditMetadataList(data.scheduledAudits, context);
    }
    return contents;
};
const deserializeAws_restJson1ListScheduledAuditsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListSecurityProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListSecurityProfilesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.securityProfileIdentifiers != null) {
        contents.securityProfileIdentifiers = deserializeAws_restJson1SecurityProfileIdentifiers(data.securityProfileIdentifiers, context);
    }
    return contents;
};
const deserializeAws_restJson1ListSecurityProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListSecurityProfilesForTargetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListSecurityProfilesForTargetCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.securityProfileTargetMappings != null) {
        contents.securityProfileTargetMappings = deserializeAws_restJson1SecurityProfileTargetMappings(data.securityProfileTargetMappings, context);
    }
    return contents;
};
const deserializeAws_restJson1ListSecurityProfilesForTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListStreamsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListStreamsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.streams != null) {
        contents.streams = deserializeAws_restJson1StreamsSummary(data.streams, context);
    }
    return contents;
};
const deserializeAws_restJson1ListStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTagsForResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.tags != null) {
        contents.tags = deserializeAws_restJson1TagList(data.tags, context);
    }
    return contents;
};
const deserializeAws_restJson1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListTargetsForPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTargetsForPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextMarker != null) {
        contents.nextMarker = __expectString(data.nextMarker);
    }
    if (data.targets != null) {
        contents.targets = deserializeAws_restJson1PolicyTargets(data.targets, context);
    }
    return contents;
};
const deserializeAws_restJson1ListTargetsForPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListTargetsForSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTargetsForSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.securityProfileTargets != null) {
        contents.securityProfileTargets = deserializeAws_restJson1SecurityProfileTargets(data.securityProfileTargets, context);
    }
    return contents;
};
const deserializeAws_restJson1ListTargetsForSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingGroupsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.thingGroups != null) {
        contents.thingGroups = deserializeAws_restJson1ThingGroupNameAndArnList(data.thingGroups, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingGroupsForThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.thingGroups != null) {
        contents.thingGroups = deserializeAws_restJson1ThingGroupNameAndArnList(data.thingGroups, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingPrincipalsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.principals != null) {
        contents.principals = deserializeAws_restJson1Principals(data.principals, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingRegistrationTaskReportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingRegistrationTaskReportsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.reportType != null) {
        contents.reportType = __expectString(data.reportType);
    }
    if (data.resourceLinks != null) {
        contents.resourceLinks = deserializeAws_restJson1S3FileUrlList(data.resourceLinks, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingRegistrationTaskReportsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingRegistrationTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingRegistrationTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.taskIds != null) {
        contents.taskIds = deserializeAws_restJson1TaskIdList(data.taskIds, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingRegistrationTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.things != null) {
        contents.things = deserializeAws_restJson1ThingAttributeList(data.things, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingsInBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingsInBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.things != null) {
        contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingsInBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingsInThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingsInThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.things != null) {
        contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingsInThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListThingTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListThingTypesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.thingTypes != null) {
        contents.thingTypes = deserializeAws_restJson1ThingTypeList(data.thingTypes, context);
    }
    return contents;
};
const deserializeAws_restJson1ListThingTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListTopicRuleDestinationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTopicRuleDestinationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.destinationSummaries != null) {
        contents.destinationSummaries = deserializeAws_restJson1TopicRuleDestinationSummaries(data.destinationSummaries, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListTopicRuleDestinationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListTopicRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTopicRulesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.rules != null) {
        contents.rules = deserializeAws_restJson1TopicRuleList(data.rules, context);
    }
    return contents;
};
const deserializeAws_restJson1ListTopicRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListV2LoggingLevelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListV2LoggingLevelsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.logTargetConfigurations != null) {
        contents.logTargetConfigurations = deserializeAws_restJson1LogTargetConfigurations(data.logTargetConfigurations, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListV2LoggingLevelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListViolationEventsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListViolationEventsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.violationEvents != null) {
        contents.violationEvents = deserializeAws_restJson1ViolationEvents(data.violationEvents, context);
    }
    return contents;
};
const deserializeAws_restJson1ListViolationEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1PutVerificationStateOnViolationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1PutVerificationStateOnViolationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1PutVerificationStateOnViolationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RegisterCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateArn != null) {
        contents.certificateArn = __expectString(data.certificateArn);
    }
    if (data.certificateId != null) {
        contents.certificateId = __expectString(data.certificateId);
    }
    return contents;
};
const deserializeAws_restJson1RegisterCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "RegistrationCodeValidationException":
        case "com.amazonaws.iot#RegistrationCodeValidationException":
            throw await deserializeAws_restJson1RegistrationCodeValidationExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RegisterCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateArn != null) {
        contents.certificateArn = __expectString(data.certificateArn);
    }
    if (data.certificateId != null) {
        contents.certificateId = __expectString(data.certificateId);
    }
    return contents;
};
const deserializeAws_restJson1RegisterCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateConflictException":
        case "com.amazonaws.iot#CertificateConflictException":
            throw await deserializeAws_restJson1CertificateConflictExceptionResponse(parsedOutput, context);
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context);
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RegisterCertificateWithoutCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterCertificateWithoutCACommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificateArn != null) {
        contents.certificateArn = __expectString(data.certificateArn);
    }
    if (data.certificateId != null) {
        contents.certificateId = __expectString(data.certificateId);
    }
    return contents;
};
const deserializeAws_restJson1RegisterCertificateWithoutCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context);
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RegisterThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.certificatePem != null) {
        contents.certificatePem = __expectString(data.certificatePem);
    }
    if (data.resourceArns != null) {
        contents.resourceArns = deserializeAws_restJson1ResourceArns(data.resourceArns, context);
    }
    return contents;
};
const deserializeAws_restJson1RegisterThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceRegistrationFailureException":
        case "com.amazonaws.iot#ResourceRegistrationFailureException":
            throw await deserializeAws_restJson1ResourceRegistrationFailureExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RejectCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RejectCertificateTransferCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1RejectCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RemoveThingFromBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RemoveThingFromBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1RemoveThingFromBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RemoveThingFromThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RemoveThingFromThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1RemoveThingFromThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ReplaceTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ReplaceTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1ReplaceTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            throw await deserializeAws_restJson1SqlParseExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1SearchIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SearchIndexCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = __expectString(data.nextToken);
    }
    if (data.thingGroups != null) {
        contents.thingGroups = deserializeAws_restJson1ThingGroupDocumentList(data.thingGroups, context);
    }
    if (data.things != null) {
        contents.things = deserializeAws_restJson1ThingDocumentList(data.things, context);
    }
    return contents;
};
const deserializeAws_restJson1SearchIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1SetDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetDefaultAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authorizerArn != null) {
        contents.authorizerArn = __expectString(data.authorizerArn);
    }
    if (data.authorizerName != null) {
        contents.authorizerName = __expectString(data.authorizerName);
    }
    return contents;
};
const deserializeAws_restJson1SetDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1SetDefaultPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetDefaultPolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1SetDefaultPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1SetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetLoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1SetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1SetV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetV2LoggingLevelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1SetV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1SetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1SetV2LoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1SetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1StartAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.taskId != null) {
        contents.taskId = __expectString(data.taskId);
    }
    return contents;
};
const deserializeAws_restJson1StartAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "TaskAlreadyExistsException":
        case "com.amazonaws.iot#TaskAlreadyExistsException":
            throw await deserializeAws_restJson1TaskAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1StartDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.taskId != null) {
        contents.taskId = __expectString(data.taskId);
    }
    return contents;
};
const deserializeAws_restJson1StartDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "TaskAlreadyExistsException":
        case "com.amazonaws.iot#TaskAlreadyExistsException":
            throw await deserializeAws_restJson1TaskAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1StartOnDemandAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartOnDemandAuditTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.taskId != null) {
        contents.taskId = __expectString(data.taskId);
    }
    return contents;
};
const deserializeAws_restJson1StartOnDemandAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1StartThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartThingRegistrationTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.taskId != null) {
        contents.taskId = __expectString(data.taskId);
    }
    return contents;
};
const deserializeAws_restJson1StartThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1StopThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StopThingRegistrationTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1StopThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1TestAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TestAuthorizationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authResults != null) {
        contents.authResults = deserializeAws_restJson1AuthResults(data.authResults, context);
    }
    return contents;
};
const deserializeAws_restJson1TestAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1TestInvokeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TestInvokeAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.disconnectAfterInSeconds != null) {
        contents.disconnectAfterInSeconds = __expectInt32(data.disconnectAfterInSeconds);
    }
    if (data.isAuthenticated != null) {
        contents.isAuthenticated = __expectBoolean(data.isAuthenticated);
    }
    if (data.policyDocuments != null) {
        contents.policyDocuments = deserializeAws_restJson1PolicyDocuments(data.policyDocuments, context);
    }
    if (data.principalId != null) {
        contents.principalId = __expectString(data.principalId);
    }
    if (data.refreshAfterInSeconds != null) {
        contents.refreshAfterInSeconds = __expectInt32(data.refreshAfterInSeconds);
    }
    return contents;
};
const deserializeAws_restJson1TestInvokeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "InvalidResponseException":
        case "com.amazonaws.iot#InvalidResponseException":
            throw await deserializeAws_restJson1InvalidResponseExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1TransferCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TransferCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.transferredCertificateArn != null) {
        contents.transferredCertificateArn = __expectString(data.transferredCertificateArn);
    }
    return contents;
};
const deserializeAws_restJson1TransferCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "TransferConflictException":
        case "com.amazonaws.iot#TransferConflictException":
            throw await deserializeAws_restJson1TransferConflictExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UntagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateAccountAuditConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.authorizerArn != null) {
        contents.authorizerArn = __expectString(data.authorizerArn);
    }
    if (data.authorizerName != null) {
        contents.authorizerName = __expectString(data.authorizerName);
    }
    return contents;
};
const deserializeAws_restJson1UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1UpdateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.displayName != null) {
        contents.displayName = __expectString(data.displayName);
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.metricArn != null) {
        contents.metricArn = __expectString(data.metricArn);
    }
    if (data.metricName != null) {
        contents.metricName = __expectString(data.metricName);
    }
    if (data.metricType != null) {
        contents.metricType = __expectString(data.metricType);
    }
    return contents;
};
const deserializeAws_restJson1UpdateCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.arn != null) {
        contents.arn = __expectString(data.arn);
    }
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.name != null) {
        contents.name = __expectString(data.name);
    }
    if (data.stringValues != null) {
        contents.stringValues = deserializeAws_restJson1DimensionStringValues(data.stringValues, context);
    }
    if (data.type != null) {
        contents.type = __expectString(data.type);
    }
    return contents;
};
const deserializeAws_restJson1UpdateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.domainConfigurationArn != null) {
        contents.domainConfigurationArn = __expectString(data.domainConfigurationArn);
    }
    if (data.domainConfigurationName != null) {
        contents.domainConfigurationName = __expectString(data.domainConfigurationName);
    }
    return contents;
};
const deserializeAws_restJson1UpdateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateDynamicThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1UpdateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateEventConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateIndexingConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.actionArn != null) {
        contents.actionArn = __expectString(data.actionArn);
    }
    if (data.actionId != null) {
        contents.actionId = __expectString(data.actionId);
    }
    return contents;
};
const deserializeAws_restJson1UpdateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.roleAlias != null) {
        contents.roleAlias = __expectString(data.roleAlias);
    }
    if (data.roleAliasArn != null) {
        contents.roleAliasArn = __expectString(data.roleAliasArn);
    }
    return contents;
};
const deserializeAws_restJson1UpdateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.scheduledAuditArn != null) {
        contents.scheduledAuditArn = __expectString(data.scheduledAuditArn);
    }
    return contents;
};
const deserializeAws_restJson1UpdateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.additionalMetricsToRetain != null) {
        contents.additionalMetricsToRetain = deserializeAws_restJson1AdditionalMetricsToRetainList(data.additionalMetricsToRetain, context);
    }
    if (data.additionalMetricsToRetainV2 != null) {
        contents.additionalMetricsToRetainV2 = deserializeAws_restJson1AdditionalMetricsToRetainV2List(data.additionalMetricsToRetainV2, context);
    }
    if (data.alertTargets != null) {
        contents.alertTargets = deserializeAws_restJson1AlertTargets(data.alertTargets, context);
    }
    if (data.behaviors != null) {
        contents.behaviors = deserializeAws_restJson1Behaviors(data.behaviors, context);
    }
    if (data.creationDate != null) {
        contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
    }
    if (data.lastModifiedDate != null) {
        contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
    }
    if (data.securityProfileArn != null) {
        contents.securityProfileArn = __expectString(data.securityProfileArn);
    }
    if (data.securityProfileDescription != null) {
        contents.securityProfileDescription = __expectString(data.securityProfileDescription);
    }
    if (data.securityProfileName != null) {
        contents.securityProfileName = __expectString(data.securityProfileName);
    }
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1UpdateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.description != null) {
        contents.description = __expectString(data.description);
    }
    if (data.streamArn != null) {
        contents.streamArn = __expectString(data.streamArn);
    }
    if (data.streamId != null) {
        contents.streamId = __expectString(data.streamId);
    }
    if (data.streamVersion != null) {
        contents.streamVersion = __expectInt32(data.streamVersion);
    }
    return contents;
};
const deserializeAws_restJson1UpdateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.version != null) {
        contents.version = __expectLong(data.version);
    }
    return contents;
};
const deserializeAws_restJson1UpdateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateThingGroupsForThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1UpdateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.valid != null) {
        contents.valid = __expectBoolean(data.valid);
    }
    if (data.validationErrors != null) {
        contents.validationErrors = deserializeAws_restJson1ValidationErrors(data.validationErrors, context);
    }
    return contents;
};
const deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
const map = __map;
const deserializeAws_restJson1CertificateConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new CertificateConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1CertificateStateExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new CertificateStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1CertificateValidationExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new CertificateValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ConflictingResourceUpdateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1DeleteConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new DeleteConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1IndexNotReadyExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new IndexNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InternalExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InternalFailureExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InternalFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InternalServerExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidAggregationExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InvalidAggregationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidQueryExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InvalidQueryException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidResponseExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InvalidResponseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidStateTransitionExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InvalidStateTransitionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1MalformedPolicyExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new MalformedPolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1NotConfiguredExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new NotConfiguredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1RegistrationCodeValidationExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new RegistrationCodeValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    if (data.resourceArn != null) {
        contents.resourceArn = __expectString(data.resourceArn);
    }
    if (data.resourceId != null) {
        contents.resourceId = __expectString(data.resourceId);
    }
    const exception = new ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceRegistrationFailureExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ResourceRegistrationFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ServiceUnavailableExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1SqlParseExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new SqlParseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1TaskAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new TaskAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ThrottlingExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new TransferAlreadyCompletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1TransferConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new TransferConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1UnauthorizedExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1VersionConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new VersionConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1VersionsLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new VersionsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const serializeAws_restJson1AbortConfig = (input, context) => {
    return {
        ...(input.criteriaList != null && {
            criteriaList: serializeAws_restJson1AbortCriteriaList(input.criteriaList, context),
        }),
    };
};
const serializeAws_restJson1AbortCriteria = (input, context) => {
    return {
        ...(input.action != null && { action: input.action }),
        ...(input.failureType != null && { failureType: input.failureType }),
        ...(input.minNumberOfExecutedThings != null && { minNumberOfExecutedThings: input.minNumberOfExecutedThings }),
        ...(input.thresholdPercentage != null && { thresholdPercentage: __serializeFloat(input.thresholdPercentage) }),
    };
};
const serializeAws_restJson1AbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1AbortCriteria(entry, context);
    });
};
const serializeAws_restJson1Action = (input, context) => {
    return {
        ...(input.cloudwatchAlarm != null && {
            cloudwatchAlarm: serializeAws_restJson1CloudwatchAlarmAction(input.cloudwatchAlarm, context),
        }),
        ...(input.cloudwatchLogs != null && {
            cloudwatchLogs: serializeAws_restJson1CloudwatchLogsAction(input.cloudwatchLogs, context),
        }),
        ...(input.cloudwatchMetric != null && {
            cloudwatchMetric: serializeAws_restJson1CloudwatchMetricAction(input.cloudwatchMetric, context),
        }),
        ...(input.dynamoDB != null && { dynamoDB: serializeAws_restJson1DynamoDBAction(input.dynamoDB, context) }),
        ...(input.dynamoDBv2 != null && { dynamoDBv2: serializeAws_restJson1DynamoDBv2Action(input.dynamoDBv2, context) }),
        ...(input.elasticsearch != null && {
            elasticsearch: serializeAws_restJson1ElasticsearchAction(input.elasticsearch, context),
        }),
        ...(input.firehose != null && { firehose: serializeAws_restJson1FirehoseAction(input.firehose, context) }),
        ...(input.http != null && { http: serializeAws_restJson1HttpAction(input.http, context) }),
        ...(input.iotAnalytics != null && {
            iotAnalytics: serializeAws_restJson1IotAnalyticsAction(input.iotAnalytics, context),
        }),
        ...(input.iotEvents != null && { iotEvents: serializeAws_restJson1IotEventsAction(input.iotEvents, context) }),
        ...(input.iotSiteWise != null && {
            iotSiteWise: serializeAws_restJson1IotSiteWiseAction(input.iotSiteWise, context),
        }),
        ...(input.kafka != null && { kafka: serializeAws_restJson1KafkaAction(input.kafka, context) }),
        ...(input.kinesis != null && { kinesis: serializeAws_restJson1KinesisAction(input.kinesis, context) }),
        ...(input.lambda != null && { lambda: serializeAws_restJson1LambdaAction(input.lambda, context) }),
        ...(input.location != null && { location: serializeAws_restJson1LocationAction(input.location, context) }),
        ...(input.openSearch != null && { openSearch: serializeAws_restJson1OpenSearchAction(input.openSearch, context) }),
        ...(input.republish != null && { republish: serializeAws_restJson1RepublishAction(input.republish, context) }),
        ...(input.s3 != null && { s3: serializeAws_restJson1S3Action(input.s3, context) }),
        ...(input.salesforce != null && { salesforce: serializeAws_restJson1SalesforceAction(input.salesforce, context) }),
        ...(input.sns != null && { sns: serializeAws_restJson1SnsAction(input.sns, context) }),
        ...(input.sqs != null && { sqs: serializeAws_restJson1SqsAction(input.sqs, context) }),
        ...(input.stepFunctions != null && {
            stepFunctions: serializeAws_restJson1StepFunctionsAction(input.stepFunctions, context),
        }),
        ...(input.timestream != null && { timestream: serializeAws_restJson1TimestreamAction(input.timestream, context) }),
    };
};
const serializeAws_restJson1ActionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1Action(entry, context);
    });
};
const serializeAws_restJson1AdditionalMetricsToRetainList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1AdditionalMetricsToRetainV2List = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1MetricToRetain(entry, context);
    });
};
const serializeAws_restJson1AdditionalParameterMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1AddThingsToThingGroupParams = (input, context) => {
    return {
        ...(input.overrideDynamicGroups != null && { overrideDynamicGroups: input.overrideDynamicGroups }),
        ...(input.thingGroupNames != null && {
            thingGroupNames: serializeAws_restJson1ThingGroupNames(input.thingGroupNames, context),
        }),
    };
};
const serializeAws_restJson1AggregationType = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.values != null && { values: serializeAws_restJson1AggregationTypeValues(input.values, context) }),
    };
};
const serializeAws_restJson1AggregationTypeValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1AlertTarget = (input, context) => {
    return {
        ...(input.alertTargetArn != null && { alertTargetArn: input.alertTargetArn }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1AlertTargets = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_restJson1AlertTarget(value, context);
        return acc;
    }, {});
};
const serializeAws_restJson1AssetPropertyTimestamp = (input, context) => {
    return {
        ...(input.offsetInNanos != null && { offsetInNanos: input.offsetInNanos }),
        ...(input.timeInSeconds != null && { timeInSeconds: input.timeInSeconds }),
    };
};
const serializeAws_restJson1AssetPropertyValue = (input, context) => {
    return {
        ...(input.quality != null && { quality: input.quality }),
        ...(input.timestamp != null && {
            timestamp: serializeAws_restJson1AssetPropertyTimestamp(input.timestamp, context),
        }),
        ...(input.value != null && { value: serializeAws_restJson1AssetPropertyVariant(input.value, context) }),
    };
};
const serializeAws_restJson1AssetPropertyValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1AssetPropertyValue(entry, context);
    });
};
const serializeAws_restJson1AssetPropertyVariant = (input, context) => {
    return AssetPropertyVariant.visit(input, {
        booleanValue: (value) => ({ booleanValue: value }),
        doubleValue: (value) => ({ doubleValue: value }),
        integerValue: (value) => ({ integerValue: value }),
        stringValue: (value) => ({ stringValue: value }),
        _: (name, value) => ({ name: value }),
    });
};
const serializeAws_restJson1AttributePayload = (input, context) => {
    return {
        ...(input.attributes != null && { attributes: serializeAws_restJson1Attributes(input.attributes, context) }),
        ...(input.merge != null && { merge: input.merge }),
    };
};
const serializeAws_restJson1Attributes = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1AttributesMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1AuditCheckConfiguration = (input, context) => {
    return {
        ...(input.enabled != null && { enabled: input.enabled }),
    };
};
const serializeAws_restJson1AuditCheckConfigurations = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_restJson1AuditCheckConfiguration(value, context);
        return acc;
    }, {});
};
const serializeAws_restJson1AuditCheckToActionsMapping = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_restJson1MitigationActionNameList(value, context);
        return acc;
    }, {});
};
const serializeAws_restJson1AuditCheckToReasonCodeFilter = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_restJson1ReasonForNonComplianceCodes(value, context);
        return acc;
    }, {});
};
const serializeAws_restJson1AuditMitigationActionsTaskTarget = (input, context) => {
    return {
        ...(input.auditCheckToReasonCodeFilter != null && {
            auditCheckToReasonCodeFilter: serializeAws_restJson1AuditCheckToReasonCodeFilter(input.auditCheckToReasonCodeFilter, context),
        }),
        ...(input.auditTaskId != null && { auditTaskId: input.auditTaskId }),
        ...(input.findingIds != null && { findingIds: serializeAws_restJson1FindingIds(input.findingIds, context) }),
    };
};
const serializeAws_restJson1AuditNotificationTarget = (input, context) => {
    return {
        ...(input.enabled != null && { enabled: input.enabled }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.targetArn != null && { targetArn: input.targetArn }),
    };
};
const serializeAws_restJson1AuditNotificationTargetConfigurations = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_restJson1AuditNotificationTarget(value, context);
        return acc;
    }, {});
};
const serializeAws_restJson1AuthInfo = (input, context) => {
    return {
        ...(input.actionType != null && { actionType: input.actionType }),
        ...(input.resources != null && { resources: serializeAws_restJson1Resources(input.resources, context) }),
    };
};
const serializeAws_restJson1AuthInfos = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1AuthInfo(entry, context);
    });
};
const serializeAws_restJson1AuthorizerConfig = (input, context) => {
    return {
        ...(input.allowAuthorizerOverride != null && { allowAuthorizerOverride: input.allowAuthorizerOverride }),
        ...(input.defaultAuthorizerName != null && { defaultAuthorizerName: input.defaultAuthorizerName }),
    };
};
const serializeAws_restJson1AwsJobAbortConfig = (input, context) => {
    return {
        ...(input.abortCriteriaList != null && {
            abortCriteriaList: serializeAws_restJson1AwsJobAbortCriteriaList(input.abortCriteriaList, context),
        }),
    };
};
const serializeAws_restJson1AwsJobAbortCriteria = (input, context) => {
    return {
        ...(input.action != null && { action: input.action }),
        ...(input.failureType != null && { failureType: input.failureType }),
        ...(input.minNumberOfExecutedThings != null && { minNumberOfExecutedThings: input.minNumberOfExecutedThings }),
        ...(input.thresholdPercentage != null && { thresholdPercentage: __serializeFloat(input.thresholdPercentage) }),
    };
};
const serializeAws_restJson1AwsJobAbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1AwsJobAbortCriteria(entry, context);
    });
};
const serializeAws_restJson1AwsJobExecutionsRolloutConfig = (input, context) => {
    return {
        ...(input.exponentialRate != null && {
            exponentialRate: serializeAws_restJson1AwsJobExponentialRolloutRate(input.exponentialRate, context),
        }),
        ...(input.maximumPerMinute != null && { maximumPerMinute: input.maximumPerMinute }),
    };
};
const serializeAws_restJson1AwsJobExponentialRolloutRate = (input, context) => {
    return {
        ...(input.baseRatePerMinute != null && { baseRatePerMinute: input.baseRatePerMinute }),
        ...(input.incrementFactor != null && { incrementFactor: __serializeFloat(input.incrementFactor) }),
        ...(input.rateIncreaseCriteria != null && {
            rateIncreaseCriteria: serializeAws_restJson1AwsJobRateIncreaseCriteria(input.rateIncreaseCriteria, context),
        }),
    };
};
const serializeAws_restJson1AwsJobPresignedUrlConfig = (input, context) => {
    return {
        ...(input.expiresInSec != null && { expiresInSec: input.expiresInSec }),
    };
};
const serializeAws_restJson1AwsJobRateIncreaseCriteria = (input, context) => {
    return {
        ...(input.numberOfNotifiedThings != null && { numberOfNotifiedThings: input.numberOfNotifiedThings }),
        ...(input.numberOfSucceededThings != null && { numberOfSucceededThings: input.numberOfSucceededThings }),
    };
};
const serializeAws_restJson1AwsJobTimeoutConfig = (input, context) => {
    return {
        ...(input.inProgressTimeoutInMinutes != null && { inProgressTimeoutInMinutes: input.inProgressTimeoutInMinutes }),
    };
};
const serializeAws_restJson1Behavior = (input, context) => {
    return {
        ...(input.criteria != null && { criteria: serializeAws_restJson1BehaviorCriteria(input.criteria, context) }),
        ...(input.metric != null && { metric: input.metric }),
        ...(input.metricDimension != null && {
            metricDimension: serializeAws_restJson1MetricDimension(input.metricDimension, context),
        }),
        ...(input.name != null && { name: input.name }),
        ...(input.suppressAlerts != null && { suppressAlerts: input.suppressAlerts }),
    };
};
const serializeAws_restJson1BehaviorCriteria = (input, context) => {
    return {
        ...(input.comparisonOperator != null && { comparisonOperator: input.comparisonOperator }),
        ...(input.consecutiveDatapointsToAlarm != null && {
            consecutiveDatapointsToAlarm: input.consecutiveDatapointsToAlarm,
        }),
        ...(input.consecutiveDatapointsToClear != null && {
            consecutiveDatapointsToClear: input.consecutiveDatapointsToClear,
        }),
        ...(input.durationSeconds != null && { durationSeconds: input.durationSeconds }),
        ...(input.mlDetectionConfig != null && {
            mlDetectionConfig: serializeAws_restJson1MachineLearningDetectionConfig(input.mlDetectionConfig, context),
        }),
        ...(input.statisticalThreshold != null && {
            statisticalThreshold: serializeAws_restJson1StatisticalThreshold(input.statisticalThreshold, context),
        }),
        ...(input.value != null && { value: serializeAws_restJson1MetricValue(input.value, context) }),
    };
};
const serializeAws_restJson1Behaviors = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1Behavior(entry, context);
    });
};
const serializeAws_restJson1BillingGroupProperties = (input, context) => {
    return {
        ...(input.billingGroupDescription != null && { billingGroupDescription: input.billingGroupDescription }),
    };
};
const serializeAws_restJson1BucketsAggregationType = (input, context) => {
    return {
        ...(input.termsAggregation != null && {
            termsAggregation: serializeAws_restJson1TermsAggregation(input.termsAggregation, context),
        }),
    };
};
const serializeAws_restJson1Cidrs = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1ClientProperties = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1CloudwatchAlarmAction = (input, context) => {
    return {
        ...(input.alarmName != null && { alarmName: input.alarmName }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.stateReason != null && { stateReason: input.stateReason }),
        ...(input.stateValue != null && { stateValue: input.stateValue }),
    };
};
const serializeAws_restJson1CloudwatchLogsAction = (input, context) => {
    return {
        ...(input.batchMode != null && { batchMode: input.batchMode }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1CloudwatchMetricAction = (input, context) => {
    return {
        ...(input.metricName != null && { metricName: input.metricName }),
        ...(input.metricNamespace != null && { metricNamespace: input.metricNamespace }),
        ...(input.metricTimestamp != null && { metricTimestamp: input.metricTimestamp }),
        ...(input.metricUnit != null && { metricUnit: input.metricUnit }),
        ...(input.metricValue != null && { metricValue: input.metricValue }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1CodeSigning = (input, context) => {
    return {
        ...(input.awsSignerJobId != null && { awsSignerJobId: input.awsSignerJobId }),
        ...(input.customCodeSigning != null && {
            customCodeSigning: serializeAws_restJson1CustomCodeSigning(input.customCodeSigning, context),
        }),
        ...(input.startSigningJobParameter != null && {
            startSigningJobParameter: serializeAws_restJson1StartSigningJobParameter(input.startSigningJobParameter, context),
        }),
    };
};
const serializeAws_restJson1CodeSigningCertificateChain = (input, context) => {
    return {
        ...(input.certificateName != null && { certificateName: input.certificateName }),
        ...(input.inlineDocument != null && { inlineDocument: input.inlineDocument }),
    };
};
const serializeAws_restJson1CodeSigningSignature = (input, context) => {
    return {
        ...(input.inlineDocument != null && { inlineDocument: context.base64Encoder(input.inlineDocument) }),
    };
};
const serializeAws_restJson1Configuration = (input, context) => {
    return {
        ...(input.Enabled != null && { Enabled: input.Enabled }),
    };
};
const serializeAws_restJson1CustomCodeSigning = (input, context) => {
    return {
        ...(input.certificateChain != null && {
            certificateChain: serializeAws_restJson1CodeSigningCertificateChain(input.certificateChain, context),
        }),
        ...(input.hashAlgorithm != null && { hashAlgorithm: input.hashAlgorithm }),
        ...(input.signature != null && { signature: serializeAws_restJson1CodeSigningSignature(input.signature, context) }),
        ...(input.signatureAlgorithm != null && { signatureAlgorithm: input.signatureAlgorithm }),
    };
};
const serializeAws_restJson1Destination = (input, context) => {
    return {
        ...(input.s3Destination != null && {
            s3Destination: serializeAws_restJson1S3Destination(input.s3Destination, context),
        }),
    };
};
const serializeAws_restJson1DetailsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1DetectMitigationActionsTaskTarget = (input, context) => {
    return {
        ...(input.behaviorName != null && { behaviorName: input.behaviorName }),
        ...(input.securityProfileName != null && { securityProfileName: input.securityProfileName }),
        ...(input.violationIds != null && {
            violationIds: serializeAws_restJson1TargetViolationIdsForDetectMitigationActions(input.violationIds, context),
        }),
    };
};
const serializeAws_restJson1DetectMitigationActionsToExecuteList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1DimensionStringValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1DynamoDBAction = (input, context) => {
    return {
        ...(input.hashKeyField != null && { hashKeyField: input.hashKeyField }),
        ...(input.hashKeyType != null && { hashKeyType: input.hashKeyType }),
        ...(input.hashKeyValue != null && { hashKeyValue: input.hashKeyValue }),
        ...(input.operation != null && { operation: input.operation }),
        ...(input.payloadField != null && { payloadField: input.payloadField }),
        ...(input.rangeKeyField != null && { rangeKeyField: input.rangeKeyField }),
        ...(input.rangeKeyType != null && { rangeKeyType: input.rangeKeyType }),
        ...(input.rangeKeyValue != null && { rangeKeyValue: input.rangeKeyValue }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.tableName != null && { tableName: input.tableName }),
    };
};
const serializeAws_restJson1DynamoDBv2Action = (input, context) => {
    return {
        ...(input.putItem != null && { putItem: serializeAws_restJson1PutItemInput(input.putItem, context) }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1ElasticsearchAction = (input, context) => {
    return {
        ...(input.endpoint != null && { endpoint: input.endpoint }),
        ...(input.id != null && { id: input.id }),
        ...(input.index != null && { index: input.index }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_restJson1EnableIoTLoggingParams = (input, context) => {
    return {
        ...(input.logLevel != null && { logLevel: input.logLevel }),
        ...(input.roleArnForLogging != null && { roleArnForLogging: input.roleArnForLogging }),
    };
};
const serializeAws_restJson1EventConfigurations = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_restJson1Configuration(value, context);
        return acc;
    }, {});
};
const serializeAws_restJson1ExponentialRolloutRate = (input, context) => {
    return {
        ...(input.baseRatePerMinute != null && { baseRatePerMinute: input.baseRatePerMinute }),
        ...(input.incrementFactor != null && { incrementFactor: __serializeFloat(input.incrementFactor) }),
        ...(input.rateIncreaseCriteria != null && {
            rateIncreaseCriteria: serializeAws_restJson1RateIncreaseCriteria(input.rateIncreaseCriteria, context),
        }),
    };
};
const serializeAws_restJson1Field = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_restJson1Fields = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1Field(entry, context);
    });
};
const serializeAws_restJson1FileLocation = (input, context) => {
    return {
        ...(input.s3Location != null && { s3Location: serializeAws_restJson1S3Location(input.s3Location, context) }),
        ...(input.stream != null && { stream: serializeAws_restJson1_Stream(input.stream, context) }),
    };
};
const serializeAws_restJson1FindingIds = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1FirehoseAction = (input, context) => {
    return {
        ...(input.batchMode != null && { batchMode: input.batchMode }),
        ...(input.deliveryStreamName != null && { deliveryStreamName: input.deliveryStreamName }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.separator != null && { separator: input.separator }),
    };
};
const serializeAws_restJson1HeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1HttpActionHeader(entry, context);
    });
};
const serializeAws_restJson1HttpAction = (input, context) => {
    return {
        ...(input.auth != null && { auth: serializeAws_restJson1HttpAuthorization(input.auth, context) }),
        ...(input.confirmationUrl != null && { confirmationUrl: input.confirmationUrl }),
        ...(input.headers != null && { headers: serializeAws_restJson1HeaderList(input.headers, context) }),
        ...(input.url != null && { url: input.url }),
    };
};
const serializeAws_restJson1HttpActionHeader = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_restJson1HttpAuthorization = (input, context) => {
    return {
        ...(input.sigv4 != null && { sigv4: serializeAws_restJson1SigV4Authorization(input.sigv4, context) }),
    };
};
const serializeAws_restJson1HttpContext = (input, context) => {
    return {
        ...(input.headers != null && { headers: serializeAws_restJson1HttpHeaders(input.headers, context) }),
        ...(input.queryString != null && { queryString: input.queryString }),
    };
};
const serializeAws_restJson1HttpHeaders = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1HttpUrlDestinationConfiguration = (input, context) => {
    return {
        ...(input.confirmationUrl != null && { confirmationUrl: input.confirmationUrl }),
    };
};
const serializeAws_restJson1IndexingFilter = (input, context) => {
    return {
        ...(input.namedShadowNames != null && {
            namedShadowNames: serializeAws_restJson1NamedShadowNamesFilter(input.namedShadowNames, context),
        }),
    };
};
const serializeAws_restJson1IotAnalyticsAction = (input, context) => {
    return {
        ...(input.batchMode != null && { batchMode: input.batchMode }),
        ...(input.channelArn != null && { channelArn: input.channelArn }),
        ...(input.channelName != null && { channelName: input.channelName }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1IotEventsAction = (input, context) => {
    return {
        ...(input.batchMode != null && { batchMode: input.batchMode }),
        ...(input.inputName != null && { inputName: input.inputName }),
        ...(input.messageId != null && { messageId: input.messageId }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1IotSiteWiseAction = (input, context) => {
    return {
        ...(input.putAssetPropertyValueEntries != null && {
            putAssetPropertyValueEntries: serializeAws_restJson1PutAssetPropertyValueEntryList(input.putAssetPropertyValueEntries, context),
        }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1IssuerCertificateIdentifier = (input, context) => {
    return {
        ...(input.issuerCertificateSerialNumber != null && {
            issuerCertificateSerialNumber: input.issuerCertificateSerialNumber,
        }),
        ...(input.issuerCertificateSubject != null && { issuerCertificateSubject: input.issuerCertificateSubject }),
        ...(input.issuerId != null && { issuerId: input.issuerId }),
    };
};
const serializeAws_restJson1JobExecutionsRetryConfig = (input, context) => {
    return {
        ...(input.criteriaList != null && {
            criteriaList: serializeAws_restJson1RetryCriteriaList(input.criteriaList, context),
        }),
    };
};
const serializeAws_restJson1JobExecutionsRolloutConfig = (input, context) => {
    return {
        ...(input.exponentialRate != null && {
            exponentialRate: serializeAws_restJson1ExponentialRolloutRate(input.exponentialRate, context),
        }),
        ...(input.maximumPerMinute != null && { maximumPerMinute: input.maximumPerMinute }),
    };
};
const serializeAws_restJson1JobTargets = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1KafkaAction = (input, context) => {
    return {
        ...(input.clientProperties != null && {
            clientProperties: serializeAws_restJson1ClientProperties(input.clientProperties, context),
        }),
        ...(input.destinationArn != null && { destinationArn: input.destinationArn }),
        ...(input.key != null && { key: input.key }),
        ...(input.partition != null && { partition: input.partition }),
        ...(input.topic != null && { topic: input.topic }),
    };
};
const serializeAws_restJson1KinesisAction = (input, context) => {
    return {
        ...(input.partitionKey != null && { partitionKey: input.partitionKey }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.streamName != null && { streamName: input.streamName }),
    };
};
const serializeAws_restJson1LambdaAction = (input, context) => {
    return {
        ...(input.functionArn != null && { functionArn: input.functionArn }),
    };
};
const serializeAws_restJson1LocationAction = (input, context) => {
    return {
        ...(input.deviceId != null && { deviceId: input.deviceId }),
        ...(input.latitude != null && { latitude: input.latitude }),
        ...(input.longitude != null && { longitude: input.longitude }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.timestamp != null && { timestamp: serializeAws_restJson1LocationTimestamp(input.timestamp, context) }),
        ...(input.trackerName != null && { trackerName: input.trackerName }),
    };
};
const serializeAws_restJson1LocationTimestamp = (input, context) => {
    return {
        ...(input.unit != null && { unit: input.unit }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_restJson1LoggingOptionsPayload = (input, context) => {
    return {
        ...(input.logLevel != null && { logLevel: input.logLevel }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1LogTarget = (input, context) => {
    return {
        ...(input.targetName != null && { targetName: input.targetName }),
        ...(input.targetType != null && { targetType: input.targetType }),
    };
};
const serializeAws_restJson1MachineLearningDetectionConfig = (input, context) => {
    return {
        ...(input.confidenceLevel != null && { confidenceLevel: input.confidenceLevel }),
    };
};
const serializeAws_restJson1MaintenanceWindow = (input, context) => {
    return {
        ...(input.durationInMinutes != null && { durationInMinutes: input.durationInMinutes }),
        ...(input.startTime != null && { startTime: input.startTime }),
    };
};
const serializeAws_restJson1MaintenanceWindows = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1MaintenanceWindow(entry, context);
    });
};
const serializeAws_restJson1MetricDimension = (input, context) => {
    return {
        ...(input.dimensionName != null && { dimensionName: input.dimensionName }),
        ...(input.operator != null && { operator: input.operator }),
    };
};
const serializeAws_restJson1MetricToRetain = (input, context) => {
    return {
        ...(input.metric != null && { metric: input.metric }),
        ...(input.metricDimension != null && {
            metricDimension: serializeAws_restJson1MetricDimension(input.metricDimension, context),
        }),
    };
};
const serializeAws_restJson1MetricValue = (input, context) => {
    return {
        ...(input.cidrs != null && { cidrs: serializeAws_restJson1Cidrs(input.cidrs, context) }),
        ...(input.count != null && { count: input.count }),
        ...(input.number != null && { number: __serializeFloat(input.number) }),
        ...(input.numbers != null && { numbers: serializeAws_restJson1NumberList(input.numbers, context) }),
        ...(input.ports != null && { ports: serializeAws_restJson1Ports(input.ports, context) }),
        ...(input.strings != null && { strings: serializeAws_restJson1StringList(input.strings, context) }),
    };
};
const serializeAws_restJson1MitigationActionNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1MitigationActionParams = (input, context) => {
    return {
        ...(input.addThingsToThingGroupParams != null && {
            addThingsToThingGroupParams: serializeAws_restJson1AddThingsToThingGroupParams(input.addThingsToThingGroupParams, context),
        }),
        ...(input.enableIoTLoggingParams != null && {
            enableIoTLoggingParams: serializeAws_restJson1EnableIoTLoggingParams(input.enableIoTLoggingParams, context),
        }),
        ...(input.publishFindingToSnsParams != null && {
            publishFindingToSnsParams: serializeAws_restJson1PublishFindingToSnsParams(input.publishFindingToSnsParams, context),
        }),
        ...(input.replaceDefaultPolicyVersionParams != null && {
            replaceDefaultPolicyVersionParams: serializeAws_restJson1ReplaceDefaultPolicyVersionParams(input.replaceDefaultPolicyVersionParams, context),
        }),
        ...(input.updateCACertificateParams != null && {
            updateCACertificateParams: serializeAws_restJson1UpdateCACertificateParams(input.updateCACertificateParams, context),
        }),
        ...(input.updateDeviceCertificateParams != null && {
            updateDeviceCertificateParams: serializeAws_restJson1UpdateDeviceCertificateParams(input.updateDeviceCertificateParams, context),
        }),
    };
};
const serializeAws_restJson1MqttContext = (input, context) => {
    return {
        ...(input.clientId != null && { clientId: input.clientId }),
        ...(input.password != null && { password: context.base64Encoder(input.password) }),
        ...(input.username != null && { username: input.username }),
    };
};
const serializeAws_restJson1MqttHeaders = (input, context) => {
    return {
        ...(input.contentType != null && { contentType: input.contentType }),
        ...(input.correlationData != null && { correlationData: input.correlationData }),
        ...(input.messageExpiry != null && { messageExpiry: input.messageExpiry }),
        ...(input.payloadFormatIndicator != null && { payloadFormatIndicator: input.payloadFormatIndicator }),
        ...(input.responseTopic != null && { responseTopic: input.responseTopic }),
        ...(input.userProperties != null && {
            userProperties: serializeAws_restJson1UserProperties(input.userProperties, context),
        }),
    };
};
const serializeAws_restJson1NamedShadowNamesFilter = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1NumberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return __serializeFloat(entry);
    });
};
const serializeAws_restJson1OpenSearchAction = (input, context) => {
    return {
        ...(input.endpoint != null && { endpoint: input.endpoint }),
        ...(input.id != null && { id: input.id }),
        ...(input.index != null && { index: input.index }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_restJson1OTAUpdateFile = (input, context) => {
    return {
        ...(input.attributes != null && { attributes: serializeAws_restJson1AttributesMap(input.attributes, context) }),
        ...(input.codeSigning != null && { codeSigning: serializeAws_restJson1CodeSigning(input.codeSigning, context) }),
        ...(input.fileLocation != null && {
            fileLocation: serializeAws_restJson1FileLocation(input.fileLocation, context),
        }),
        ...(input.fileName != null && { fileName: input.fileName }),
        ...(input.fileType != null && { fileType: input.fileType }),
        ...(input.fileVersion != null && { fileVersion: input.fileVersion }),
    };
};
const serializeAws_restJson1OTAUpdateFiles = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1OTAUpdateFile(entry, context);
    });
};
const serializeAws_restJson1ParameterMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1Parameters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1PercentList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return __serializeFloat(entry);
    });
};
const serializeAws_restJson1PolicyNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1PolicyVersionIdentifier = (input, context) => {
    return {
        ...(input.policyName != null && { policyName: input.policyName }),
        ...(input.policyVersionId != null && { policyVersionId: input.policyVersionId }),
    };
};
const serializeAws_restJson1Ports = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1PresignedUrlConfig = (input, context) => {
    return {
        ...(input.expiresInSec != null && { expiresInSec: input.expiresInSec }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1Protocols = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1ProvisioningHook = (input, context) => {
    return {
        ...(input.payloadVersion != null && { payloadVersion: input.payloadVersion }),
        ...(input.targetArn != null && { targetArn: input.targetArn }),
    };
};
const serializeAws_restJson1PublicKeyMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1PublishFindingToSnsParams = (input, context) => {
    return {
        ...(input.topicArn != null && { topicArn: input.topicArn }),
    };
};
const serializeAws_restJson1PutAssetPropertyValueEntry = (input, context) => {
    return {
        ...(input.assetId != null && { assetId: input.assetId }),
        ...(input.entryId != null && { entryId: input.entryId }),
        ...(input.propertyAlias != null && { propertyAlias: input.propertyAlias }),
        ...(input.propertyId != null && { propertyId: input.propertyId }),
        ...(input.propertyValues != null && {
            propertyValues: serializeAws_restJson1AssetPropertyValueList(input.propertyValues, context),
        }),
    };
};
const serializeAws_restJson1PutAssetPropertyValueEntryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1PutAssetPropertyValueEntry(entry, context);
    });
};
const serializeAws_restJson1PutItemInput = (input, context) => {
    return {
        ...(input.tableName != null && { tableName: input.tableName }),
    };
};
const serializeAws_restJson1RateIncreaseCriteria = (input, context) => {
    return {
        ...(input.numberOfNotifiedThings != null && { numberOfNotifiedThings: input.numberOfNotifiedThings }),
        ...(input.numberOfSucceededThings != null && { numberOfSucceededThings: input.numberOfSucceededThings }),
    };
};
const serializeAws_restJson1ReasonForNonComplianceCodes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1RegistrationConfig = (input, context) => {
    return {
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.templateBody != null && { templateBody: input.templateBody }),
        ...(input.templateName != null && { templateName: input.templateName }),
    };
};
const serializeAws_restJson1ReplaceDefaultPolicyVersionParams = (input, context) => {
    return {
        ...(input.templateName != null && { templateName: input.templateName }),
    };
};
const serializeAws_restJson1RepublishAction = (input, context) => {
    return {
        ...(input.headers != null && { headers: serializeAws_restJson1MqttHeaders(input.headers, context) }),
        ...(input.qos != null && { qos: input.qos }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.topic != null && { topic: input.topic }),
    };
};
const serializeAws_restJson1ResourceIdentifier = (input, context) => {
    return {
        ...(input.account != null && { account: input.account }),
        ...(input.caCertificateId != null && { caCertificateId: input.caCertificateId }),
        ...(input.clientId != null && { clientId: input.clientId }),
        ...(input.cognitoIdentityPoolId != null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
        ...(input.deviceCertificateArn != null && { deviceCertificateArn: input.deviceCertificateArn }),
        ...(input.deviceCertificateId != null && { deviceCertificateId: input.deviceCertificateId }),
        ...(input.iamRoleArn != null && { iamRoleArn: input.iamRoleArn }),
        ...(input.issuerCertificateIdentifier != null && {
            issuerCertificateIdentifier: serializeAws_restJson1IssuerCertificateIdentifier(input.issuerCertificateIdentifier, context),
        }),
        ...(input.policyVersionIdentifier != null && {
            policyVersionIdentifier: serializeAws_restJson1PolicyVersionIdentifier(input.policyVersionIdentifier, context),
        }),
        ...(input.roleAliasArn != null && { roleAliasArn: input.roleAliasArn }),
    };
};
const serializeAws_restJson1Resources = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1RetryCriteria = (input, context) => {
    return {
        ...(input.failureType != null && { failureType: input.failureType }),
        ...(input.numberOfRetries != null && { numberOfRetries: input.numberOfRetries }),
    };
};
const serializeAws_restJson1RetryCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1RetryCriteria(entry, context);
    });
};
const serializeAws_restJson1S3Action = (input, context) => {
    return {
        ...(input.bucketName != null && { bucketName: input.bucketName }),
        ...(input.cannedAcl != null && { cannedAcl: input.cannedAcl }),
        ...(input.key != null && { key: input.key }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_restJson1S3Destination = (input, context) => {
    return {
        ...(input.bucket != null && { bucket: input.bucket }),
        ...(input.prefix != null && { prefix: input.prefix }),
    };
};
const serializeAws_restJson1S3Location = (input, context) => {
    return {
        ...(input.bucket != null && { bucket: input.bucket }),
        ...(input.key != null && { key: input.key }),
        ...(input.version != null && { version: input.version }),
    };
};
const serializeAws_restJson1SalesforceAction = (input, context) => {
    return {
        ...(input.token != null && { token: input.token }),
        ...(input.url != null && { url: input.url }),
    };
};
const serializeAws_restJson1SchedulingConfig = (input, context) => {
    return {
        ...(input.endBehavior != null && { endBehavior: input.endBehavior }),
        ...(input.endTime != null && { endTime: input.endTime }),
        ...(input.maintenanceWindows != null && {
            maintenanceWindows: serializeAws_restJson1MaintenanceWindows(input.maintenanceWindows, context),
        }),
        ...(input.startTime != null && { startTime: input.startTime }),
    };
};
const serializeAws_restJson1SearchableAttributes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1SecurityGroupList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1ServerCertificateArns = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1SigningProfileParameter = (input, context) => {
    return {
        ...(input.certificateArn != null && { certificateArn: input.certificateArn }),
        ...(input.certificatePathOnDevice != null && { certificatePathOnDevice: input.certificatePathOnDevice }),
        ...(input.platform != null && { platform: input.platform }),
    };
};
const serializeAws_restJson1SigV4Authorization = (input, context) => {
    return {
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.serviceName != null && { serviceName: input.serviceName }),
        ...(input.signingRegion != null && { signingRegion: input.signingRegion }),
    };
};
const serializeAws_restJson1SnsAction = (input, context) => {
    return {
        ...(input.messageFormat != null && { messageFormat: input.messageFormat }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.targetArn != null && { targetArn: input.targetArn }),
    };
};
const serializeAws_restJson1SqsAction = (input, context) => {
    return {
        ...(input.queueUrl != null && { queueUrl: input.queueUrl }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.useBase64 != null && { useBase64: input.useBase64 }),
    };
};
const serializeAws_restJson1StartSigningJobParameter = (input, context) => {
    return {
        ...(input.destination != null && { destination: serializeAws_restJson1Destination(input.destination, context) }),
        ...(input.signingProfileName != null && { signingProfileName: input.signingProfileName }),
        ...(input.signingProfileParameter != null && {
            signingProfileParameter: serializeAws_restJson1SigningProfileParameter(input.signingProfileParameter, context),
        }),
    };
};
const serializeAws_restJson1StatisticalThreshold = (input, context) => {
    return {
        ...(input.statistic != null && { statistic: input.statistic }),
    };
};
const serializeAws_restJson1StepFunctionsAction = (input, context) => {
    return {
        ...(input.executionNamePrefix != null && { executionNamePrefix: input.executionNamePrefix }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.stateMachineName != null && { stateMachineName: input.stateMachineName }),
    };
};
const serializeAws_restJson1_Stream = (input, context) => {
    return {
        ...(input.fileId != null && { fileId: input.fileId }),
        ...(input.streamId != null && { streamId: input.streamId }),
    };
};
const serializeAws_restJson1StreamFile = (input, context) => {
    return {
        ...(input.fileId != null && { fileId: input.fileId }),
        ...(input.s3Location != null && { s3Location: serializeAws_restJson1S3Location(input.s3Location, context) }),
    };
};
const serializeAws_restJson1StreamFiles = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1StreamFile(entry, context);
    });
};
const serializeAws_restJson1StringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1SubnetIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1Tag = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_restJson1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1Tag(entry, context);
    });
};
const serializeAws_restJson1TargetAuditCheckNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1Targets = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1TargetViolationIdsForDetectMitigationActions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1TermsAggregation = (input, context) => {
    return {
        ...(input.maxBuckets != null && { maxBuckets: input.maxBuckets }),
    };
};
const serializeAws_restJson1ThingGroupIndexingConfiguration = (input, context) => {
    return {
        ...(input.customFields != null && { customFields: serializeAws_restJson1Fields(input.customFields, context) }),
        ...(input.managedFields != null && { managedFields: serializeAws_restJson1Fields(input.managedFields, context) }),
        ...(input.thingGroupIndexingMode != null && { thingGroupIndexingMode: input.thingGroupIndexingMode }),
    };
};
const serializeAws_restJson1ThingGroupList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1ThingGroupNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1ThingGroupProperties = (input, context) => {
    return {
        ...(input.attributePayload != null && {
            attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
        }),
        ...(input.thingGroupDescription != null && { thingGroupDescription: input.thingGroupDescription }),
    };
};
const serializeAws_restJson1ThingIndexingConfiguration = (input, context) => {
    return {
        ...(input.customFields != null && { customFields: serializeAws_restJson1Fields(input.customFields, context) }),
        ...(input.deviceDefenderIndexingMode != null && { deviceDefenderIndexingMode: input.deviceDefenderIndexingMode }),
        ...(input.filter != null && { filter: serializeAws_restJson1IndexingFilter(input.filter, context) }),
        ...(input.managedFields != null && { managedFields: serializeAws_restJson1Fields(input.managedFields, context) }),
        ...(input.namedShadowIndexingMode != null && { namedShadowIndexingMode: input.namedShadowIndexingMode }),
        ...(input.thingConnectivityIndexingMode != null && {
            thingConnectivityIndexingMode: input.thingConnectivityIndexingMode,
        }),
        ...(input.thingIndexingMode != null && { thingIndexingMode: input.thingIndexingMode }),
    };
};
const serializeAws_restJson1ThingTypeProperties = (input, context) => {
    return {
        ...(input.searchableAttributes != null && {
            searchableAttributes: serializeAws_restJson1SearchableAttributes(input.searchableAttributes, context),
        }),
        ...(input.thingTypeDescription != null && { thingTypeDescription: input.thingTypeDescription }),
    };
};
const serializeAws_restJson1TimeoutConfig = (input, context) => {
    return {
        ...(input.inProgressTimeoutInMinutes != null && { inProgressTimeoutInMinutes: input.inProgressTimeoutInMinutes }),
    };
};
const serializeAws_restJson1TimestreamAction = (input, context) => {
    return {
        ...(input.databaseName != null && { databaseName: input.databaseName }),
        ...(input.dimensions != null && {
            dimensions: serializeAws_restJson1TimestreamDimensionList(input.dimensions, context),
        }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.tableName != null && { tableName: input.tableName }),
        ...(input.timestamp != null && { timestamp: serializeAws_restJson1TimestreamTimestamp(input.timestamp, context) }),
    };
};
const serializeAws_restJson1TimestreamDimension = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_restJson1TimestreamDimensionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1TimestreamDimension(entry, context);
    });
};
const serializeAws_restJson1TimestreamTimestamp = (input, context) => {
    return {
        ...(input.unit != null && { unit: input.unit }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_restJson1TlsContext = (input, context) => {
    return {
        ...(input.serverName != null && { serverName: input.serverName }),
    };
};
const serializeAws_restJson1TopicRuleDestinationConfiguration = (input, context) => {
    return {
        ...(input.httpUrlConfiguration != null && {
            httpUrlConfiguration: serializeAws_restJson1HttpUrlDestinationConfiguration(input.httpUrlConfiguration, context),
        }),
        ...(input.vpcConfiguration != null && {
            vpcConfiguration: serializeAws_restJson1VpcDestinationConfiguration(input.vpcConfiguration, context),
        }),
    };
};
const serializeAws_restJson1TopicRulePayload = (input, context) => {
    return {
        ...(input.actions != null && { actions: serializeAws_restJson1ActionList(input.actions, context) }),
        ...(input.awsIotSqlVersion != null && { awsIotSqlVersion: input.awsIotSqlVersion }),
        ...(input.description != null && { description: input.description }),
        ...(input.errorAction != null && { errorAction: serializeAws_restJson1Action(input.errorAction, context) }),
        ...(input.ruleDisabled != null && { ruleDisabled: input.ruleDisabled }),
        ...(input.sql != null && { sql: input.sql }),
    };
};
const serializeAws_restJson1UpdateCACertificateParams = (input, context) => {
    return {
        ...(input.action != null && { action: input.action }),
    };
};
const serializeAws_restJson1UpdateDeviceCertificateParams = (input, context) => {
    return {
        ...(input.action != null && { action: input.action }),
    };
};
const serializeAws_restJson1UserProperties = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1UserProperty(entry, context);
    });
};
const serializeAws_restJson1UserProperty = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_restJson1ViolationEventOccurrenceRange = (input, context) => {
    return {
        ...(input.endTime != null && { endTime: Math.round(input.endTime.getTime() / 1000) }),
        ...(input.startTime != null && { startTime: Math.round(input.startTime.getTime() / 1000) }),
    };
};
const serializeAws_restJson1VpcDestinationConfiguration = (input, context) => {
    return {
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.securityGroups != null && {
            securityGroups: serializeAws_restJson1SecurityGroupList(input.securityGroups, context),
        }),
        ...(input.subnetIds != null && { subnetIds: serializeAws_restJson1SubnetIdList(input.subnetIds, context) }),
        ...(input.vpcId != null && { vpcId: input.vpcId }),
    };
};
const deserializeAws_restJson1AbortConfig = (output, context) => {
    return {
        criteriaList: output.criteriaList != null ? deserializeAws_restJson1AbortCriteriaList(output.criteriaList, context) : undefined,
    };
};
const deserializeAws_restJson1AbortCriteria = (output, context) => {
    return {
        action: __expectString(output.action),
        failureType: __expectString(output.failureType),
        minNumberOfExecutedThings: __expectInt32(output.minNumberOfExecutedThings),
        thresholdPercentage: __limitedParseDouble(output.thresholdPercentage),
    };
};
const deserializeAws_restJson1AbortCriteriaList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AbortCriteria(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1Action = (output, context) => {
    return {
        cloudwatchAlarm: output.cloudwatchAlarm != null
            ? deserializeAws_restJson1CloudwatchAlarmAction(output.cloudwatchAlarm, context)
            : undefined,
        cloudwatchLogs: output.cloudwatchLogs != null
            ? deserializeAws_restJson1CloudwatchLogsAction(output.cloudwatchLogs, context)
            : undefined,
        cloudwatchMetric: output.cloudwatchMetric != null
            ? deserializeAws_restJson1CloudwatchMetricAction(output.cloudwatchMetric, context)
            : undefined,
        dynamoDB: output.dynamoDB != null ? deserializeAws_restJson1DynamoDBAction(output.dynamoDB, context) : undefined,
        dynamoDBv2: output.dynamoDBv2 != null ? deserializeAws_restJson1DynamoDBv2Action(output.dynamoDBv2, context) : undefined,
        elasticsearch: output.elasticsearch != null
            ? deserializeAws_restJson1ElasticsearchAction(output.elasticsearch, context)
            : undefined,
        firehose: output.firehose != null ? deserializeAws_restJson1FirehoseAction(output.firehose, context) : undefined,
        http: output.http != null ? deserializeAws_restJson1HttpAction(output.http, context) : undefined,
        iotAnalytics: output.iotAnalytics != null
            ? deserializeAws_restJson1IotAnalyticsAction(output.iotAnalytics, context)
            : undefined,
        iotEvents: output.iotEvents != null ? deserializeAws_restJson1IotEventsAction(output.iotEvents, context) : undefined,
        iotSiteWise: output.iotSiteWise != null ? deserializeAws_restJson1IotSiteWiseAction(output.iotSiteWise, context) : undefined,
        kafka: output.kafka != null ? deserializeAws_restJson1KafkaAction(output.kafka, context) : undefined,
        kinesis: output.kinesis != null ? deserializeAws_restJson1KinesisAction(output.kinesis, context) : undefined,
        lambda: output.lambda != null ? deserializeAws_restJson1LambdaAction(output.lambda, context) : undefined,
        location: output.location != null ? deserializeAws_restJson1LocationAction(output.location, context) : undefined,
        openSearch: output.openSearch != null ? deserializeAws_restJson1OpenSearchAction(output.openSearch, context) : undefined,
        republish: output.republish != null ? deserializeAws_restJson1RepublishAction(output.republish, context) : undefined,
        s3: output.s3 != null ? deserializeAws_restJson1S3Action(output.s3, context) : undefined,
        salesforce: output.salesforce != null ? deserializeAws_restJson1SalesforceAction(output.salesforce, context) : undefined,
        sns: output.sns != null ? deserializeAws_restJson1SnsAction(output.sns, context) : undefined,
        sqs: output.sqs != null ? deserializeAws_restJson1SqsAction(output.sqs, context) : undefined,
        stepFunctions: output.stepFunctions != null
            ? deserializeAws_restJson1StepFunctionsAction(output.stepFunctions, context)
            : undefined,
        timestream: output.timestream != null ? deserializeAws_restJson1TimestreamAction(output.timestream, context) : undefined,
    };
};
const deserializeAws_restJson1ActionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Action(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ActiveViolation = (output, context) => {
    return {
        behavior: output.behavior != null ? deserializeAws_restJson1Behavior(output.behavior, context) : undefined,
        lastViolationTime: output.lastViolationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastViolationTime)))
            : undefined,
        lastViolationValue: output.lastViolationValue != null
            ? deserializeAws_restJson1MetricValue(output.lastViolationValue, context)
            : undefined,
        securityProfileName: __expectString(output.securityProfileName),
        thingName: __expectString(output.thingName),
        verificationState: __expectString(output.verificationState),
        verificationStateDescription: __expectString(output.verificationStateDescription),
        violationEventAdditionalInfo: output.violationEventAdditionalInfo != null
            ? deserializeAws_restJson1ViolationEventAdditionalInfo(output.violationEventAdditionalInfo, context)
            : undefined,
        violationId: __expectString(output.violationId),
        violationStartTime: output.violationStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.violationStartTime)))
            : undefined,
    };
};
const deserializeAws_restJson1ActiveViolations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ActiveViolation(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AdditionalMetricsToRetainList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1AdditionalMetricsToRetainV2List = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MetricToRetain(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AdditionalParameterMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1AddThingsToThingGroupParams = (output, context) => {
    return {
        overrideDynamicGroups: __expectBoolean(output.overrideDynamicGroups),
        thingGroupNames: output.thingGroupNames != null
            ? deserializeAws_restJson1ThingGroupNames(output.thingGroupNames, context)
            : undefined,
    };
};
const deserializeAws_restJson1AggregationType = (output, context) => {
    return {
        name: __expectString(output.name),
        values: output.values != null ? deserializeAws_restJson1AggregationTypeValues(output.values, context) : undefined,
    };
};
const deserializeAws_restJson1AggregationTypeValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1AlertTarget = (output, context) => {
    return {
        alertTargetArn: __expectString(output.alertTargetArn),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1AlertTargets = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1AlertTarget(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1Allowed = (output, context) => {
    return {
        policies: output.policies != null ? deserializeAws_restJson1Policies(output.policies, context) : undefined,
    };
};
const deserializeAws_restJson1AssetPropertyTimestamp = (output, context) => {
    return {
        offsetInNanos: __expectString(output.offsetInNanos),
        timeInSeconds: __expectString(output.timeInSeconds),
    };
};
const deserializeAws_restJson1AssetPropertyValue = (output, context) => {
    return {
        quality: __expectString(output.quality),
        timestamp: output.timestamp != null ? deserializeAws_restJson1AssetPropertyTimestamp(output.timestamp, context) : undefined,
        value: output.value != null
            ? deserializeAws_restJson1AssetPropertyVariant(__expectUnion(output.value), context)
            : undefined,
    };
};
const deserializeAws_restJson1AssetPropertyValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AssetPropertyValue(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AssetPropertyVariant = (output, context) => {
    if (__expectString(output.booleanValue) !== undefined) {
        return { booleanValue: __expectString(output.booleanValue) };
    }
    if (__expectString(output.doubleValue) !== undefined) {
        return { doubleValue: __expectString(output.doubleValue) };
    }
    if (__expectString(output.integerValue) !== undefined) {
        return { integerValue: __expectString(output.integerValue) };
    }
    if (__expectString(output.stringValue) !== undefined) {
        return { stringValue: __expectString(output.stringValue) };
    }
    return { $unknown: Object.entries(output)[0] };
};
const deserializeAws_restJson1AttributePayload = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_restJson1Attributes(output.attributes, context) : undefined,
        merge: __expectBoolean(output.merge),
    };
};
const deserializeAws_restJson1Attributes = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1AttributesMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1AuditCheckConfiguration = (output, context) => {
    return {
        enabled: __expectBoolean(output.enabled),
    };
};
const deserializeAws_restJson1AuditCheckConfigurations = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1AuditCheckConfiguration(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1AuditCheckDetails = (output, context) => {
    return {
        checkCompliant: __expectBoolean(output.checkCompliant),
        checkRunStatus: __expectString(output.checkRunStatus),
        errorCode: __expectString(output.errorCode),
        message: __expectString(output.message),
        nonCompliantResourcesCount: __expectLong(output.nonCompliantResourcesCount),
        suppressedNonCompliantResourcesCount: __expectLong(output.suppressedNonCompliantResourcesCount),
        totalResourcesCount: __expectLong(output.totalResourcesCount),
    };
};
const deserializeAws_restJson1AuditCheckToActionsMapping = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1MitigationActionNameList(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1AuditCheckToReasonCodeFilter = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1ReasonForNonComplianceCodes(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1AuditDetails = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1AuditCheckDetails(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1AuditFinding = (output, context) => {
    return {
        checkName: __expectString(output.checkName),
        findingId: __expectString(output.findingId),
        findingTime: output.findingTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.findingTime)))
            : undefined,
        isSuppressed: __expectBoolean(output.isSuppressed),
        nonCompliantResource: output.nonCompliantResource != null
            ? deserializeAws_restJson1NonCompliantResource(output.nonCompliantResource, context)
            : undefined,
        reasonForNonCompliance: __expectString(output.reasonForNonCompliance),
        reasonForNonComplianceCode: __expectString(output.reasonForNonComplianceCode),
        relatedResources: output.relatedResources != null
            ? deserializeAws_restJson1RelatedResources(output.relatedResources, context)
            : undefined,
        severity: __expectString(output.severity),
        taskId: __expectString(output.taskId),
        taskStartTime: output.taskStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.taskStartTime)))
            : undefined,
    };
};
const deserializeAws_restJson1AuditFindings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditFinding(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AuditMitigationActionExecutionMetadata = (output, context) => {
    return {
        actionId: __expectString(output.actionId),
        actionName: __expectString(output.actionName),
        endTime: output.endTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.endTime))) : undefined,
        errorCode: __expectString(output.errorCode),
        findingId: __expectString(output.findingId),
        message: __expectString(output.message),
        startTime: output.startTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startTime))) : undefined,
        status: __expectString(output.status),
        taskId: __expectString(output.taskId),
    };
};
const deserializeAws_restJson1AuditMitigationActionExecutionMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditMitigationActionExecutionMetadata(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AuditMitigationActionsTaskMetadata = (output, context) => {
    return {
        startTime: output.startTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startTime))) : undefined,
        taskId: __expectString(output.taskId),
        taskStatus: __expectString(output.taskStatus),
    };
};
const deserializeAws_restJson1AuditMitigationActionsTaskMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditMitigationActionsTaskMetadata(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AuditMitigationActionsTaskStatistics = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1TaskStatisticsForAuditCheck(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1AuditMitigationActionsTaskTarget = (output, context) => {
    return {
        auditCheckToReasonCodeFilter: output.auditCheckToReasonCodeFilter != null
            ? deserializeAws_restJson1AuditCheckToReasonCodeFilter(output.auditCheckToReasonCodeFilter, context)
            : undefined,
        auditTaskId: __expectString(output.auditTaskId),
        findingIds: output.findingIds != null ? deserializeAws_restJson1FindingIds(output.findingIds, context) : undefined,
    };
};
const deserializeAws_restJson1AuditNotificationTarget = (output, context) => {
    return {
        enabled: __expectBoolean(output.enabled),
        roleArn: __expectString(output.roleArn),
        targetArn: __expectString(output.targetArn),
    };
};
const deserializeAws_restJson1AuditNotificationTargetConfigurations = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1AuditNotificationTarget(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1AuditSuppression = (output, context) => {
    return {
        checkName: __expectString(output.checkName),
        description: __expectString(output.description),
        expirationDate: output.expirationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.expirationDate)))
            : undefined,
        resourceIdentifier: output.resourceIdentifier != null
            ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
            : undefined,
        suppressIndefinitely: __expectBoolean(output.suppressIndefinitely),
    };
};
const deserializeAws_restJson1AuditSuppressionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditSuppression(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AuditTaskMetadata = (output, context) => {
    return {
        taskId: __expectString(output.taskId),
        taskStatus: __expectString(output.taskStatus),
        taskType: __expectString(output.taskType),
    };
};
const deserializeAws_restJson1AuditTaskMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuditTaskMetadata(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AuthInfo = (output, context) => {
    return {
        actionType: __expectString(output.actionType),
        resources: output.resources != null ? deserializeAws_restJson1Resources(output.resources, context) : undefined,
    };
};
const deserializeAws_restJson1AuthorizerConfig = (output, context) => {
    return {
        allowAuthorizerOverride: __expectBoolean(output.allowAuthorizerOverride),
        defaultAuthorizerName: __expectString(output.defaultAuthorizerName),
    };
};
const deserializeAws_restJson1AuthorizerDescription = (output, context) => {
    return {
        authorizerArn: __expectString(output.authorizerArn),
        authorizerFunctionArn: __expectString(output.authorizerFunctionArn),
        authorizerName: __expectString(output.authorizerName),
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        enableCachingForHttp: __expectBoolean(output.enableCachingForHttp),
        lastModifiedDate: output.lastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
            : undefined,
        signingDisabled: __expectBoolean(output.signingDisabled),
        status: __expectString(output.status),
        tokenKeyName: __expectString(output.tokenKeyName),
        tokenSigningPublicKeys: output.tokenSigningPublicKeys != null
            ? deserializeAws_restJson1PublicKeyMap(output.tokenSigningPublicKeys, context)
            : undefined,
    };
};
const deserializeAws_restJson1Authorizers = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuthorizerSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AuthorizerSummary = (output, context) => {
    return {
        authorizerArn: __expectString(output.authorizerArn),
        authorizerName: __expectString(output.authorizerName),
    };
};
const deserializeAws_restJson1AuthResult = (output, context) => {
    return {
        allowed: output.allowed != null ? deserializeAws_restJson1Allowed(output.allowed, context) : undefined,
        authDecision: __expectString(output.authDecision),
        authInfo: output.authInfo != null ? deserializeAws_restJson1AuthInfo(output.authInfo, context) : undefined,
        denied: output.denied != null ? deserializeAws_restJson1Denied(output.denied, context) : undefined,
        missingContextValues: output.missingContextValues != null
            ? deserializeAws_restJson1MissingContextValues(output.missingContextValues, context)
            : undefined,
    };
};
const deserializeAws_restJson1AuthResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuthResult(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AwsJobExecutionsRolloutConfig = (output, context) => {
    return {
        exponentialRate: output.exponentialRate != null
            ? deserializeAws_restJson1AwsJobExponentialRolloutRate(output.exponentialRate, context)
            : undefined,
        maximumPerMinute: __expectInt32(output.maximumPerMinute),
    };
};
const deserializeAws_restJson1AwsJobExponentialRolloutRate = (output, context) => {
    return {
        baseRatePerMinute: __expectInt32(output.baseRatePerMinute),
        incrementFactor: __limitedParseDouble(output.incrementFactor),
        rateIncreaseCriteria: output.rateIncreaseCriteria != null
            ? deserializeAws_restJson1AwsJobRateIncreaseCriteria(output.rateIncreaseCriteria, context)
            : undefined,
    };
};
const deserializeAws_restJson1AwsJobPresignedUrlConfig = (output, context) => {
    return {
        expiresInSec: __expectLong(output.expiresInSec),
    };
};
const deserializeAws_restJson1AwsJobRateIncreaseCriteria = (output, context) => {
    return {
        numberOfNotifiedThings: __expectInt32(output.numberOfNotifiedThings),
        numberOfSucceededThings: __expectInt32(output.numberOfSucceededThings),
    };
};
const deserializeAws_restJson1Behavior = (output, context) => {
    return {
        criteria: output.criteria != null ? deserializeAws_restJson1BehaviorCriteria(output.criteria, context) : undefined,
        metric: __expectString(output.metric),
        metricDimension: output.metricDimension != null
            ? deserializeAws_restJson1MetricDimension(output.metricDimension, context)
            : undefined,
        name: __expectString(output.name),
        suppressAlerts: __expectBoolean(output.suppressAlerts),
    };
};
const deserializeAws_restJson1BehaviorCriteria = (output, context) => {
    return {
        comparisonOperator: __expectString(output.comparisonOperator),
        consecutiveDatapointsToAlarm: __expectInt32(output.consecutiveDatapointsToAlarm),
        consecutiveDatapointsToClear: __expectInt32(output.consecutiveDatapointsToClear),
        durationSeconds: __expectInt32(output.durationSeconds),
        mlDetectionConfig: output.mlDetectionConfig != null
            ? deserializeAws_restJson1MachineLearningDetectionConfig(output.mlDetectionConfig, context)
            : undefined,
        statisticalThreshold: output.statisticalThreshold != null
            ? deserializeAws_restJson1StatisticalThreshold(output.statisticalThreshold, context)
            : undefined,
        value: output.value != null ? deserializeAws_restJson1MetricValue(output.value, context) : undefined,
    };
};
const deserializeAws_restJson1BehaviorModelTrainingSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1BehaviorModelTrainingSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1BehaviorModelTrainingSummary = (output, context) => {
    return {
        behaviorName: __expectString(output.behaviorName),
        datapointsCollectionPercentage: __limitedParseDouble(output.datapointsCollectionPercentage),
        lastModelRefreshDate: output.lastModelRefreshDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModelRefreshDate)))
            : undefined,
        modelStatus: __expectString(output.modelStatus),
        securityProfileName: __expectString(output.securityProfileName),
        trainingDataCollectionStartDate: output.trainingDataCollectionStartDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.trainingDataCollectionStartDate)))
            : undefined,
    };
};
const deserializeAws_restJson1Behaviors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Behavior(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1BillingGroupMetadata = (output, context) => {
    return {
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
    };
};
const deserializeAws_restJson1BillingGroupNameAndArnList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1GroupNameAndArn(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1BillingGroupProperties = (output, context) => {
    return {
        billingGroupDescription: __expectString(output.billingGroupDescription),
    };
};
const deserializeAws_restJson1Bucket = (output, context) => {
    return {
        count: __expectInt32(output.count),
        keyValue: __expectString(output.keyValue),
    };
};
const deserializeAws_restJson1Buckets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Bucket(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1CACertificate = (output, context) => {
    return {
        certificateArn: __expectString(output.certificateArn),
        certificateId: __expectString(output.certificateId),
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        status: __expectString(output.status),
    };
};
const deserializeAws_restJson1CACertificateDescription = (output, context) => {
    return {
        autoRegistrationStatus: __expectString(output.autoRegistrationStatus),
        certificateArn: __expectString(output.certificateArn),
        certificateId: __expectString(output.certificateId),
        certificateMode: __expectString(output.certificateMode),
        certificatePem: __expectString(output.certificatePem),
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        customerVersion: __expectInt32(output.customerVersion),
        generationId: __expectString(output.generationId),
        lastModifiedDate: output.lastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
            : undefined,
        ownedBy: __expectString(output.ownedBy),
        status: __expectString(output.status),
        validity: output.validity != null ? deserializeAws_restJson1CertificateValidity(output.validity, context) : undefined,
    };
};
const deserializeAws_restJson1CACertificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1CACertificate(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1Certificate = (output, context) => {
    return {
        certificateArn: __expectString(output.certificateArn),
        certificateId: __expectString(output.certificateId),
        certificateMode: __expectString(output.certificateMode),
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        status: __expectString(output.status),
    };
};
const deserializeAws_restJson1CertificateDescription = (output, context) => {
    return {
        caCertificateId: __expectString(output.caCertificateId),
        certificateArn: __expectString(output.certificateArn),
        certificateId: __expectString(output.certificateId),
        certificateMode: __expectString(output.certificateMode),
        certificatePem: __expectString(output.certificatePem),
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        customerVersion: __expectInt32(output.customerVersion),
        generationId: __expectString(output.generationId),
        lastModifiedDate: output.lastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
            : undefined,
        ownedBy: __expectString(output.ownedBy),
        previousOwnedBy: __expectString(output.previousOwnedBy),
        status: __expectString(output.status),
        transferData: output.transferData != null ? deserializeAws_restJson1TransferData(output.transferData, context) : undefined,
        validity: output.validity != null ? deserializeAws_restJson1CertificateValidity(output.validity, context) : undefined,
    };
};
const deserializeAws_restJson1Certificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Certificate(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1CertificateValidity = (output, context) => {
    return {
        notAfter: output.notAfter != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.notAfter))) : undefined,
        notBefore: output.notBefore != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.notBefore))) : undefined,
    };
};
const deserializeAws_restJson1Cidrs = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ClientProperties = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1CloudwatchAlarmAction = (output, context) => {
    return {
        alarmName: __expectString(output.alarmName),
        roleArn: __expectString(output.roleArn),
        stateReason: __expectString(output.stateReason),
        stateValue: __expectString(output.stateValue),
    };
};
const deserializeAws_restJson1CloudwatchLogsAction = (output, context) => {
    return {
        batchMode: __expectBoolean(output.batchMode),
        logGroupName: __expectString(output.logGroupName),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1CloudwatchMetricAction = (output, context) => {
    return {
        metricName: __expectString(output.metricName),
        metricNamespace: __expectString(output.metricNamespace),
        metricTimestamp: __expectString(output.metricTimestamp),
        metricUnit: __expectString(output.metricUnit),
        metricValue: __expectString(output.metricValue),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1CodeSigning = (output, context) => {
    return {
        awsSignerJobId: __expectString(output.awsSignerJobId),
        customCodeSigning: output.customCodeSigning != null
            ? deserializeAws_restJson1CustomCodeSigning(output.customCodeSigning, context)
            : undefined,
        startSigningJobParameter: output.startSigningJobParameter != null
            ? deserializeAws_restJson1StartSigningJobParameter(output.startSigningJobParameter, context)
            : undefined,
    };
};
const deserializeAws_restJson1CodeSigningCertificateChain = (output, context) => {
    return {
        certificateName: __expectString(output.certificateName),
        inlineDocument: __expectString(output.inlineDocument),
    };
};
const deserializeAws_restJson1CodeSigningSignature = (output, context) => {
    return {
        inlineDocument: output.inlineDocument != null ? context.base64Decoder(output.inlineDocument) : undefined,
    };
};
const deserializeAws_restJson1Configuration = (output, context) => {
    return {
        Enabled: __expectBoolean(output.Enabled),
    };
};
const deserializeAws_restJson1CustomCodeSigning = (output, context) => {
    return {
        certificateChain: output.certificateChain != null
            ? deserializeAws_restJson1CodeSigningCertificateChain(output.certificateChain, context)
            : undefined,
        hashAlgorithm: __expectString(output.hashAlgorithm),
        signature: output.signature != null ? deserializeAws_restJson1CodeSigningSignature(output.signature, context) : undefined,
        signatureAlgorithm: __expectString(output.signatureAlgorithm),
    };
};
const deserializeAws_restJson1Denied = (output, context) => {
    return {
        explicitDeny: output.explicitDeny != null ? deserializeAws_restJson1ExplicitDeny(output.explicitDeny, context) : undefined,
        implicitDeny: output.implicitDeny != null ? deserializeAws_restJson1ImplicitDeny(output.implicitDeny, context) : undefined,
    };
};
const deserializeAws_restJson1Destination = (output, context) => {
    return {
        s3Destination: output.s3Destination != null ? deserializeAws_restJson1S3Destination(output.s3Destination, context) : undefined,
    };
};
const deserializeAws_restJson1DetailsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1DetectMitigationActionExecution = (output, context) => {
    return {
        actionName: __expectString(output.actionName),
        errorCode: __expectString(output.errorCode),
        executionEndDate: output.executionEndDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.executionEndDate)))
            : undefined,
        executionStartDate: output.executionStartDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.executionStartDate)))
            : undefined,
        message: __expectString(output.message),
        status: __expectString(output.status),
        taskId: __expectString(output.taskId),
        thingName: __expectString(output.thingName),
        violationId: __expectString(output.violationId),
    };
};
const deserializeAws_restJson1DetectMitigationActionExecutionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DetectMitigationActionExecution(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1DetectMitigationActionsTaskStatistics = (output, context) => {
    return {
        actionsExecuted: __expectLong(output.actionsExecuted),
        actionsFailed: __expectLong(output.actionsFailed),
        actionsSkipped: __expectLong(output.actionsSkipped),
    };
};
const deserializeAws_restJson1DetectMitigationActionsTaskSummary = (output, context) => {
    return {
        actionsDefinition: output.actionsDefinition != null
            ? deserializeAws_restJson1MitigationActionList(output.actionsDefinition, context)
            : undefined,
        onlyActiveViolationsIncluded: __expectBoolean(output.onlyActiveViolationsIncluded),
        suppressedAlertsIncluded: __expectBoolean(output.suppressedAlertsIncluded),
        target: output.target != null
            ? deserializeAws_restJson1DetectMitigationActionsTaskTarget(output.target, context)
            : undefined,
        taskEndTime: output.taskEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.taskEndTime)))
            : undefined,
        taskId: __expectString(output.taskId),
        taskStartTime: output.taskStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.taskStartTime)))
            : undefined,
        taskStatistics: output.taskStatistics != null
            ? deserializeAws_restJson1DetectMitigationActionsTaskStatistics(output.taskStatistics, context)
            : undefined,
        taskStatus: __expectString(output.taskStatus),
        violationEventOccurrenceRange: output.violationEventOccurrenceRange != null
            ? deserializeAws_restJson1ViolationEventOccurrenceRange(output.violationEventOccurrenceRange, context)
            : undefined,
    };
};
const deserializeAws_restJson1DetectMitigationActionsTaskSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DetectMitigationActionsTaskSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1DetectMitigationActionsTaskTarget = (output, context) => {
    return {
        behaviorName: __expectString(output.behaviorName),
        securityProfileName: __expectString(output.securityProfileName),
        violationIds: output.violationIds != null
            ? deserializeAws_restJson1TargetViolationIdsForDetectMitigationActions(output.violationIds, context)
            : undefined,
    };
};
const deserializeAws_restJson1DimensionNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1DimensionStringValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1DocumentParameter = (output, context) => {
    return {
        description: __expectString(output.description),
        example: __expectString(output.example),
        key: __expectString(output.key),
        optional: __expectBoolean(output.optional),
        regex: __expectString(output.regex),
    };
};
const deserializeAws_restJson1DocumentParameters = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DocumentParameter(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1DomainConfigurations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DomainConfigurationSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1DomainConfigurationSummary = (output, context) => {
    return {
        domainConfigurationArn: __expectString(output.domainConfigurationArn),
        domainConfigurationName: __expectString(output.domainConfigurationName),
        serviceType: __expectString(output.serviceType),
    };
};
const deserializeAws_restJson1DynamoDBAction = (output, context) => {
    return {
        hashKeyField: __expectString(output.hashKeyField),
        hashKeyType: __expectString(output.hashKeyType),
        hashKeyValue: __expectString(output.hashKeyValue),
        operation: __expectString(output.operation),
        payloadField: __expectString(output.payloadField),
        rangeKeyField: __expectString(output.rangeKeyField),
        rangeKeyType: __expectString(output.rangeKeyType),
        rangeKeyValue: __expectString(output.rangeKeyValue),
        roleArn: __expectString(output.roleArn),
        tableName: __expectString(output.tableName),
    };
};
const deserializeAws_restJson1DynamoDBv2Action = (output, context) => {
    return {
        putItem: output.putItem != null ? deserializeAws_restJson1PutItemInput(output.putItem, context) : undefined,
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1EffectivePolicies = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1EffectivePolicy(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1EffectivePolicy = (output, context) => {
    return {
        policyArn: __expectString(output.policyArn),
        policyDocument: __expectString(output.policyDocument),
        policyName: __expectString(output.policyName),
    };
};
const deserializeAws_restJson1ElasticsearchAction = (output, context) => {
    return {
        endpoint: __expectString(output.endpoint),
        id: __expectString(output.id),
        index: __expectString(output.index),
        roleArn: __expectString(output.roleArn),
        type: __expectString(output.type),
    };
};
const deserializeAws_restJson1EnableIoTLoggingParams = (output, context) => {
    return {
        logLevel: __expectString(output.logLevel),
        roleArnForLogging: __expectString(output.roleArnForLogging),
    };
};
const deserializeAws_restJson1Environments = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ErrorInfo = (output, context) => {
    return {
        code: __expectString(output.code),
        message: __expectString(output.message),
    };
};
const deserializeAws_restJson1EventConfigurations = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1Configuration(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1ExplicitDeny = (output, context) => {
    return {
        policies: output.policies != null ? deserializeAws_restJson1Policies(output.policies, context) : undefined,
    };
};
const deserializeAws_restJson1ExponentialRolloutRate = (output, context) => {
    return {
        baseRatePerMinute: __expectInt32(output.baseRatePerMinute),
        incrementFactor: __limitedParseDouble(output.incrementFactor),
        rateIncreaseCriteria: output.rateIncreaseCriteria != null
            ? deserializeAws_restJson1RateIncreaseCriteria(output.rateIncreaseCriteria, context)
            : undefined,
    };
};
const deserializeAws_restJson1Field = (output, context) => {
    return {
        name: __expectString(output.name),
        type: __expectString(output.type),
    };
};
const deserializeAws_restJson1Fields = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Field(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1FileLocation = (output, context) => {
    return {
        s3Location: output.s3Location != null ? deserializeAws_restJson1S3Location(output.s3Location, context) : undefined,
        stream: output.stream != null ? deserializeAws_restJson1_Stream(output.stream, context) : undefined,
    };
};
const deserializeAws_restJson1FindingIds = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1FirehoseAction = (output, context) => {
    return {
        batchMode: __expectBoolean(output.batchMode),
        deliveryStreamName: __expectString(output.deliveryStreamName),
        roleArn: __expectString(output.roleArn),
        separator: __expectString(output.separator),
    };
};
const deserializeAws_restJson1FleetMetricNameAndArn = (output, context) => {
    return {
        metricArn: __expectString(output.metricArn),
        metricName: __expectString(output.metricName),
    };
};
const deserializeAws_restJson1FleetMetricNameAndArnList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1FleetMetricNameAndArn(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1GroupNameAndArn = (output, context) => {
    return {
        groupArn: __expectString(output.groupArn),
        groupName: __expectString(output.groupName),
    };
};
const deserializeAws_restJson1HeaderList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1HttpActionHeader(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1HttpAction = (output, context) => {
    return {
        auth: output.auth != null ? deserializeAws_restJson1HttpAuthorization(output.auth, context) : undefined,
        confirmationUrl: __expectString(output.confirmationUrl),
        headers: output.headers != null ? deserializeAws_restJson1HeaderList(output.headers, context) : undefined,
        url: __expectString(output.url),
    };
};
const deserializeAws_restJson1HttpActionHeader = (output, context) => {
    return {
        key: __expectString(output.key),
        value: __expectString(output.value),
    };
};
const deserializeAws_restJson1HttpAuthorization = (output, context) => {
    return {
        sigv4: output.sigv4 != null ? deserializeAws_restJson1SigV4Authorization(output.sigv4, context) : undefined,
    };
};
const deserializeAws_restJson1HttpUrlDestinationProperties = (output, context) => {
    return {
        confirmationUrl: __expectString(output.confirmationUrl),
    };
};
const deserializeAws_restJson1HttpUrlDestinationSummary = (output, context) => {
    return {
        confirmationUrl: __expectString(output.confirmationUrl),
    };
};
const deserializeAws_restJson1ImplicitDeny = (output, context) => {
    return {
        policies: output.policies != null ? deserializeAws_restJson1Policies(output.policies, context) : undefined,
    };
};
const deserializeAws_restJson1IndexingFilter = (output, context) => {
    return {
        namedShadowNames: output.namedShadowNames != null
            ? deserializeAws_restJson1NamedShadowNamesFilter(output.namedShadowNames, context)
            : undefined,
    };
};
const deserializeAws_restJson1IndexNamesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1IotAnalyticsAction = (output, context) => {
    return {
        batchMode: __expectBoolean(output.batchMode),
        channelArn: __expectString(output.channelArn),
        channelName: __expectString(output.channelName),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1IotEventsAction = (output, context) => {
    return {
        batchMode: __expectBoolean(output.batchMode),
        inputName: __expectString(output.inputName),
        messageId: __expectString(output.messageId),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1IotSiteWiseAction = (output, context) => {
    return {
        putAssetPropertyValueEntries: output.putAssetPropertyValueEntries != null
            ? deserializeAws_restJson1PutAssetPropertyValueEntryList(output.putAssetPropertyValueEntries, context)
            : undefined,
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1IssuerCertificateIdentifier = (output, context) => {
    return {
        issuerCertificateSerialNumber: __expectString(output.issuerCertificateSerialNumber),
        issuerCertificateSubject: __expectString(output.issuerCertificateSubject),
        issuerId: __expectString(output.issuerId),
    };
};
const deserializeAws_restJson1Job = (output, context) => {
    return {
        abortConfig: output.abortConfig != null ? deserializeAws_restJson1AbortConfig(output.abortConfig, context) : undefined,
        comment: __expectString(output.comment),
        completedAt: output.completedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.completedAt)))
            : undefined,
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        description: __expectString(output.description),
        documentParameters: output.documentParameters != null
            ? deserializeAws_restJson1ParameterMap(output.documentParameters, context)
            : undefined,
        forceCanceled: __expectBoolean(output.forceCanceled),
        isConcurrent: __expectBoolean(output.isConcurrent),
        jobArn: __expectString(output.jobArn),
        jobExecutionsRetryConfig: output.jobExecutionsRetryConfig != null
            ? deserializeAws_restJson1JobExecutionsRetryConfig(output.jobExecutionsRetryConfig, context)
            : undefined,
        jobExecutionsRolloutConfig: output.jobExecutionsRolloutConfig != null
            ? deserializeAws_restJson1JobExecutionsRolloutConfig(output.jobExecutionsRolloutConfig, context)
            : undefined,
        jobId: __expectString(output.jobId),
        jobProcessDetails: output.jobProcessDetails != null
            ? deserializeAws_restJson1JobProcessDetails(output.jobProcessDetails, context)
            : undefined,
        jobTemplateArn: __expectString(output.jobTemplateArn),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
            : undefined,
        namespaceId: __expectString(output.namespaceId),
        presignedUrlConfig: output.presignedUrlConfig != null
            ? deserializeAws_restJson1PresignedUrlConfig(output.presignedUrlConfig, context)
            : undefined,
        reasonCode: __expectString(output.reasonCode),
        scheduledJobRollouts: output.scheduledJobRollouts != null
            ? deserializeAws_restJson1ScheduledJobRolloutList(output.scheduledJobRollouts, context)
            : undefined,
        schedulingConfig: output.schedulingConfig != null
            ? deserializeAws_restJson1SchedulingConfig(output.schedulingConfig, context)
            : undefined,
        status: __expectString(output.status),
        targetSelection: __expectString(output.targetSelection),
        targets: output.targets != null ? deserializeAws_restJson1JobTargets(output.targets, context) : undefined,
        timeoutConfig: output.timeoutConfig != null ? deserializeAws_restJson1TimeoutConfig(output.timeoutConfig, context) : undefined,
    };
};
const deserializeAws_restJson1JobExecution = (output, context) => {
    return {
        approximateSecondsBeforeTimedOut: __expectLong(output.approximateSecondsBeforeTimedOut),
        executionNumber: __expectLong(output.executionNumber),
        forceCanceled: __expectBoolean(output.forceCanceled),
        jobId: __expectString(output.jobId),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
            : undefined,
        queuedAt: output.queuedAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.queuedAt))) : undefined,
        startedAt: output.startedAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startedAt))) : undefined,
        status: __expectString(output.status),
        statusDetails: output.statusDetails != null
            ? deserializeAws_restJson1JobExecutionStatusDetails(output.statusDetails, context)
            : undefined,
        thingArn: __expectString(output.thingArn),
        versionNumber: __expectLong(output.versionNumber),
    };
};
const deserializeAws_restJson1JobExecutionsRetryConfig = (output, context) => {
    return {
        criteriaList: output.criteriaList != null ? deserializeAws_restJson1RetryCriteriaList(output.criteriaList, context) : undefined,
    };
};
const deserializeAws_restJson1JobExecutionsRolloutConfig = (output, context) => {
    return {
        exponentialRate: output.exponentialRate != null
            ? deserializeAws_restJson1ExponentialRolloutRate(output.exponentialRate, context)
            : undefined,
        maximumPerMinute: __expectInt32(output.maximumPerMinute),
    };
};
const deserializeAws_restJson1JobExecutionStatusDetails = (output, context) => {
    return {
        detailsMap: output.detailsMap != null ? deserializeAws_restJson1DetailsMap(output.detailsMap, context) : undefined,
    };
};
const deserializeAws_restJson1JobExecutionSummary = (output, context) => {
    return {
        executionNumber: __expectLong(output.executionNumber),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
            : undefined,
        queuedAt: output.queuedAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.queuedAt))) : undefined,
        retryAttempt: __expectInt32(output.retryAttempt),
        startedAt: output.startedAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startedAt))) : undefined,
        status: __expectString(output.status),
    };
};
const deserializeAws_restJson1JobExecutionSummaryForJob = (output, context) => {
    return {
        jobExecutionSummary: output.jobExecutionSummary != null
            ? deserializeAws_restJson1JobExecutionSummary(output.jobExecutionSummary, context)
            : undefined,
        thingArn: __expectString(output.thingArn),
    };
};
const deserializeAws_restJson1JobExecutionSummaryForJobList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1JobExecutionSummaryForJob(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1JobExecutionSummaryForThing = (output, context) => {
    return {
        jobExecutionSummary: output.jobExecutionSummary != null
            ? deserializeAws_restJson1JobExecutionSummary(output.jobExecutionSummary, context)
            : undefined,
        jobId: __expectString(output.jobId),
    };
};
const deserializeAws_restJson1JobExecutionSummaryForThingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1JobExecutionSummaryForThing(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1JobProcessDetails = (output, context) => {
    return {
        numberOfCanceledThings: __expectInt32(output.numberOfCanceledThings),
        numberOfFailedThings: __expectInt32(output.numberOfFailedThings),
        numberOfInProgressThings: __expectInt32(output.numberOfInProgressThings),
        numberOfQueuedThings: __expectInt32(output.numberOfQueuedThings),
        numberOfRejectedThings: __expectInt32(output.numberOfRejectedThings),
        numberOfRemovedThings: __expectInt32(output.numberOfRemovedThings),
        numberOfSucceededThings: __expectInt32(output.numberOfSucceededThings),
        numberOfTimedOutThings: __expectInt32(output.numberOfTimedOutThings),
        processingTargets: output.processingTargets != null
            ? deserializeAws_restJson1ProcessingTargetNameList(output.processingTargets, context)
            : undefined,
    };
};
const deserializeAws_restJson1JobSummary = (output, context) => {
    return {
        completedAt: output.completedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.completedAt)))
            : undefined,
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        isConcurrent: __expectBoolean(output.isConcurrent),
        jobArn: __expectString(output.jobArn),
        jobId: __expectString(output.jobId),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
            : undefined,
        status: __expectString(output.status),
        targetSelection: __expectString(output.targetSelection),
        thingGroupId: __expectString(output.thingGroupId),
    };
};
const deserializeAws_restJson1JobSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1JobSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1JobTargets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1JobTemplateSummary = (output, context) => {
    return {
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        description: __expectString(output.description),
        jobTemplateArn: __expectString(output.jobTemplateArn),
        jobTemplateId: __expectString(output.jobTemplateId),
    };
};
const deserializeAws_restJson1JobTemplateSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1JobTemplateSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1KafkaAction = (output, context) => {
    return {
        clientProperties: output.clientProperties != null
            ? deserializeAws_restJson1ClientProperties(output.clientProperties, context)
            : undefined,
        destinationArn: __expectString(output.destinationArn),
        key: __expectString(output.key),
        partition: __expectString(output.partition),
        topic: __expectString(output.topic),
    };
};
const deserializeAws_restJson1KeyPair = (output, context) => {
    return {
        PrivateKey: __expectString(output.PrivateKey),
        PublicKey: __expectString(output.PublicKey),
    };
};
const deserializeAws_restJson1KinesisAction = (output, context) => {
    return {
        partitionKey: __expectString(output.partitionKey),
        roleArn: __expectString(output.roleArn),
        streamName: __expectString(output.streamName),
    };
};
const deserializeAws_restJson1LambdaAction = (output, context) => {
    return {
        functionArn: __expectString(output.functionArn),
    };
};
const deserializeAws_restJson1LocationAction = (output, context) => {
    return {
        deviceId: __expectString(output.deviceId),
        latitude: __expectString(output.latitude),
        longitude: __expectString(output.longitude),
        roleArn: __expectString(output.roleArn),
        timestamp: output.timestamp != null ? deserializeAws_restJson1LocationTimestamp(output.timestamp, context) : undefined,
        trackerName: __expectString(output.trackerName),
    };
};
const deserializeAws_restJson1LocationTimestamp = (output, context) => {
    return {
        unit: __expectString(output.unit),
        value: __expectString(output.value),
    };
};
const deserializeAws_restJson1LogTarget = (output, context) => {
    return {
        targetName: __expectString(output.targetName),
        targetType: __expectString(output.targetType),
    };
};
const deserializeAws_restJson1LogTargetConfiguration = (output, context) => {
    return {
        logLevel: __expectString(output.logLevel),
        logTarget: output.logTarget != null ? deserializeAws_restJson1LogTarget(output.logTarget, context) : undefined,
    };
};
const deserializeAws_restJson1LogTargetConfigurations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1LogTargetConfiguration(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1MachineLearningDetectionConfig = (output, context) => {
    return {
        confidenceLevel: __expectString(output.confidenceLevel),
    };
};
const deserializeAws_restJson1MaintenanceWindow = (output, context) => {
    return {
        durationInMinutes: __expectInt32(output.durationInMinutes),
        startTime: __expectString(output.startTime),
    };
};
const deserializeAws_restJson1MaintenanceWindows = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MaintenanceWindow(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ManagedJobTemplatesSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ManagedJobTemplateSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ManagedJobTemplateSummary = (output, context) => {
    return {
        description: __expectString(output.description),
        environments: output.environments != null ? deserializeAws_restJson1Environments(output.environments, context) : undefined,
        templateArn: __expectString(output.templateArn),
        templateName: __expectString(output.templateName),
        templateVersion: __expectString(output.templateVersion),
    };
};
const deserializeAws_restJson1MetricDatum = (output, context) => {
    return {
        timestamp: output.timestamp != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.timestamp))) : undefined,
        value: output.value != null ? deserializeAws_restJson1MetricValue(output.value, context) : undefined,
    };
};
const deserializeAws_restJson1MetricDatumList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MetricDatum(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1MetricDimension = (output, context) => {
    return {
        dimensionName: __expectString(output.dimensionName),
        operator: __expectString(output.operator),
    };
};
const deserializeAws_restJson1MetricNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1MetricToRetain = (output, context) => {
    return {
        metric: __expectString(output.metric),
        metricDimension: output.metricDimension != null
            ? deserializeAws_restJson1MetricDimension(output.metricDimension, context)
            : undefined,
    };
};
const deserializeAws_restJson1MetricValue = (output, context) => {
    return {
        cidrs: output.cidrs != null ? deserializeAws_restJson1Cidrs(output.cidrs, context) : undefined,
        count: __expectLong(output.count),
        number: __limitedParseDouble(output.number),
        numbers: output.numbers != null ? deserializeAws_restJson1NumberList(output.numbers, context) : undefined,
        ports: output.ports != null ? deserializeAws_restJson1Ports(output.ports, context) : undefined,
        strings: output.strings != null ? deserializeAws_restJson1StringList(output.strings, context) : undefined,
    };
};
const deserializeAws_restJson1MissingContextValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1MitigationAction = (output, context) => {
    return {
        actionParams: output.actionParams != null
            ? deserializeAws_restJson1MitigationActionParams(output.actionParams, context)
            : undefined,
        id: __expectString(output.id),
        name: __expectString(output.name),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1MitigationActionIdentifier = (output, context) => {
    return {
        actionArn: __expectString(output.actionArn),
        actionName: __expectString(output.actionName),
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
    };
};
const deserializeAws_restJson1MitigationActionIdentifierList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MitigationActionIdentifier(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1MitigationActionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1MitigationAction(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1MitigationActionNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1MitigationActionParams = (output, context) => {
    return {
        addThingsToThingGroupParams: output.addThingsToThingGroupParams != null
            ? deserializeAws_restJson1AddThingsToThingGroupParams(output.addThingsToThingGroupParams, context)
            : undefined,
        enableIoTLoggingParams: output.enableIoTLoggingParams != null
            ? deserializeAws_restJson1EnableIoTLoggingParams(output.enableIoTLoggingParams, context)
            : undefined,
        publishFindingToSnsParams: output.publishFindingToSnsParams != null
            ? deserializeAws_restJson1PublishFindingToSnsParams(output.publishFindingToSnsParams, context)
            : undefined,
        replaceDefaultPolicyVersionParams: output.replaceDefaultPolicyVersionParams != null
            ? deserializeAws_restJson1ReplaceDefaultPolicyVersionParams(output.replaceDefaultPolicyVersionParams, context)
            : undefined,
        updateCACertificateParams: output.updateCACertificateParams != null
            ? deserializeAws_restJson1UpdateCACertificateParams(output.updateCACertificateParams, context)
            : undefined,
        updateDeviceCertificateParams: output.updateDeviceCertificateParams != null
            ? deserializeAws_restJson1UpdateDeviceCertificateParams(output.updateDeviceCertificateParams, context)
            : undefined,
    };
};
const deserializeAws_restJson1MqttHeaders = (output, context) => {
    return {
        contentType: __expectString(output.contentType),
        correlationData: __expectString(output.correlationData),
        messageExpiry: __expectString(output.messageExpiry),
        payloadFormatIndicator: __expectString(output.payloadFormatIndicator),
        responseTopic: __expectString(output.responseTopic),
        userProperties: output.userProperties != null
            ? deserializeAws_restJson1UserProperties(output.userProperties, context)
            : undefined,
    };
};
const deserializeAws_restJson1NamedShadowNamesFilter = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1NonCompliantResource = (output, context) => {
    return {
        additionalInfo: output.additionalInfo != null ? deserializeAws_restJson1StringMap(output.additionalInfo, context) : undefined,
        resourceIdentifier: output.resourceIdentifier != null
            ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
            : undefined,
        resourceType: __expectString(output.resourceType),
    };
};
const deserializeAws_restJson1NumberList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __limitedParseDouble(entry);
    });
    return retVal;
};
const deserializeAws_restJson1OpenSearchAction = (output, context) => {
    return {
        endpoint: __expectString(output.endpoint),
        id: __expectString(output.id),
        index: __expectString(output.index),
        roleArn: __expectString(output.roleArn),
        type: __expectString(output.type),
    };
};
const deserializeAws_restJson1OTAUpdateFile = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_restJson1AttributesMap(output.attributes, context) : undefined,
        codeSigning: output.codeSigning != null ? deserializeAws_restJson1CodeSigning(output.codeSigning, context) : undefined,
        fileLocation: output.fileLocation != null ? deserializeAws_restJson1FileLocation(output.fileLocation, context) : undefined,
        fileName: __expectString(output.fileName),
        fileType: __expectInt32(output.fileType),
        fileVersion: __expectString(output.fileVersion),
    };
};
const deserializeAws_restJson1OTAUpdateFiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1OTAUpdateFile(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1OTAUpdateInfo = (output, context) => {
    return {
        additionalParameters: output.additionalParameters != null
            ? deserializeAws_restJson1AdditionalParameterMap(output.additionalParameters, context)
            : undefined,
        awsIotJobArn: __expectString(output.awsIotJobArn),
        awsIotJobId: __expectString(output.awsIotJobId),
        awsJobExecutionsRolloutConfig: output.awsJobExecutionsRolloutConfig != null
            ? deserializeAws_restJson1AwsJobExecutionsRolloutConfig(output.awsJobExecutionsRolloutConfig, context)
            : undefined,
        awsJobPresignedUrlConfig: output.awsJobPresignedUrlConfig != null
            ? deserializeAws_restJson1AwsJobPresignedUrlConfig(output.awsJobPresignedUrlConfig, context)
            : undefined,
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        description: __expectString(output.description),
        errorInfo: output.errorInfo != null ? deserializeAws_restJson1ErrorInfo(output.errorInfo, context) : undefined,
        lastModifiedDate: output.lastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
            : undefined,
        otaUpdateArn: __expectString(output.otaUpdateArn),
        otaUpdateFiles: output.otaUpdateFiles != null
            ? deserializeAws_restJson1OTAUpdateFiles(output.otaUpdateFiles, context)
            : undefined,
        otaUpdateId: __expectString(output.otaUpdateId),
        otaUpdateStatus: __expectString(output.otaUpdateStatus),
        protocols: output.protocols != null ? deserializeAws_restJson1Protocols(output.protocols, context) : undefined,
        targetSelection: __expectString(output.targetSelection),
        targets: output.targets != null ? deserializeAws_restJson1Targets(output.targets, context) : undefined,
    };
};
const deserializeAws_restJson1OTAUpdatesSummary = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1OTAUpdateSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1OTAUpdateSummary = (output, context) => {
    return {
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        otaUpdateArn: __expectString(output.otaUpdateArn),
        otaUpdateId: __expectString(output.otaUpdateId),
    };
};
const deserializeAws_restJson1OutgoingCertificate = (output, context) => {
    return {
        certificateArn: __expectString(output.certificateArn),
        certificateId: __expectString(output.certificateId),
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        transferDate: output.transferDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.transferDate)))
            : undefined,
        transferMessage: __expectString(output.transferMessage),
        transferredTo: __expectString(output.transferredTo),
    };
};
const deserializeAws_restJson1OutgoingCertificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1OutgoingCertificate(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ParameterMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1Percentiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PercentPair(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1PercentPair = (output, context) => {
    return {
        percent: __limitedParseDouble(output.percent),
        value: __limitedParseDouble(output.value),
    };
};
const deserializeAws_restJson1Policies = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Policy(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1Policy = (output, context) => {
    return {
        policyArn: __expectString(output.policyArn),
        policyName: __expectString(output.policyName),
    };
};
const deserializeAws_restJson1PolicyDocuments = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1PolicyTargets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1PolicyVersion = (output, context) => {
    return {
        createDate: output.createDate != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createDate))) : undefined,
        isDefaultVersion: __expectBoolean(output.isDefaultVersion),
        versionId: __expectString(output.versionId),
    };
};
const deserializeAws_restJson1PolicyVersionIdentifier = (output, context) => {
    return {
        policyName: __expectString(output.policyName),
        policyVersionId: __expectString(output.policyVersionId),
    };
};
const deserializeAws_restJson1PolicyVersions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PolicyVersion(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1Ports = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectInt32(entry);
    });
    return retVal;
};
const deserializeAws_restJson1PresignedUrlConfig = (output, context) => {
    return {
        expiresInSec: __expectLong(output.expiresInSec),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1Principals = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ProcessingTargetNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1Protocols = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ProvisioningHook = (output, context) => {
    return {
        payloadVersion: __expectString(output.payloadVersion),
        targetArn: __expectString(output.targetArn),
    };
};
const deserializeAws_restJson1ProvisioningTemplateListing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ProvisioningTemplateSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ProvisioningTemplateSummary = (output, context) => {
    return {
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        description: __expectString(output.description),
        enabled: __expectBoolean(output.enabled),
        lastModifiedDate: output.lastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
            : undefined,
        templateArn: __expectString(output.templateArn),
        templateName: __expectString(output.templateName),
        type: __expectString(output.type),
    };
};
const deserializeAws_restJson1ProvisioningTemplateVersionListing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ProvisioningTemplateVersionSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ProvisioningTemplateVersionSummary = (output, context) => {
    return {
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        isDefaultVersion: __expectBoolean(output.isDefaultVersion),
        versionId: __expectInt32(output.versionId),
    };
};
const deserializeAws_restJson1PublicKeyMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1PublishFindingToSnsParams = (output, context) => {
    return {
        topicArn: __expectString(output.topicArn),
    };
};
const deserializeAws_restJson1PutAssetPropertyValueEntry = (output, context) => {
    return {
        assetId: __expectString(output.assetId),
        entryId: __expectString(output.entryId),
        propertyAlias: __expectString(output.propertyAlias),
        propertyId: __expectString(output.propertyId),
        propertyValues: output.propertyValues != null
            ? deserializeAws_restJson1AssetPropertyValueList(output.propertyValues, context)
            : undefined,
    };
};
const deserializeAws_restJson1PutAssetPropertyValueEntryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PutAssetPropertyValueEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1PutItemInput = (output, context) => {
    return {
        tableName: __expectString(output.tableName),
    };
};
const deserializeAws_restJson1RateIncreaseCriteria = (output, context) => {
    return {
        numberOfNotifiedThings: __expectInt32(output.numberOfNotifiedThings),
        numberOfSucceededThings: __expectInt32(output.numberOfSucceededThings),
    };
};
const deserializeAws_restJson1ReasonForNonComplianceCodes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1RegistrationConfig = (output, context) => {
    return {
        roleArn: __expectString(output.roleArn),
        templateBody: __expectString(output.templateBody),
        templateName: __expectString(output.templateName),
    };
};
const deserializeAws_restJson1RelatedResource = (output, context) => {
    return {
        additionalInfo: output.additionalInfo != null ? deserializeAws_restJson1StringMap(output.additionalInfo, context) : undefined,
        resourceIdentifier: output.resourceIdentifier != null
            ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
            : undefined,
        resourceType: __expectString(output.resourceType),
    };
};
const deserializeAws_restJson1RelatedResources = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1RelatedResource(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ReplaceDefaultPolicyVersionParams = (output, context) => {
    return {
        templateName: __expectString(output.templateName),
    };
};
const deserializeAws_restJson1RepublishAction = (output, context) => {
    return {
        headers: output.headers != null ? deserializeAws_restJson1MqttHeaders(output.headers, context) : undefined,
        qos: __expectInt32(output.qos),
        roleArn: __expectString(output.roleArn),
        topic: __expectString(output.topic),
    };
};
const deserializeAws_restJson1ResourceArns = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1ResourceIdentifier = (output, context) => {
    return {
        account: __expectString(output.account),
        caCertificateId: __expectString(output.caCertificateId),
        clientId: __expectString(output.clientId),
        cognitoIdentityPoolId: __expectString(output.cognitoIdentityPoolId),
        deviceCertificateArn: __expectString(output.deviceCertificateArn),
        deviceCertificateId: __expectString(output.deviceCertificateId),
        iamRoleArn: __expectString(output.iamRoleArn),
        issuerCertificateIdentifier: output.issuerCertificateIdentifier != null
            ? deserializeAws_restJson1IssuerCertificateIdentifier(output.issuerCertificateIdentifier, context)
            : undefined,
        policyVersionIdentifier: output.policyVersionIdentifier != null
            ? deserializeAws_restJson1PolicyVersionIdentifier(output.policyVersionIdentifier, context)
            : undefined,
        roleAliasArn: __expectString(output.roleAliasArn),
    };
};
const deserializeAws_restJson1Resources = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1RetryCriteria = (output, context) => {
    return {
        failureType: __expectString(output.failureType),
        numberOfRetries: __expectInt32(output.numberOfRetries),
    };
};
const deserializeAws_restJson1RetryCriteriaList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1RetryCriteria(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1RoleAliasDescription = (output, context) => {
    return {
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        credentialDurationSeconds: __expectInt32(output.credentialDurationSeconds),
        lastModifiedDate: output.lastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
            : undefined,
        owner: __expectString(output.owner),
        roleAlias: __expectString(output.roleAlias),
        roleAliasArn: __expectString(output.roleAliasArn),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1RoleAliases = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1S3Action = (output, context) => {
    return {
        bucketName: __expectString(output.bucketName),
        cannedAcl: __expectString(output.cannedAcl),
        key: __expectString(output.key),
        roleArn: __expectString(output.roleArn),
    };
};
const deserializeAws_restJson1S3Destination = (output, context) => {
    return {
        bucket: __expectString(output.bucket),
        prefix: __expectString(output.prefix),
    };
};
const deserializeAws_restJson1S3FileUrlList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1S3Location = (output, context) => {
    return {
        bucket: __expectString(output.bucket),
        key: __expectString(output.key),
        version: __expectString(output.version),
    };
};
const deserializeAws_restJson1SalesforceAction = (output, context) => {
    return {
        token: __expectString(output.token),
        url: __expectString(output.url),
    };
};
const deserializeAws_restJson1ScheduledAuditMetadata = (output, context) => {
    return {
        dayOfMonth: __expectString(output.dayOfMonth),
        dayOfWeek: __expectString(output.dayOfWeek),
        frequency: __expectString(output.frequency),
        scheduledAuditArn: __expectString(output.scheduledAuditArn),
        scheduledAuditName: __expectString(output.scheduledAuditName),
    };
};
const deserializeAws_restJson1ScheduledAuditMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ScheduledAuditMetadata(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ScheduledJobRollout = (output, context) => {
    return {
        startTime: __expectString(output.startTime),
    };
};
const deserializeAws_restJson1ScheduledJobRolloutList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ScheduledJobRollout(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1SchedulingConfig = (output, context) => {
    return {
        endBehavior: __expectString(output.endBehavior),
        endTime: __expectString(output.endTime),
        maintenanceWindows: output.maintenanceWindows != null
            ? deserializeAws_restJson1MaintenanceWindows(output.maintenanceWindows, context)
            : undefined,
        startTime: __expectString(output.startTime),
    };
};
const deserializeAws_restJson1SearchableAttributes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1SecurityGroupList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1SecurityProfileIdentifier = (output, context) => {
    return {
        arn: __expectString(output.arn),
        name: __expectString(output.name),
    };
};
const deserializeAws_restJson1SecurityProfileIdentifiers = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1SecurityProfileIdentifier(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1SecurityProfileTarget = (output, context) => {
    return {
        arn: __expectString(output.arn),
    };
};
const deserializeAws_restJson1SecurityProfileTargetMapping = (output, context) => {
    return {
        securityProfileIdentifier: output.securityProfileIdentifier != null
            ? deserializeAws_restJson1SecurityProfileIdentifier(output.securityProfileIdentifier, context)
            : undefined,
        target: output.target != null ? deserializeAws_restJson1SecurityProfileTarget(output.target, context) : undefined,
    };
};
const deserializeAws_restJson1SecurityProfileTargetMappings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1SecurityProfileTargetMapping(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1SecurityProfileTargets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1SecurityProfileTarget(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ServerCertificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ServerCertificateSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ServerCertificateSummary = (output, context) => {
    return {
        serverCertificateArn: __expectString(output.serverCertificateArn),
        serverCertificateStatus: __expectString(output.serverCertificateStatus),
        serverCertificateStatusDetail: __expectString(output.serverCertificateStatusDetail),
    };
};
const deserializeAws_restJson1SigningProfileParameter = (output, context) => {
    return {
        certificateArn: __expectString(output.certificateArn),
        certificatePathOnDevice: __expectString(output.certificatePathOnDevice),
        platform: __expectString(output.platform),
    };
};
const deserializeAws_restJson1SigV4Authorization = (output, context) => {
    return {
        roleArn: __expectString(output.roleArn),
        serviceName: __expectString(output.serviceName),
        signingRegion: __expectString(output.signingRegion),
    };
};
const deserializeAws_restJson1SnsAction = (output, context) => {
    return {
        messageFormat: __expectString(output.messageFormat),
        roleArn: __expectString(output.roleArn),
        targetArn: __expectString(output.targetArn),
    };
};
const deserializeAws_restJson1SqsAction = (output, context) => {
    return {
        queueUrl: __expectString(output.queueUrl),
        roleArn: __expectString(output.roleArn),
        useBase64: __expectBoolean(output.useBase64),
    };
};
const deserializeAws_restJson1StartSigningJobParameter = (output, context) => {
    return {
        destination: output.destination != null ? deserializeAws_restJson1Destination(output.destination, context) : undefined,
        signingProfileName: __expectString(output.signingProfileName),
        signingProfileParameter: output.signingProfileParameter != null
            ? deserializeAws_restJson1SigningProfileParameter(output.signingProfileParameter, context)
            : undefined,
    };
};
const deserializeAws_restJson1StatisticalThreshold = (output, context) => {
    return {
        statistic: __expectString(output.statistic),
    };
};
const deserializeAws_restJson1Statistics = (output, context) => {
    return {
        average: __limitedParseDouble(output.average),
        count: __expectInt32(output.count),
        maximum: __limitedParseDouble(output.maximum),
        minimum: __limitedParseDouble(output.minimum),
        stdDeviation: __limitedParseDouble(output.stdDeviation),
        sum: __limitedParseDouble(output.sum),
        sumOfSquares: __limitedParseDouble(output.sumOfSquares),
        variance: __limitedParseDouble(output.variance),
    };
};
const deserializeAws_restJson1StepFunctionsAction = (output, context) => {
    return {
        executionNamePrefix: __expectString(output.executionNamePrefix),
        roleArn: __expectString(output.roleArn),
        stateMachineName: __expectString(output.stateMachineName),
    };
};
const deserializeAws_restJson1_Stream = (output, context) => {
    return {
        fileId: __expectInt32(output.fileId),
        streamId: __expectString(output.streamId),
    };
};
const deserializeAws_restJson1StreamFile = (output, context) => {
    return {
        fileId: __expectInt32(output.fileId),
        s3Location: output.s3Location != null ? deserializeAws_restJson1S3Location(output.s3Location, context) : undefined,
    };
};
const deserializeAws_restJson1StreamFiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1StreamFile(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1StreamInfo = (output, context) => {
    return {
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        description: __expectString(output.description),
        files: output.files != null ? deserializeAws_restJson1StreamFiles(output.files, context) : undefined,
        lastUpdatedAt: output.lastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
            : undefined,
        roleArn: __expectString(output.roleArn),
        streamArn: __expectString(output.streamArn),
        streamId: __expectString(output.streamId),
        streamVersion: __expectInt32(output.streamVersion),
    };
};
const deserializeAws_restJson1StreamsSummary = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1StreamSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1StreamSummary = (output, context) => {
    return {
        description: __expectString(output.description),
        streamArn: __expectString(output.streamArn),
        streamId: __expectString(output.streamId),
        streamVersion: __expectInt32(output.streamVersion),
    };
};
const deserializeAws_restJson1StringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1StringMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1SubnetIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1Tag = (output, context) => {
    return {
        Key: __expectString(output.Key),
        Value: __expectString(output.Value),
    };
};
const deserializeAws_restJson1TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Tag(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1TargetAuditCheckNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1Targets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1TargetViolationIdsForDetectMitigationActions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1TaskIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1TaskStatistics = (output, context) => {
    return {
        canceledChecks: __expectInt32(output.canceledChecks),
        compliantChecks: __expectInt32(output.compliantChecks),
        failedChecks: __expectInt32(output.failedChecks),
        inProgressChecks: __expectInt32(output.inProgressChecks),
        nonCompliantChecks: __expectInt32(output.nonCompliantChecks),
        totalChecks: __expectInt32(output.totalChecks),
        waitingForDataCollectionChecks: __expectInt32(output.waitingForDataCollectionChecks),
    };
};
const deserializeAws_restJson1TaskStatisticsForAuditCheck = (output, context) => {
    return {
        canceledFindingsCount: __expectLong(output.canceledFindingsCount),
        failedFindingsCount: __expectLong(output.failedFindingsCount),
        skippedFindingsCount: __expectLong(output.skippedFindingsCount),
        succeededFindingsCount: __expectLong(output.succeededFindingsCount),
        totalFindingsCount: __expectLong(output.totalFindingsCount),
    };
};
const deserializeAws_restJson1ThingAttribute = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_restJson1Attributes(output.attributes, context) : undefined,
        thingArn: __expectString(output.thingArn),
        thingName: __expectString(output.thingName),
        thingTypeName: __expectString(output.thingTypeName),
        version: __expectLong(output.version),
    };
};
const deserializeAws_restJson1ThingAttributeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingAttribute(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ThingConnectivity = (output, context) => {
    return {
        connected: __expectBoolean(output.connected),
        disconnectReason: __expectString(output.disconnectReason),
        timestamp: __expectLong(output.timestamp),
    };
};
const deserializeAws_restJson1ThingDocument = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_restJson1Attributes(output.attributes, context) : undefined,
        connectivity: output.connectivity != null ? deserializeAws_restJson1ThingConnectivity(output.connectivity, context) : undefined,
        deviceDefender: __expectString(output.deviceDefender),
        shadow: __expectString(output.shadow),
        thingGroupNames: output.thingGroupNames != null
            ? deserializeAws_restJson1ThingGroupNameList(output.thingGroupNames, context)
            : undefined,
        thingId: __expectString(output.thingId),
        thingName: __expectString(output.thingName),
        thingTypeName: __expectString(output.thingTypeName),
    };
};
const deserializeAws_restJson1ThingDocumentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingDocument(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ThingGroupDocument = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_restJson1Attributes(output.attributes, context) : undefined,
        parentGroupNames: output.parentGroupNames != null
            ? deserializeAws_restJson1ThingGroupNameList(output.parentGroupNames, context)
            : undefined,
        thingGroupDescription: __expectString(output.thingGroupDescription),
        thingGroupId: __expectString(output.thingGroupId),
        thingGroupName: __expectString(output.thingGroupName),
    };
};
const deserializeAws_restJson1ThingGroupDocumentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingGroupDocument(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ThingGroupIndexingConfiguration = (output, context) => {
    return {
        customFields: output.customFields != null ? deserializeAws_restJson1Fields(output.customFields, context) : undefined,
        managedFields: output.managedFields != null ? deserializeAws_restJson1Fields(output.managedFields, context) : undefined,
        thingGroupIndexingMode: __expectString(output.thingGroupIndexingMode),
    };
};
const deserializeAws_restJson1ThingGroupMetadata = (output, context) => {
    return {
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        parentGroupName: __expectString(output.parentGroupName),
        rootToParentThingGroups: output.rootToParentThingGroups != null
            ? deserializeAws_restJson1ThingGroupNameAndArnList(output.rootToParentThingGroups, context)
            : undefined,
    };
};
const deserializeAws_restJson1ThingGroupNameAndArnList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1GroupNameAndArn(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ThingGroupNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ThingGroupNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ThingGroupProperties = (output, context) => {
    return {
        attributePayload: output.attributePayload != null
            ? deserializeAws_restJson1AttributePayload(output.attributePayload, context)
            : undefined,
        thingGroupDescription: __expectString(output.thingGroupDescription),
    };
};
const deserializeAws_restJson1ThingIndexingConfiguration = (output, context) => {
    return {
        customFields: output.customFields != null ? deserializeAws_restJson1Fields(output.customFields, context) : undefined,
        deviceDefenderIndexingMode: __expectString(output.deviceDefenderIndexingMode),
        filter: output.filter != null ? deserializeAws_restJson1IndexingFilter(output.filter, context) : undefined,
        managedFields: output.managedFields != null ? deserializeAws_restJson1Fields(output.managedFields, context) : undefined,
        namedShadowIndexingMode: __expectString(output.namedShadowIndexingMode),
        thingConnectivityIndexingMode: __expectString(output.thingConnectivityIndexingMode),
        thingIndexingMode: __expectString(output.thingIndexingMode),
    };
};
const deserializeAws_restJson1ThingNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ThingTypeDefinition = (output, context) => {
    return {
        thingTypeArn: __expectString(output.thingTypeArn),
        thingTypeMetadata: output.thingTypeMetadata != null
            ? deserializeAws_restJson1ThingTypeMetadata(output.thingTypeMetadata, context)
            : undefined,
        thingTypeName: __expectString(output.thingTypeName),
        thingTypeProperties: output.thingTypeProperties != null
            ? deserializeAws_restJson1ThingTypeProperties(output.thingTypeProperties, context)
            : undefined,
    };
};
const deserializeAws_restJson1ThingTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ThingTypeDefinition(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ThingTypeMetadata = (output, context) => {
    return {
        creationDate: output.creationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
            : undefined,
        deprecated: __expectBoolean(output.deprecated),
        deprecationDate: output.deprecationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.deprecationDate)))
            : undefined,
    };
};
const deserializeAws_restJson1ThingTypeProperties = (output, context) => {
    return {
        searchableAttributes: output.searchableAttributes != null
            ? deserializeAws_restJson1SearchableAttributes(output.searchableAttributes, context)
            : undefined,
        thingTypeDescription: __expectString(output.thingTypeDescription),
    };
};
const deserializeAws_restJson1TimeoutConfig = (output, context) => {
    return {
        inProgressTimeoutInMinutes: __expectLong(output.inProgressTimeoutInMinutes),
    };
};
const deserializeAws_restJson1TimestreamAction = (output, context) => {
    return {
        databaseName: __expectString(output.databaseName),
        dimensions: output.dimensions != null
            ? deserializeAws_restJson1TimestreamDimensionList(output.dimensions, context)
            : undefined,
        roleArn: __expectString(output.roleArn),
        tableName: __expectString(output.tableName),
        timestamp: output.timestamp != null ? deserializeAws_restJson1TimestreamTimestamp(output.timestamp, context) : undefined,
    };
};
const deserializeAws_restJson1TimestreamDimension = (output, context) => {
    return {
        name: __expectString(output.name),
        value: __expectString(output.value),
    };
};
const deserializeAws_restJson1TimestreamDimensionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1TimestreamDimension(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1TimestreamTimestamp = (output, context) => {
    return {
        unit: __expectString(output.unit),
        value: __expectString(output.value),
    };
};
const deserializeAws_restJson1TopicRule = (output, context) => {
    return {
        actions: output.actions != null ? deserializeAws_restJson1ActionList(output.actions, context) : undefined,
        awsIotSqlVersion: __expectString(output.awsIotSqlVersion),
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        description: __expectString(output.description),
        errorAction: output.errorAction != null ? deserializeAws_restJson1Action(output.errorAction, context) : undefined,
        ruleDisabled: __expectBoolean(output.ruleDisabled),
        ruleName: __expectString(output.ruleName),
        sql: __expectString(output.sql),
    };
};
const deserializeAws_restJson1TopicRuleDestination = (output, context) => {
    return {
        arn: __expectString(output.arn),
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        httpUrlProperties: output.httpUrlProperties != null
            ? deserializeAws_restJson1HttpUrlDestinationProperties(output.httpUrlProperties, context)
            : undefined,
        lastUpdatedAt: output.lastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
            : undefined,
        status: __expectString(output.status),
        statusReason: __expectString(output.statusReason),
        vpcProperties: output.vpcProperties != null
            ? deserializeAws_restJson1VpcDestinationProperties(output.vpcProperties, context)
            : undefined,
    };
};
const deserializeAws_restJson1TopicRuleDestinationSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1TopicRuleDestinationSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1TopicRuleDestinationSummary = (output, context) => {
    return {
        arn: __expectString(output.arn),
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        httpUrlSummary: output.httpUrlSummary != null
            ? deserializeAws_restJson1HttpUrlDestinationSummary(output.httpUrlSummary, context)
            : undefined,
        lastUpdatedAt: output.lastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
            : undefined,
        status: __expectString(output.status),
        statusReason: __expectString(output.statusReason),
        vpcDestinationSummary: output.vpcDestinationSummary != null
            ? deserializeAws_restJson1VpcDestinationSummary(output.vpcDestinationSummary, context)
            : undefined,
    };
};
const deserializeAws_restJson1TopicRuleList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1TopicRuleListItem(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1TopicRuleListItem = (output, context) => {
    return {
        createdAt: output.createdAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt))) : undefined,
        ruleArn: __expectString(output.ruleArn),
        ruleDisabled: __expectBoolean(output.ruleDisabled),
        ruleName: __expectString(output.ruleName),
        topicPattern: __expectString(output.topicPattern),
    };
};
const deserializeAws_restJson1TransferData = (output, context) => {
    return {
        acceptDate: output.acceptDate != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.acceptDate))) : undefined,
        rejectDate: output.rejectDate != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.rejectDate))) : undefined,
        rejectReason: __expectString(output.rejectReason),
        transferDate: output.transferDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.transferDate)))
            : undefined,
        transferMessage: __expectString(output.transferMessage),
    };
};
const deserializeAws_restJson1UpdateCACertificateParams = (output, context) => {
    return {
        action: __expectString(output.action),
    };
};
const deserializeAws_restJson1UpdateDeviceCertificateParams = (output, context) => {
    return {
        action: __expectString(output.action),
    };
};
const deserializeAws_restJson1UserProperties = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1UserProperty(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1UserProperty = (output, context) => {
    return {
        key: __expectString(output.key),
        value: __expectString(output.value),
    };
};
const deserializeAws_restJson1ValidationError = (output, context) => {
    return {
        errorMessage: __expectString(output.errorMessage),
    };
};
const deserializeAws_restJson1ValidationErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ValidationError(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ViolationEvent = (output, context) => {
    return {
        behavior: output.behavior != null ? deserializeAws_restJson1Behavior(output.behavior, context) : undefined,
        metricValue: output.metricValue != null ? deserializeAws_restJson1MetricValue(output.metricValue, context) : undefined,
        securityProfileName: __expectString(output.securityProfileName),
        thingName: __expectString(output.thingName),
        verificationState: __expectString(output.verificationState),
        verificationStateDescription: __expectString(output.verificationStateDescription),
        violationEventAdditionalInfo: output.violationEventAdditionalInfo != null
            ? deserializeAws_restJson1ViolationEventAdditionalInfo(output.violationEventAdditionalInfo, context)
            : undefined,
        violationEventTime: output.violationEventTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.violationEventTime)))
            : undefined,
        violationEventType: __expectString(output.violationEventType),
        violationId: __expectString(output.violationId),
    };
};
const deserializeAws_restJson1ViolationEventAdditionalInfo = (output, context) => {
    return {
        confidenceLevel: __expectString(output.confidenceLevel),
    };
};
const deserializeAws_restJson1ViolationEventOccurrenceRange = (output, context) => {
    return {
        endTime: output.endTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.endTime))) : undefined,
        startTime: output.startTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startTime))) : undefined,
    };
};
const deserializeAws_restJson1ViolationEvents = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ViolationEvent(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1VpcDestinationProperties = (output, context) => {
    return {
        roleArn: __expectString(output.roleArn),
        securityGroups: output.securityGroups != null
            ? deserializeAws_restJson1SecurityGroupList(output.securityGroups, context)
            : undefined,
        subnetIds: output.subnetIds != null ? deserializeAws_restJson1SubnetIdList(output.subnetIds, context) : undefined,
        vpcId: __expectString(output.vpcId),
    };
};
const deserializeAws_restJson1VpcDestinationSummary = (output, context) => {
    return {
        roleArn: __expectString(output.roleArn),
        securityGroups: output.securityGroups != null
            ? deserializeAws_restJson1SecurityGroupList(output.securityGroups, context)
            : undefined,
        subnetIds: output.subnetIds != null ? deserializeAws_restJson1SubnetIdList(output.subnetIds, context) : undefined,
        vpcId: __expectString(output.vpcId),
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
